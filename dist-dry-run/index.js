var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name17 in all)
    __defProp(target, name17, { get: all[name17], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name17) {
  return new Error(`[unenv] ${name17} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name17) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name17);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedAsync(name17) {
  const fn = /* @__PURE__ */ notImplemented(name17);
  fn.__promisify__ = () => /* @__PURE__ */ notImplemented(name17 + ".__promisify__");
  fn.native = fn;
  return fn;
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name17) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name17} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedAsync, "notImplementedAsync");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name17, options) {
        this.name = name17;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name17, type) {
        return this._entries.filter((e) => e.name === name17 && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name17, options) {
        const entry = new PerformanceMark(name17, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge2() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      __name(merge2, "merge");
      function subexp(str) {
        return "(?:" + str + ")";
      }
      __name(subexp, "subexp");
      function typeOf(o2) {
        return o2 === void 0 ? "undefined" : o2 === null ? "null" : Object.prototype.toString.call(o2).split(" ").pop().split("]").shift().toLowerCase();
      }
      __name(typeOf, "typeOf");
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      __name(toUpperCase, "toUpperCase");
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      __name(toArray, "toArray");
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      __name(assign, "assign");
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      __name(buildExps, "buildExps");
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i2) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i2 && _arr.length === i2) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        __name(sliceIterator, "sliceIterator");
        return function(arr, i2) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i2);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = /* @__PURE__ */ __name(function(arr) {
        if (Array.isArray(arr)) {
          for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) arr2[i2] = arr[i2];
          return arr2;
        } else {
          return Array.from(arr);
        }
      }, "toConsumableArray");
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      __name(error$1, "error$1");
      function map2(array2, fn) {
        var result = [];
        var length = array2.length;
        while (length--) {
          result[length] = fn(array2[length]);
        }
        return result;
      }
      __name(map2, "map");
      function mapDomain(string4, fn) {
        var parts = string4.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string4 = parts[1];
        }
        string4 = string4.replace(regexSeparators, ".");
        var labels = string4.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      __name(mapDomain, "mapDomain");
      function ucs2decode(string4) {
        var output = [];
        var counter = 0;
        var length = string4.length;
        while (counter < length) {
          var value = string4.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string4.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      __name(ucs2decode, "ucs2decode");
      var ucs2encode = /* @__PURE__ */ __name(function ucs2encode2(array2) {
        return String.fromCodePoint.apply(String, toConsumableArray(array2));
      }, "ucs2encode");
      var basicToDigit = /* @__PURE__ */ __name(function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }, "basicToDigit");
      var digitToBasic = /* @__PURE__ */ __name(function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }, "digitToBasic");
      var adapt = /* @__PURE__ */ __name(function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }, "adapt");
      var decode = /* @__PURE__ */ __name(function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i2 = 0;
        var n2 = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i2;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i2) / w)) {
              error$1("overflow");
            }
            i2 += digit * w;
            var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t2) {
              break;
            }
            var baseMinusT = base - t2;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i2 - oldi, out, oldi == 0);
          if (floor(i2 / out) > maxInt - n2) {
            error$1("overflow");
          }
          n2 += floor(i2 / out);
          i2 %= out;
          output.splice(i2++, 0, n2);
        }
        return String.fromCodePoint.apply(String, output);
      }, "decode");
      var encode = /* @__PURE__ */ __name(function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n2 = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n2 && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n2) * handledCPCountPlusOne;
          n2 = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n2 && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n2) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t2) {
                    break;
                  }
                  var qMinusT = q - t2;
                  var baseMinusT = base - t2;
                  output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n2;
        }
        return output.join("");
      }, "encode");
      var toUnicode = /* @__PURE__ */ __name(function toUnicode2(input) {
        return mapDomain(input, function(string4) {
          return regexPunycode.test(string4) ? decode(string4.slice(4).toLowerCase()) : string4;
        });
      }, "toUnicode");
      var toASCII = /* @__PURE__ */ __name(function toASCII2(input) {
        return mapDomain(input, function(string4) {
          return regexNonASCII.test(string4) ? "xn--" + encode(string4) : string4;
        });
      }, "toASCII");
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      __name(pctEncChar, "pctEncChar");
      function pctDecChars(str) {
        var newStr = "";
        var i2 = 0;
        var il = str.length;
        while (i2 < il) {
          var c = parseInt(str.substr(i2 + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i2 += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i2 >= 6) {
              var c2 = parseInt(str.substr(i2 + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i2, 6);
            }
            i2 += 6;
          } else if (c >= 224) {
            if (il - i2 >= 9) {
              var _c = parseInt(str.substr(i2 + 4, 2), 16);
              var c3 = parseInt(str.substr(i2 + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i2, 9);
            }
            i2 += 9;
          } else {
            newStr += str.substr(i2, 3);
            i2 += 3;
          }
        }
        return newStr;
      }
      __name(pctDecChars, "pctDecChars");
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        __name(decodeUnreserved2, "decodeUnreserved");
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      __name(_normalizeComponentEncoding, "_normalizeComponentEncoding");
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      __name(_stripLeadingZeros, "_stripLeadingZeros");
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      __name(_normalizeIPv4, "_normalizeIPv4");
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a2, b) {
            return b.length - a2.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      __name(_normalizeIPv6, "_normalizeIPv6");
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse3(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      __name(parse3, "parse");
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      __name(_recomposeAuthority, "_recomposeAuthority");
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s2 = im[0];
              input = input.slice(s2.length);
              output.push(s2);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      __name(removeDotSegments, "removeDotSegments");
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s2 = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s2 = removeDotSegments(s2);
          }
          if (authority === void 0) {
            s2 = s2.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s2);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      __name(serialize, "serialize");
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse3(serialize(base2, options), options);
          relative = parse3(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      __name(resolveComponents, "resolveComponents");
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      __name(resolve, "resolve");
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse3(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse3(serialize(uri, options), options);
        }
        return uri;
      }
      __name(normalize, "normalize");
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse3(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse3(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      __name(equal, "equal");
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      __name(escapeComponent, "escapeComponent");
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      __name(unescapeComponent, "unescapeComponent");
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: /* @__PURE__ */ __name(function parse4(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        }, "parse"),
        serialize: /* @__PURE__ */ __name(function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }, "serialize")
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      __name(isSecure, "isSecure");
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: /* @__PURE__ */ __name(function parse4(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        }, "parse"),
        serialize: /* @__PURE__ */ __name(function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }, "serialize")
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      __name(decodeUnreserved, "decodeUnreserved");
      var handler$4 = {
        scheme: "mailto",
        parse: /* @__PURE__ */ __name(function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        }, "parse$$1"),
        serialize: /* @__PURE__ */ __name(function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain3 = toAddr.slice(atIdx + 1);
              try {
                domain3 = !options.iri ? punycode.toASCII(unescapeComponent(domain3, options).toLowerCase()) : punycode.toUnicode(domain3);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain3;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name17 in headers) {
            if (headers[name17] !== O[name17]) {
              fields.push(name17.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name17].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }, "serialize$$1")
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: /* @__PURE__ */ __name(function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        }, "parse$$1"),
        serialize: /* @__PURE__ */ __name(function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }, "serialize$$1")
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: /* @__PURE__ */ __name(function parse4(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        }, "parse"),
        serialize: /* @__PURE__ */ __name(function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }, "serialize")
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse3;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function equal(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length, i2, keys2;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
        keys2 = Object.keys(a2);
        length = keys2.length;
        if (length !== Object.keys(b).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!equal(a2[key], b[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    }, "equal");
  }
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/lib/compile/ucs2length.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320) pos++;
        }
      }
      return length;
    }, "ucs2length");
  }
});

// node_modules/ajv/lib/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/lib/compile/util.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o2, to) {
      to = to || {};
      for (var key in o2) to[key] = o2[key];
      return to;
    }
    __name(copy, "copy");
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK2 = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK2 + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK2 + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK2 + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK2 + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    __name(checkDataType, "checkDataType");
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number) delete types.integer;
          for (var t2 in types)
            code += (code ? " && " : "") + checkDataType(t2, data, strictNumbers, true);
          return code;
      }
    }
    __name(checkDataTypes, "checkDataTypes");
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i2 = 0; i2 < dataTypes.length; i2++) {
          var t2 = dataTypes[i2];
          if (COERCE_TO_TYPES[t2]) types[types.length] = t2;
          else if (optionCoerceTypes === "array" && t2 === "array") types[types.length] = t2;
        }
        if (types.length) return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    __name(coerceToTypes, "coerceToTypes");
    function toHash(arr) {
      var hash = {};
      for (var i2 = 0; i2 < arr.length; i2++) hash[arr[i2]] = true;
      return hash;
    }
    __name(toHash, "toHash");
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    __name(getProperty, "getProperty");
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    __name(escapeQuotes, "escapeQuotes");
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    __name(varOccurences, "varOccurences");
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    __name(varReplace, "varReplace");
    function schemaHasRules(schema115, rules) {
      if (typeof schema115 == "boolean") return !schema115;
      for (var key in schema115) if (rules[key]) return true;
    }
    __name(schemaHasRules, "schemaHasRules");
    function schemaHasRulesExcept(schema115, rules, exceptKeyword) {
      if (typeof schema115 == "boolean") return !schema115 && exceptKeyword != "not";
      for (var key in schema115) if (key != exceptKeyword && rules[key]) return true;
    }
    __name(schemaHasRulesExcept, "schemaHasRulesExcept");
    function schemaUnknownRules(schema115, rules) {
      if (typeof schema115 == "boolean") return;
      for (var key in schema115) if (!rules[key]) return key;
    }
    __name(schemaUnknownRules, "schemaUnknownRules");
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    __name(toQuotedString, "toQuotedString");
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path2 = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path2);
    }
    __name(getPathExpr, "getPathExpr");
    function getPath(currentPath, prop, jsonPointers) {
      var path2 = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path2);
    }
    __name(getPath, "getPath");
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "") return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer) return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i2 = 0; i2 < segments.length; i2++) {
        var segment = segments[i2];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    __name(getData, "getData");
    function joinPaths(a2, b) {
      if (a2 == '""') return b;
      return (a2 + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    __name(joinPaths, "joinPaths");
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    __name(unescapeFragment, "unescapeFragment");
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    __name(escapeFragment, "escapeFragment");
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    __name(escapeJsonPointer, "escapeJsonPointer");
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    __name(unescapeJsonPointer, "unescapeJsonPointer");
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "node_modules/ajv/lib/compile/schema_obj.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util3 = require_util();
    module.exports = SchemaObject;
    function SchemaObject(obj) {
      util3.copy(obj, this);
    }
    __name(SchemaObject, "SchemaObject");
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var traverse = module.exports = function(schema115, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema115, "", schema115);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema115, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema115 && typeof schema115 == "object" && !Array.isArray(schema115)) {
        pre(schema115, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema115) {
          var sch = schema115[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i2 = 0; i2 < sch.length; i2++)
                _traverse(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema115, i2);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema115, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema115);
          }
        }
        post(schema115, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    __name(_traverse, "_traverse");
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    __name(escapeJsonPtr, "escapeJsonPtr");
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/lib/compile/resolve.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util3 = require_util();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal]) refVal = this._refs[refVal];
        else return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema115, v, baseId;
      if (res) {
        schema115 = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema115 instanceof SchemaObject) {
        v = schema115.validate || compile.call(this, schema115.schema, root, void 0, baseId);
      } else if (schema115 !== void 0) {
        v = inlineRef(schema115, this._opts.inlineRefs) ? schema115 : compile.call(this, schema115, root, void 0, baseId);
      }
      return v;
    }
    __name(resolve, "resolve");
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    __name(resolveSchema, "resolveSchema");
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema115 = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema115);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema115, root);
      }
    }
    __name(resolveRecursive, "resolveRecursive");
    var PREVENT_SCOPE_CHANGE = util3.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema115, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/") return;
      var parts = parsedRef.fragment.split("/");
      for (var i2 = 1; i2 < parts.length; i2++) {
        var part = parts[i2];
        if (part) {
          part = util3.unescapeFragment(part);
          schema115 = schema115[part];
          if (schema115 === void 0) break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema115);
            if (id) baseId = resolveUrl(baseId, id);
            if (schema115.$ref) {
              var $ref = resolveUrl(baseId, schema115.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema115 = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema115 !== void 0 && schema115 !== root.schema)
        return { schema: schema115, root, baseId };
    }
    __name(getJsonPointer, "getJsonPointer");
    var SIMPLE_INLINED = util3.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema115, limit) {
      if (limit === false) return false;
      if (limit === void 0 || limit === true) return checkNoRef(schema115);
      else if (limit) return countKeys(schema115) <= limit;
    }
    __name(inlineRef, "inlineRef");
    function checkNoRef(schema115) {
      var item;
      if (Array.isArray(schema115)) {
        for (var i2 = 0; i2 < schema115.length; i2++) {
          item = schema115[i2];
          if (typeof item == "object" && !checkNoRef(item)) return false;
        }
      } else {
        for (var key in schema115) {
          if (key == "$ref") return false;
          item = schema115[key];
          if (typeof item == "object" && !checkNoRef(item)) return false;
        }
      }
      return true;
    }
    __name(checkNoRef, "checkNoRef");
    function countKeys(schema115) {
      var count3 = 0, item;
      if (Array.isArray(schema115)) {
        for (var i2 = 0; i2 < schema115.length; i2++) {
          item = schema115[i2];
          if (typeof item == "object") count3 += countKeys(item);
          if (count3 == Infinity) return Infinity;
        }
      } else {
        for (var key in schema115) {
          if (key == "$ref") return Infinity;
          if (SIMPLE_INLINED[key]) {
            count3++;
          } else {
            item = schema115[key];
            if (typeof item == "object") count3 += countKeys(item) + 1;
            if (count3 == Infinity) return Infinity;
          }
        }
      }
      return count3;
    }
    __name(countKeys, "countKeys");
    function getFullPath(id, normalize) {
      if (normalize !== false) id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    __name(getFullPath, "getFullPath");
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    __name(_getFullPath, "_getFullPath");
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    __name(normalizeId, "normalizeId");
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    __name(resolveUrl, "resolveUrl");
    function resolveIds(schema115) {
      var schemaId = normalizeId(this._getId(schema115));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema115, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "") return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util3.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string") refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
    __name(resolveIds, "resolveIds");
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "node_modules/ajv/lib/compile/error_classes.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var resolve = require_resolve();
    module.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    __name(ValidationError, "ValidationError");
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    __name(MissingRefError, "MissingRefError");
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
    __name(errorSubclass, "errorSubclass");
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function(data, opts) {
      if (!opts) opts = {};
      if (typeof opts === "function") opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a2, b) {
            var aobj = { key: a2, value: node[a2] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return (/* @__PURE__ */ __name(function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i2, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i2 = 0; i2 < node.length; i2++) {
            if (i2) out += ",";
            out += stringify2(node[i2]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys2 = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          var value = stringify2(node[key]);
          if (!value) continue;
          if (out) out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }, "stringify"))(data);
    };
  }
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate = __commonJS({
  "node_modules/ajv/lib/dotjs/validate.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
          else throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
          else throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id) it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async) throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i4 = 0; i4 < rules.length; i4++)
          if ($shouldUseRule(rules[i4])) return true;
      }
      __name($shouldUseGroup, "$shouldUseGroup");
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      __name($shouldUseRule, "$shouldUseRule");
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i4 = 0; i4 < impl.length; i4++)
          if (it.schema[impl[i4]] !== void 0) return true;
      }
      __name($ruleImplementsSomeKeyword, "$ruleImplementsSomeKeyword");
      return out;
    }, "generate_validate");
  }
});

// node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/lib/compile/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var resolve = require_resolve();
    var util3 = require_util();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate();
    var ucs2length = util3.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module.exports = compile;
    function compile(schema115, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema: schema115, refVal, refs };
      var c = checkCompiling.call(this, schema115, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling) return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema115, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode) cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema115, root, baseId);
      }
      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
      }
      __name(callValidate, "callValidate");
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util: util3,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
        var validate;
        try {
          var makeValidate = new Function(
            "self",
            "RULES",
            "formats",
            "root",
            "refVal",
            "defaults",
            "customRules",
            "equal",
            "ucs2length",
            "ValidationError",
            sourceCode
          );
          validate = makeValidate(
            self2,
            RULES,
            formats,
            root,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );
          refVal[0] = validate;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async) validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate;
      }
      __name(localCompile, "localCompile");
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      __name(resolveRef, "resolveRef");
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      __name(addLocalRef, "addLocalRef");
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      __name(removeLocalRef, "removeLocalRef");
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      __name(replaceLocalRef, "replaceLocalRef");
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      __name(resolvedRef, "resolvedRef");
      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === void 0) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return "pattern" + index;
      }
      __name(usePattern, "usePattern");
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util3.toQuotedString(value);
          case "object":
            if (value === null) return "null";
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === void 0) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return "default" + index;
        }
      }
      __name(useDefault, "useDefault");
      function useCustomRule(rule, schema116, parentSchema, it) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema116);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log") self2.logger.error(message);
              else throw new Error(message);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile2) {
          validate = compile2.call(self2, schema116, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self2, schema116, parentSchema, it);
          if (opts.validateSchema !== false) self2.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self2, it, rule.keyword, schema116, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate) return;
        }
        if (validate === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate;
        return {
          code: "customRule" + index,
          validate
        };
      }
      __name(useCustomRule, "useCustomRule");
    }
    __name(compile, "compile");
    function checkCompiling(schema115, root, baseId) {
      var index = compIndex.call(this, schema115, root, baseId);
      if (index >= 0) return { index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema: schema115,
        root,
        baseId
      };
      return { index, compiling: false };
    }
    __name(checkCompiling, "checkCompiling");
    function endCompiling(schema115, root, baseId) {
      var i2 = compIndex.call(this, schema115, root, baseId);
      if (i2 >= 0) this._compilations.splice(i2, 1);
    }
    __name(endCompiling, "endCompiling");
    function compIndex(schema115, root, baseId) {
      for (var i2 = 0; i2 < this._compilations.length; i2++) {
        var c = this._compilations[i2];
        if (c.schema == schema115 && c.root == root && c.baseId == baseId) return i2;
      }
      return -1;
    }
    __name(compIndex, "compIndex");
    function patternCode(i2, patterns) {
      return "var pattern" + i2 + " = new RegExp(" + util3.toQuotedString(patterns[i2]) + ");";
    }
    __name(patternCode, "patternCode");
    function defaultCode(i2) {
      return "var default" + i2 + " = defaults[" + i2 + "];";
    }
    __name(defaultCode, "defaultCode");
    function refValCode(i2, refVal) {
      return refVal[i2] === void 0 ? "" : "var refVal" + i2 + " = refVal[" + i2 + "];";
    }
    __name(refValCode, "refValCode");
    function customRuleCode(i2) {
      return "var customRule" + i2 + " = customRules[" + i2 + "];";
    }
    __name(customRuleCode, "customRuleCode");
    function vars(arr, statement) {
      if (!arr.length) return "";
      var code = "";
      for (var i2 = 0; i2 < arr.length; i2++)
        code += statement(i2, arr);
      return code;
    }
    __name(vars, "vars");
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "node_modules/ajv/lib/cache.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Cache = module.exports = /* @__PURE__ */ __name(function Cache2() {
      this._cache = {};
    }, "Cache");
    Cache.prototype.put = /* @__PURE__ */ __name(function Cache_put(key, value) {
      this._cache[key] = value;
    }, "Cache_put");
    Cache.prototype.get = /* @__PURE__ */ __name(function Cache_get(key) {
      return this._cache[key];
    }, "Cache_get");
    Cache.prototype.del = /* @__PURE__ */ __name(function Cache_del(key) {
      delete this._cache[key];
    }, "Cache_del");
    Cache.prototype.clear = /* @__PURE__ */ __name(function Cache_clear() {
      this._cache = {};
    }, "Cache_clear");
  }
});

// node_modules/ajv/lib/compile/formats.js
var require_formats = __commonJS({
  "node_modules/ajv/lib/compile/formats.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util3 = require_util();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util3.copy(formats[mode]);
    }
    __name(formats, "formats");
    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL2,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date: date5,
      time: time5,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    __name(isLeapYear, "isLeapYear");
    function date5(str) {
      var matches = str.match(DATE);
      if (!matches) return false;
      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    __name(date5, "date");
    function time5(str, full) {
      var matches = str.match(TIME);
      if (!matches) return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    __name(time5, "time");
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date5(dateTime[0]) && time5(dateTime[1], true);
    }
    __name(date_time, "date_time");
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    __name(uri, "uri");
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str)) return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
    __name(regex, "regex");
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/lib/dotjs/ref.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async) throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    }, "generate_ref");
  }
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/lib/dotjs/allOf.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    }, "generate_allOf");
  }
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/lib/dotjs/anyOf.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    }, "generate_anyOf");
  }
});

// node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "node_modules/ajv/lib/dotjs/comment.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    }, "generate_comment");
  }
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "node_modules/ajv/lib/dotjs/const.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate_const");
  }
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/lib/dotjs/contains.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    }, "generate_contains");
  }
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/lib/dotjs/dependencies.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__") continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    }, "generate_dependencies");
  }
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/lib/dotjs/enum.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate_enum");
  }
});

// node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "node_modules/ajv/lib/dotjs/format.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async) throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject) $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate_format");
  }
});

// node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "node_modules/ajv/lib/dotjs/if.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    }, "generate_if");
  }
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "node_modules/ajv/lib/dotjs/items.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    }, "generate_items");
  }
});

// node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "node_modules/ajv/lib/dotjs/_limit.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate__limit");
  }
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitItems.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate__limitItems");
  }
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitLength.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate__limitLength");
  }
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitProperties.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate__limitProperties");
  }
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/lib/dotjs/multipleOf.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate_multipleOf");
  }
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "node_modules/ajv/lib/dotjs/not.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    }, "generate_not");
  }
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/lib/dotjs/oneOf.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    }, "generate_oneOf");
  }
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/lib/dotjs/pattern.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    }, "generate_pattern");
  }
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/lib/dotjs/properties.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      __name(notProto, "notProto");
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    }, "generate_properties");
  }
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/lib/dotjs/propertyNames.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    }, "generate_propertyNames");
  }
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "node_modules/ajv/lib/dotjs/required.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    }, "generate_required");
  }
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/lib/dotjs/uniqueItems.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    }, "generate_uniqueItems");
  }
});

// node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "node_modules/ajv/lib/dotjs/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate()
    };
  }
});

// node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/lib/compile/rules.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ruleModules = require_dotjs();
    var toHash = require_util().toHash;
    module.exports = /* @__PURE__ */ __name(function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group3) {
        group3.rules = group3.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group3.type) RULES.types[group3.type] = group3;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    }, "rules");
  }
});

// node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "node_modules/ajv/lib/data.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i2 = 0; i2 < keywordsJsonPointers.length; i2++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i2].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema115 = keywords[key];
          if (schema115) {
            keywords[key] = {
              anyOf: [
                schema115,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// node_modules/ajv/lib/compile/async.js
var require_async = __commonJS({
  "node_modules/ajv/lib/compile/async.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MissingRefError = require_error_classes().MissingRef;
    module.exports = compileAsync;
    function compileAsync(schema115, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema115).then(function() {
        var schemaObj = self2._addSchema(schema115, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(
          function(v) {
            callback(null, v);
          },
          callback
        );
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      __name(loadMetaSchemaOf, "loadMetaSchemaOf");
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError) return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref)) self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          __name(removePromise, "removePromise");
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
          __name(added, "added");
        }
        __name(loadMissingSchema, "loadMissingSchema");
      }
      __name(_compileAsync, "_compileAsync");
    }
    __name(compileAsync, "compileAsync");
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "node_modules/ajv/lib/dotjs/custom.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate) return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    }, "generate_custom");
  }
});

// node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "node_modules/ajv/lib/definition_schema.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var metaSchema = require_json_schema_draft_07();
    module.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/lib/keyword.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i2 = 0; i2 < dataType.length; i2++)
            _addRule(keyword, dataType[i2], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i3 = 0; i3 < RULES.length; i3++) {
          var rg = RULES[i3];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      __name(_addRule, "_addRule");
      return this;
    }
    __name(addKeyword, "addKeyword");
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    __name(getKeyword, "getKeyword");
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i2 = 0; i2 < RULES.length; i2++) {
        var rules = RULES[i2].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    __name(removeKeyword, "removeKeyword");
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition)) return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
    __name(validateKeyword, "validateKeyword");
  }
});

// node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "node_modules/ajv/lib/refs/data.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/lib/ajv.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compileSchema = require_compile();
    var resolve = require_resolve();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats();
    var rules = require_rules();
    var $dataMetaSchema = require_data();
    var util3 = require_util();
    module.exports = Ajv3;
    Ajv3.prototype.validate = validate;
    Ajv3.prototype.compile = compile;
    Ajv3.prototype.addSchema = addSchema;
    Ajv3.prototype.addMetaSchema = addMetaSchema;
    Ajv3.prototype.validateSchema = validateSchema;
    Ajv3.prototype.getSchema = getSchema;
    Ajv3.prototype.removeSchema = removeSchema;
    Ajv3.prototype.addFormat = addFormat3;
    Ajv3.prototype.errorsText = errorsText;
    Ajv3.prototype._addSchema = _addSchema;
    Ajv3.prototype._compile = _compile;
    Ajv3.prototype.compileAsync = require_async();
    var customKeyword = require_keyword();
    Ajv3.prototype.addKeyword = customKeyword.add;
    Ajv3.prototype.getKeyword = customKeyword.get;
    Ajv3.prototype.removeKeyword = customKeyword.remove;
    Ajv3.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv3.ValidationError = errorClasses.Validation;
    Ajv3.MissingRefError = errorClasses.MissingRef;
    Ajv3.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv3(opts) {
      if (!(this instanceof Ajv3)) return new Ajv3(opts);
      opts = this._opts = util3.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
      if (opts.serialize === void 0) opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats) addInitialFormats(this);
      if (opts.keywords) addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
      if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    __name(Ajv3, "Ajv");
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true) this.errors = v.errors;
      return valid;
    }
    __name(validate, "validate");
    function compile(schema115, _meta) {
      var schemaObj = this._addSchema(schema115, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    __name(compile, "compile");
    function addSchema(schema115, key, _skipValidation, _meta) {
      if (Array.isArray(schema115)) {
        for (var i2 = 0; i2 < schema115.length; i2++) this.addSchema(schema115[i2], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema115);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema115, _skipValidation, _meta, true);
      return this;
    }
    __name(addSchema, "addSchema");
    function addMetaSchema(schema115, key, skipValidation) {
      this.addSchema(schema115, key, skipValidation, true);
      return this;
    }
    __name(addMetaSchema, "addMetaSchema");
    function validateSchema(schema115, throwOrLogError) {
      var $schema = schema115.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema115);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log") this.logger.error(message);
        else throw new Error(message);
      }
      return valid;
    }
    __name(validateSchema, "validateSchema");
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    __name(defaultMeta, "defaultMeta");
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    __name(getSchema, "getSchema");
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema115 = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema115, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema: schema115,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    __name(_getSchemaFragment, "_getSchemaFragment");
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    __name(_getSchemaObj, "_getSchemaObj");
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj) this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    __name(removeSchema, "removeSchema");
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    __name(_removeAllSchemas, "_removeAllSchemas");
    function _addSchema(schema115, skipValidation, meta, shouldAddSchema) {
      if (typeof schema115 != "object" && typeof schema115 != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema115) : schema115;
      var cached2 = this._cache.get(cacheKey);
      if (cached2) return cached2;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema115));
      if (id && shouldAddSchema) checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema115.$schema)))
        this.validateSchema(schema115, true);
      var localRefs = resolve.ids.call(this, schema115);
      var schemaObj = new SchemaObject({
        id,
        schema: schema115,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta) this.validateSchema(schema115, true);
      return schemaObj;
    }
    __name(_addSchema, "_addSchema");
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
      __name(callValidate, "callValidate");
    }
    __name(_compile, "_compile");
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    __name(chooseGetId, "chooseGetId");
    function _getId(schema115) {
      if (schema115.$id) this.logger.warn("schema $id ignored", schema115.$id);
      return schema115.id;
    }
    __name(_getId, "_getId");
    function _get$Id(schema115) {
      if (schema115.id) this.logger.warn("schema id ignored", schema115.id);
      return schema115.$id;
    }
    __name(_get$Id, "_get$Id");
    function _get$IdOrId(schema115) {
      if (schema115.$id && schema115.id && schema115.$id != schema115.id)
        throw new Error("schema $id is different from id");
      return schema115.$id || schema115.id;
    }
    __name(_get$IdOrId, "_get$IdOrId");
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors) return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text2 = "";
      for (var i2 = 0; i2 < errors.length; i2++) {
        var e = errors[i2];
        if (e) text2 += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text2.slice(0, -separator.length);
    }
    __name(errorsText, "errorsText");
    function addFormat3(name17, format) {
      if (typeof format == "string") format = new RegExp(format);
      this._formats[name17] = format;
      return this;
    }
    __name(addFormat3, "addFormat");
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false) return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    __name(addDefaultMetaSchema, "addDefaultMetaSchema");
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
      else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
    }
    __name(addInitialSchemas, "addInitialSchemas");
    function addInitialFormats(self2) {
      for (var name17 in self2._opts.formats) {
        var format = self2._opts.formats[name17];
        self2.addFormat(name17, format);
      }
    }
    __name(addInitialFormats, "addInitialFormats");
    function addInitialKeywords(self2) {
      for (var name17 in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name17];
        self2.addKeyword(name17, keyword);
      }
    }
    __name(addInitialKeywords, "addInitialKeywords");
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    __name(checkUnique, "checkUnique");
    function getMetaSchemaOptions(self2) {
      var metaOpts = util3.copy(self2._opts);
      for (var i2 = 0; i2 < META_IGNORE_OPTIONS.length; i2++)
        delete metaOpts[META_IGNORE_OPTIONS[i2]];
      return metaOpts;
    }
    __name(getMetaSchemaOptions, "getMetaSchemaOptions");
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop3, warn: noop3, error: noop3 };
      } else {
        if (logger === void 0) logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    __name(setLogger, "setLogger");
    function noop3() {
    }
    __name(noop3, "noop");
  }
});

// node_modules/unenv/dist/runtime/node/os.mjs
var EOL;
var init_os = __esm({
  "node_modules/unenv/dist/runtime/node/os.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    EOL = "\n";
  }
});

// node_modules/mimetext/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mimetext/node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mimetext/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mimetext/node_modules/mime-db/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_db();
  }
});

// node-built-in-modules:path
import libDefault from "path";
var require_path = __commonJS({
  "node-built-in-modules:path"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node_modules/mimetext/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mimetext/node_modules/mime-types/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var db = require_mime_db();
    var extname = require_path().extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType2;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    __name(charset, "charset");
    function contentType2(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    __name(contentType2, "contentType");
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    __name(extension, "extension");
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    __name(lookup, "lookup");
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(/* @__PURE__ */ __name(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i2 = 0; i2 < exts.length; i2++) {
          var extension2 = exts[i2];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      }, "forEachMimeType"));
    }
    __name(populateMaps, "populateMaps");
  }
});

// node_modules/core-js-pure/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js-pure/internals/fails.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error42) {
        return true;
      }
    };
  }
});

// node_modules/core-js-pure/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-native.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js-pure/internals/global-this.js
var require_global_this = __commonJS({
  "node_modules/core-js-pure/internals/global-this.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var check2 = /* @__PURE__ */ __name(function(it) {
      return it && it.Math === Math && it;
    }, "check");
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check2(typeof globalThis == "object" && globalThis) || check2(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check2(typeof self == "object" && self) || check2(typeof global == "object" && global) || check2(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js-pure/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js-pure/internals/function-apply.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js-pure/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js-pure/internals/classof-raw.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uncurryThis = require_function_uncurry_this();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString(it), 8, -1);
    };
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this-clause.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn) {
      if (classofRaw(fn) === "Function") return uncurryThis(fn);
    };
  }
});

// node_modules/core-js-pure/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js-pure/internals/is-callable.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var documentAll = typeof document == "object" && document.all;
    module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js-pure/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js-pure/internals/descriptors.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: /* @__PURE__ */ __name(function() {
        return 7;
      }, "get") })[1] !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js-pure/internals/function-call.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js-pure/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js-pure/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? /* @__PURE__ */ __name(function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    }, "propertyIsEnumerable") : $propertyIsEnumerable;
  }
});

// node_modules/core-js-pure/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js-pure/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/indexed-object.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// node_modules/core-js-pure/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js-pure/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// node_modules/core-js-pure/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js-pure/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js-pure/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js-pure/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js-pure/internals/is-object.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isCallable = require_is_callable();
    module.exports = function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// node_modules/core-js-pure/internals/path.js
var require_path2 = __commonJS({
  "node_modules/core-js-pure/internals/path.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js-pure/internals/get-built-in.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var path2 = require_path2();
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var aFunction = /* @__PURE__ */ __name(function(variable) {
      return isCallable(variable) ? variable : void 0;
    }, "aFunction");
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(path2[namespace]) || aFunction(globalThis2[namespace]) : path2[namespace] && path2[namespace][method] || globalThis2[namespace] && globalThis2[namespace][method];
    };
  }
});

// node_modules/core-js-pure/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS({
  "node_modules/core-js-pure/internals/environment-user-agent.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var globalThis2 = require_global_this();
    var navigator2 = globalThis2.navigator;
    var userAgent = navigator2 && navigator2.userAgent;
    module.exports = userAgent ? String(userAgent) : "";
  }
});

// node_modules/core-js-pure/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS({
  "node_modules/core-js-pure/internals/environment-v8-version.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var process2 = globalThis2.process;
    var Deno = globalThis2.Deno;
    var versions2 = process2 && process2.versions || Deno && Deno.version;
    var v8 = versions2 && versions2.v8;
    var match;
    var version3;
    if (v8) {
      match = v8.split(".");
      version3 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version3 && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version3 = +match[1];
      }
    }
    module.exports = version3;
  }
});

// node_modules/core-js-pure/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js-pure/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var V8_VERSION = require_environment_v8_version();
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $String = globalThis2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol17 = Symbol("symbol detection");
      return !$String(symbol17) || !(Object(symbol17) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js-pure/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js-pure/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js-pure/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js-pure/internals/is-symbol.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// node_modules/core-js-pure/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js-pure/internals/try-to-string.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error42) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js-pure/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js-pure/internals/a-callable.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js-pure/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js-pure/internals/get-method.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js-pure/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject2 = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject2(val = call(fn, input))) return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js-pure/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js-pure/internals/is-pure.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = true;
  }
});

// node_modules/core-js-pure/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js-pure/internals/define-global-property.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var globalThis2 = require_global_this();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error42) {
        globalThis2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js-pure/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js-pure/internals/shared-store.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global_this();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.45.1",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2025 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js-pure/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js-pure/internals/shared.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var store = require_shared_store();
    module.exports = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
  }
});

// node_modules/core-js-pure/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js-pure/internals/to-object.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js-pure/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js-pure/internals/has-own-property.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || /* @__PURE__ */ __name(function hasOwn(it, key) {
      return hasOwnProperty(toObject(it), key);
    }, "hasOwn");
  }
});

// node_modules/core-js-pure/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js-pure/internals/uid.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1.1.toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
    };
  }
});

// node_modules/core-js-pure/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var globalThis2 = require_global_this();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name17) {
      if (!hasOwn(WellKnownSymbolsStore, name17)) {
        WellKnownSymbolsStore[name17] = NATIVE_SYMBOL && hasOwn(Symbol2, name17) ? Symbol2[name17] : createWellKnownSymbol("Symbol." + name17);
      }
      return WellKnownSymbolsStore[name17];
    };
  }
});

// node_modules/core-js-pure/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/to-primitive.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var call = require_function_call();
    var isObject2 = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject2(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject2(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js-pure/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js-pure/internals/to-property-key.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js-pure/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js-pure/internals/document-create-element.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var globalThis2 = require_global_this();
    var isObject2 = require_is_object();
    var document2 = globalThis2.document;
    var EXISTS = isObject2(document2) && isObject2(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js-pure/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js-pure/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: /* @__PURE__ */ __name(function() {
          return 7;
        }, "get")
      }).a !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : /* @__PURE__ */ __name(function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error42) {
      }
      if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    }, "getOwnPropertyDescriptor");
  }
});

// node_modules/core-js-pure/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js-pure/internals/is-forced.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = /* @__PURE__ */ __name(function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    }, "isForced");
    var normalize = isForced.normalize = function(string4) {
      return String(string4).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// node_modules/core-js-pure/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-context.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js-pure/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js-pure/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js-pure/internals/an-object.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isObject2 = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject2(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js-pure/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js-pure/internals/object-define-property.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    }, "defineProperty") : $defineProperty : /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error42) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    }, "defineProperty");
  }
});

// node_modules/core-js-pure/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js-pure/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object4, key, value) {
      return definePropertyModule.f(object4, key, createPropertyDescriptor(1, value));
    } : function(object4, key, value) {
      object4[key] = value;
      return object4;
    };
  }
});

// node_modules/core-js-pure/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js-pure/internals/export.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var globalThis2 = require_global_this();
    var apply = require_function_apply();
    var uncurryThis = require_function_uncurry_this_clause();
    var isCallable = require_is_callable();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var isForced = require_is_forced();
    var path2 = require_path2();
    var bind = require_function_bind_context();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    require_shared_store();
    var wrapConstructor = /* @__PURE__ */ __name(function(NativeConstructor) {
      var Wrapper = /* @__PURE__ */ __name(function(a2, b, c) {
        if (this instanceof Wrapper) {
          switch (arguments.length) {
            case 0:
              return new NativeConstructor();
            case 1:
              return new NativeConstructor(a2);
            case 2:
              return new NativeConstructor(a2, b);
          }
          return new NativeConstructor(a2, b, c);
        }
        return apply(NativeConstructor, this, arguments);
      }, "Wrapper");
      Wrapper.prototype = NativeConstructor.prototype;
      return Wrapper;
    }, "wrapConstructor");
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var PROTO = options.proto;
      var nativeSource = GLOBAL ? globalThis2 : STATIC ? globalThis2[TARGET] : globalThis2[TARGET] && globalThis2[TARGET].prototype;
      var target = GLOBAL ? path2 : path2[TARGET] || createNonEnumerableProperty(path2, TARGET, {})[TARGET];
      var targetPrototype = target.prototype;
      var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
      var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
      for (key in source) {
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
        targetProperty = target[key];
        if (USE_NATIVE) if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(nativeSource, key);
          nativeProperty = descriptor && descriptor.value;
        } else nativeProperty = nativeSource[key];
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
        if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;
        if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis2);
        else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
        else resultProperty = sourceProperty;
        if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(resultProperty, "sham", true);
        }
        createNonEnumerableProperty(target, key, resultProperty);
        if (PROTO) {
          VIRTUAL_PROTOTYPE = TARGET + "Prototype";
          if (!hasOwn(path2, VIRTUAL_PROTOTYPE)) {
            createNonEnumerableProperty(path2, VIRTUAL_PROTOTYPE, {});
          }
          createNonEnumerableProperty(path2[VIRTUAL_PROTOTYPE], key, sourceProperty);
          if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
            createNonEnumerableProperty(targetPrototype, key, sourceProperty);
          }
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js-pure/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js-pure/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js-pure/internals/classof.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = /* @__PURE__ */ __name(function(it, key) {
      try {
        return it[key];
      } catch (error42) {
      }
    }, "tryGet");
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js-pure/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js-pure/internals/to-string.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js-pure/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js-pure/internals/whitespaces.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js-pure/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js-pure/internals/string-trim.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
    var createMethod = /* @__PURE__ */ __name(function(TYPE) {
      return function($this) {
        var string4 = toString(requireObjectCoercible($this));
        if (TYPE & 1) string4 = replace(string4, ltrim, "");
        if (TYPE & 2) string4 = replace(string4, rtrim, "$1");
        return string4;
      };
    }, "createMethod");
    module.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js-pure/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js-pure/internals/function-name.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (/* @__PURE__ */ __name(function something() {
    }, "something")).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js-pure/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js-pure/internals/string-trim-forced.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module.exports = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js-pure/modules/es.string.trim.js
var require_es_string_trim = __commonJS({
  "node_modules/core-js-pure/modules/es.string.trim.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var $ = require_export();
    var $trim = require_string_trim().trim;
    var forcedStringTrimMethod = require_string_trim_forced();
    $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: /* @__PURE__ */ __name(function trim() {
        return $trim(this);
      }, "trim")
    });
  }
});

// node_modules/core-js-pure/internals/get-built-in-prototype-method.js
var require_get_built_in_prototype_method = __commonJS({
  "node_modules/core-js-pure/internals/get-built-in-prototype-method.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var globalThis2 = require_global_this();
    var path2 = require_path2();
    module.exports = function(CONSTRUCTOR, METHOD) {
      var Namespace = path2[CONSTRUCTOR + "Prototype"];
      var pureMethod = Namespace && Namespace[METHOD];
      if (pureMethod) return pureMethod;
      var NativeConstructor = globalThis2[CONSTRUCTOR];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      return NativePrototype && NativePrototype[METHOD];
    };
  }
});

// node_modules/core-js-pure/es/string/virtual/trim.js
var require_trim = __commonJS({
  "node_modules/core-js-pure/es/string/virtual/trim.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    require_es_string_trim();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("String", "trim");
  }
});

// node_modules/core-js-pure/es/instance/trim.js
var require_trim2 = __commonJS({
  "node_modules/core-js-pure/es/instance/trim.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_trim();
    var StringPrototype = String.prototype;
    module.exports = function(it) {
      var own = it.trim;
      return typeof it == "string" || it === StringPrototype || isPrototypeOf(StringPrototype, it) && own === StringPrototype.trim ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/trim.js
var require_trim3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/trim.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parent = require_trim2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/instance/trim.js
var require_trim4 = __commonJS({
  "node_modules/core-js-pure/actual/instance/trim.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parent = require_trim3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/instance/trim.js
var require_trim5 = __commonJS({
  "node_modules/core-js-pure/full/instance/trim.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parent = require_trim4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/instance/trim.js
var require_trim6 = __commonJS({
  "node_modules/core-js-pure/features/instance/trim.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_trim5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/instance/trim.js
var require_trim7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/instance/trim.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_trim6();
  }
});

// node_modules/mimetext/dist/mimetext.node.es.js
var mimetext_node_es_exports = {};
__export(mimetext_node_es_exports, {
  MIMEMessage: () => d,
  MIMEMessageContent: () => o,
  MIMEMessageHeader: () => a,
  MIMETextError: () => n,
  Mailbox: () => i,
  createMimeMessage: () => u
});
function u() {
  return new d(h);
}
var t, import_trim, n, i, a, r, o, d, h;
var init_mimetext_node_es = __esm({
  "node_modules/mimetext/dist/mimetext.node.es.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_os();
    t = __toESM(require_mime_types(), 1);
    import_trim = __toESM(require_trim7(), 1);
    n = class extends Error {
      static {
        __name(this, "n");
      }
      name = "";
      description = "";
      constructor(e, t2 = "") {
        super(t2), this.name = e, this.description = t2;
      }
    };
    i = class {
      static {
        __name(this, "i");
      }
      reSpecCompliantAddr = /(([^<>\r\n]+)\s)?<[^\r\n]+>/;
      name = "";
      addr = "";
      type = "To";
      constructor(e, t2 = { type: "To" }) {
        this.type = t2.type, this.parse(e);
      }
      getAddrDomain() {
        if (this.addr.includes("@")) {
          const e = this.addr.split("@");
          if (e.length > 1) return e[1];
        }
        return "";
      }
      dump() {
        return this.name.length > 0 ? `"${this.name}" <${this.addr}>` : `<${this.addr}>`;
      }
      parse(e) {
        if (this.isMailboxAddrObject(e)) return this.addr = e.addr, "string" == typeof e.name && (this.name = e.name), "string" == typeof e.type && (this.type = e.type), this;
        if (this.isMailboxAddrText(e)) {
          const t2 = (0, import_trim.default)(e).call(e);
          if (t2.startsWith("<") && t2.endsWith(">")) return this.addr = t2.slice(1, -1), this;
          const n2 = t2.split(" <");
          return n2[0] = /^("|')/.test(n2[0]) ? n2[0].slice(1) : n2[0], n2[0] = /("|')$/.test(n2[0]) ? n2[0].slice(0, -1) : n2[0], n2[1] = n2[1].slice(0, -1), this.name = n2[0], this.addr = n2[1], this;
        }
        if ("string" == typeof e) return this.addr = e, this;
        throw new n("MIMETEXT_INVALID_MAILBOX", "Couldn't recognize the input.");
      }
      isMailboxAddrText(e) {
        return "string" == typeof e && this.reSpecCompliantAddr.test(e);
      }
      isMailboxAddrObject(e) {
        return this.isObject(e) && Object.hasOwn(e, "addr");
      }
      isObject(e) {
        return !!e && e.constructor === Object;
      }
    };
    a = class {
      static {
        __name(this, "a");
      }
      fields = [{ name: "Date", generator: /* @__PURE__ */ __name(() => (/* @__PURE__ */ new Date()).toUTCString().replace(/GMT|UTC/gi, "+0000"), "generator") }, { name: "From", required: true, validate: /* @__PURE__ */ __name((e) => this.validateMailboxSingle(e), "validate"), dump: /* @__PURE__ */ __name((e) => this.dumpMailboxSingle(e), "dump") }, { name: "Sender", validate: /* @__PURE__ */ __name((e) => this.validateMailboxSingle(e), "validate"), dump: /* @__PURE__ */ __name((e) => this.dumpMailboxSingle(e), "dump") }, { name: "Reply-To", validate: /* @__PURE__ */ __name((e) => this.validateMailboxSingle(e), "validate"), dump: /* @__PURE__ */ __name((e) => this.dumpMailboxSingle(e), "dump") }, { name: "To", validate: /* @__PURE__ */ __name((e) => this.validateMailboxMulti(e), "validate"), dump: /* @__PURE__ */ __name((e) => this.dumpMailboxMulti(e), "dump") }, { name: "Cc", validate: /* @__PURE__ */ __name((e) => this.validateMailboxMulti(e), "validate"), dump: /* @__PURE__ */ __name((e) => this.dumpMailboxMulti(e), "dump") }, { name: "Bcc", validate: /* @__PURE__ */ __name((e) => this.validateMailboxMulti(e), "validate"), dump: /* @__PURE__ */ __name((e) => this.dumpMailboxMulti(e), "dump") }, { name: "Message-ID", generator: /* @__PURE__ */ __name(() => "<" + Math.random().toString(36).slice(2) + "@" + this.fields.filter((e) => "From" === e.name)[0].value.getAddrDomain() + ">", "generator") }, { name: "Subject", required: true, dump: /* @__PURE__ */ __name((e) => "string" == typeof e ? "=?utf-8?B?" + this.envctx.toBase64(e) + "?=" : "", "dump") }, { name: "MIME-Version", generator: /* @__PURE__ */ __name(() => "1.0", "generator") }];
      constructor(e) {
        this.envctx = e;
      }
      dump() {
        let e = "";
        for (const t2 of this.fields) {
          if (t2.disabled) continue;
          const s2 = void 0 !== t2.value && null !== t2.value;
          if (!s2 && t2.required) throw new n("MIMETEXT_MISSING_HEADER", `The "${t2.name}" header is required.`);
          if (!s2 && "function" != typeof t2.generator) continue;
          s2 || "function" != typeof t2.generator || (t2.value = t2.generator());
          const i2 = Object.hasOwn(t2, "dump") && "function" == typeof t2.dump ? t2.dump(t2.value) : "string" == typeof t2.value ? t2.value : "";
          e += `${t2.name}: ${i2}${this.envctx.eol}`;
        }
        return e.slice(0, -1 * this.envctx.eol.length);
      }
      toObject() {
        return this.fields.reduce((e, t2) => (e[t2.name] = t2.value, e), {});
      }
      get(e) {
        const t2 = this.fields.findIndex((t3) => t3.name.toLowerCase() === e.toLowerCase());
        return -1 !== t2 ? this.fields[t2].value : void 0;
      }
      set(e, t2) {
        const s2 = /* @__PURE__ */ __name((t3) => t3.name.toLowerCase() === e.toLowerCase(), "s");
        if (!!this.fields.some(s2)) {
          const i2 = this.fields.findIndex(s2), a2 = this.fields[i2];
          if (a2.validate && !a2.validate(t2)) throw new n("MIMETEXT_INVALID_HEADER_VALUE", `The value for the header "${e}" is invalid.`);
          return this.fields[i2].value = t2, this.fields[i2];
        }
        return this.setCustom({ name: e, value: t2, custom: true, dump: /* @__PURE__ */ __name((e2) => "string" == typeof e2 ? e2 : "", "dump") });
      }
      setCustom(e) {
        if (this.isHeaderField(e)) {
          if ("string" != typeof e.value) throw new n("MIMETEXT_INVALID_HEADER_FIELD", "Custom header must have a value.");
          return this.fields.push(e), e;
        }
        throw new n("MIMETEXT_INVALID_HEADER_FIELD", "Invalid input for custom header. It must be in type of HeaderField.");
      }
      validateMailboxSingle(e) {
        return e instanceof i;
      }
      validateMailboxMulti(e) {
        return e instanceof i || this.isArrayOfMailboxes(e);
      }
      dumpMailboxMulti(e) {
        const t2 = /* @__PURE__ */ __name((e2) => 0 === e2.name.length ? e2.dump() : `=?utf-8?B?${this.envctx.toBase64(e2.name)}?= <${e2.addr}>`, "t");
        return this.isArrayOfMailboxes(e) ? e.map(t2).join(`,${this.envctx.eol} `) : e instanceof i ? t2(e) : "";
      }
      dumpMailboxSingle(e) {
        return e instanceof i ? ((e2) => 0 === e2.name.length ? e2.dump() : `=?utf-8?B?${this.envctx.toBase64(e2.name)}?= <${e2.addr}>`)(e) : "";
      }
      isHeaderField(e) {
        const t2 = ["name", "value", "dump", "required", "disabled", "generator", "custom"];
        if (this.isObject(e)) {
          const s2 = e;
          if (Object.hasOwn(s2, "name") && "string" == typeof s2.name && s2.name.length > 0 && !Object.keys(s2).some((e2) => !t2.includes(e2))) return true;
        }
        return false;
      }
      isObject(e) {
        return !!e && e.constructor === Object;
      }
      isArrayOfMailboxes(e) {
        return this.isArray(e) && e.every((e2) => e2 instanceof i);
      }
      isArray(e) {
        return !!e && e.constructor === Array;
      }
    };
    r = class extends a {
      static {
        __name(this, "r");
      }
      fields = [{ name: "Content-ID" }, { name: "Content-Type" }, { name: "Content-Transfer-Encoding" }, { name: "Content-Disposition" }];
      constructor(e) {
        super(e);
      }
    };
    o = class {
      static {
        __name(this, "o");
      }
      constructor(e, t2, s2 = {}) {
        this.envctx = e, this.headers = new r(this.envctx), this.data = t2, this.setHeaders(s2);
      }
      dump() {
        const e = this.envctx.eol;
        return this.headers.dump() + e + e + this.data;
      }
      isAttachment() {
        const e = this.headers.get("Content-Disposition");
        return "string" == typeof e && e.includes("attachment");
      }
      isInlineAttachment() {
        const e = this.headers.get("Content-Disposition");
        return "string" == typeof e && e.includes("inline");
      }
      setHeader(e, t2) {
        return this.headers.set(e, t2), e;
      }
      getHeader(e) {
        return this.headers.get(e);
      }
      setHeaders(e) {
        return Object.keys(e).map((t2) => this.setHeader(t2, e[t2]));
      }
      getHeaders() {
        return this.headers.toObject();
      }
    };
    d = class {
      static {
        __name(this, "d");
      }
      boundaries = { mixed: "", alt: "", related: "" };
      validTypes = ["text/html", "text/plain"];
      validContentTransferEncodings = ["7bit", "8bit", "binary", "quoted-printable", "base64"];
      messages = [];
      constructor(e) {
        this.envctx = e, this.headers = new a(this.envctx), this.messages = [], this.generateBoundaries();
      }
      asRaw() {
        const e = this.envctx.eol, t2 = this.headers.dump(), s2 = this.getMessageByType("text/plain"), i2 = this.getMessageByType("text/html"), a2 = i2 ?? s2 ?? void 0;
        if (void 0 === a2) throw new n("MIMETEXT_MISSING_BODY", "No content added to the message.");
        const r2 = this.hasAttachments(), o2 = this.hasInlineAttachments(), d2 = o2 && r2 ? "mixed+related" : r2 ? "mixed" : o2 ? "related" : s2 && i2 ? "alternative" : "";
        if ("mixed+related" === d2) {
          const n2 = this.getAttachments().map((t3) => "--" + this.boundaries.mixed + e + t3.dump() + e + e).join("").slice(0, -1 * e.length), a3 = this.getInlineAttachments().map((t3) => "--" + this.boundaries.related + e + t3.dump() + e + e).join("").slice(0, -1 * e.length);
          return t2 + e + "Content-Type: multipart/mixed; boundary=" + this.boundaries.mixed + e + e + "--" + this.boundaries.mixed + e + "Content-Type: multipart/related; boundary=" + this.boundaries.related + e + e + this.dumpTextContent(s2, i2, this.boundaries.related) + e + e + a3 + "--" + this.boundaries.related + "--" + e + n2 + "--" + this.boundaries.mixed + "--";
        }
        if ("mixed" === d2) {
          const n2 = this.getAttachments().map((t3) => "--" + this.boundaries.mixed + e + t3.dump() + e + e).join("").slice(0, -1 * e.length);
          return t2 + e + "Content-Type: multipart/mixed; boundary=" + this.boundaries.mixed + e + e + this.dumpTextContent(s2, i2, this.boundaries.mixed) + e + (s2 && i2 ? "" : e) + n2 + "--" + this.boundaries.mixed + "--";
        }
        if ("related" === d2) {
          const n2 = this.getInlineAttachments().map((t3) => "--" + this.boundaries.related + e + t3.dump() + e + e).join("").slice(0, -1 * e.length);
          return t2 + e + "Content-Type: multipart/related; boundary=" + this.boundaries.related + e + e + this.dumpTextContent(s2, i2, this.boundaries.related) + e + e + n2 + "--" + this.boundaries.related + "--";
        }
        return "alternative" === d2 ? t2 + e + "Content-Type: multipart/alternative; boundary=" + this.boundaries.alt + e + e + this.dumpTextContent(s2, i2, this.boundaries.alt) + e + e + "--" + this.boundaries.alt + "--" : t2 + e + a2.dump();
      }
      asEncoded() {
        return this.envctx.toBase64WebSafe(this.asRaw());
      }
      dumpTextContent(e, t2, s2) {
        const n2 = this.envctx.eol, i2 = t2 ?? e;
        let a2 = "";
        return a2 = e && t2 && (this.hasInlineAttachments() || this.hasAttachments()) ? "--" + s2 + n2 + "Content-Type: multipart/alternative; boundary=" + this.boundaries.alt + n2 + n2 + "--" + this.boundaries.alt + n2 + e.dump() + n2 + n2 + "--" + this.boundaries.alt + n2 + t2.dump() + n2 + n2 + "--" + this.boundaries.alt + "--" : e && t2 ? "--" + s2 + n2 + e.dump() + n2 + n2 + "--" + s2 + n2 + t2.dump() : "--" + s2 + n2 + i2.dump(), a2;
      }
      hasInlineAttachments() {
        return this.messages.some((e) => e.isInlineAttachment());
      }
      hasAttachments() {
        return this.messages.some((e) => e.isAttachment());
      }
      getAttachments() {
        const e = /* @__PURE__ */ __name((e2) => e2.isAttachment(), "e");
        return this.messages.some(e) ? this.messages.filter(e) : [];
      }
      getInlineAttachments() {
        const e = /* @__PURE__ */ __name((e2) => e2.isInlineAttachment(), "e");
        return this.messages.some(e) ? this.messages.filter(e) : [];
      }
      getMessageByType(e) {
        const t2 = /* @__PURE__ */ __name((t3) => !t3.isAttachment() && !t3.isInlineAttachment() && (t3.getHeader("Content-Type") || "").includes(e), "t");
        return this.messages.some(t2) ? this.messages.filter(t2)[0] : void 0;
      }
      addAttachment(e) {
        if (this.isObject(e.headers) || (e.headers = {}), "string" != typeof e.filename) throw new n("MIMETEXT_MISSING_FILENAME", 'The property "filename" must exist while adding attachments.');
        let t2 = (e.headers["Content-Type"] ?? e.contentType) || "none";
        if (false === this.envctx.validateContentType(t2)) throw new n("MIMETEXT_INVALID_MESSAGE_TYPE", `You specified an invalid content type "${t2}".`);
        const s2 = e.headers["Content-Transfer-Encoding"] ?? e.encoding ?? "base64";
        this.validContentTransferEncodings.includes(s2) || (t2 = "application/octet-stream");
        const i2 = e.headers["Content-ID"];
        "string" == typeof i2 && i2.length > 2 && !i2.startsWith("<") && !i2.endsWith(">") && (e.headers["Content-ID"] = "<" + e.headers["Content-ID"] + ">");
        const a2 = e.inline ? "inline" : "attachment";
        return e.headers = Object.assign({}, e.headers, { "Content-Type": `${t2}; name="${e.filename}"`, "Content-Transfer-Encoding": s2, "Content-Disposition": `${a2}; filename="${e.filename}"` }), this._addMessage({ data: e.data, headers: e.headers });
      }
      addMessage(e) {
        this.isObject(e.headers) || (e.headers = {});
        let t2 = (e.headers["Content-Type"] ?? e.contentType) || "none";
        if (!this.validTypes.includes(t2)) throw new n("MIMETEXT_INVALID_MESSAGE_TYPE", `Valid content types are ${this.validTypes.join(", ")} but you specified "${t2}".`);
        const s2 = e.headers["Content-Transfer-Encoding"] ?? e.encoding ?? "7bit";
        this.validContentTransferEncodings.includes(s2) || (t2 = "application/octet-stream");
        const i2 = e.charset ?? "UTF-8";
        return e.headers = Object.assign({}, e.headers, { "Content-Type": `${t2}; charset=${i2}`, "Content-Transfer-Encoding": s2 }), this._addMessage({ data: e.data, headers: e.headers });
      }
      _addMessage(e) {
        const t2 = new o(this.envctx, e.data, e.headers);
        return this.messages.push(t2), t2;
      }
      setSender(e, t2 = { type: "From" }) {
        const s2 = new i(e, t2);
        return this.setHeader("From", s2), s2;
      }
      getSender() {
        return this.getHeader("From");
      }
      setRecipients(e, t2 = { type: "To" }) {
        const s2 = (this.isArray(e) ? e : [e]).map((e2) => new i(e2, t2));
        return this.setHeader(t2.type, s2), s2;
      }
      getRecipients(e = { type: "To" }) {
        return this.getHeader(e.type);
      }
      setRecipient(e, t2 = { type: "To" }) {
        return this.setRecipients(e, t2);
      }
      setTo(e, t2 = { type: "To" }) {
        return this.setRecipients(e, t2);
      }
      setCc(e, t2 = { type: "Cc" }) {
        return this.setRecipients(e, t2);
      }
      setBcc(e, t2 = { type: "Bcc" }) {
        return this.setRecipients(e, t2);
      }
      setSubject(e) {
        return this.setHeader("subject", e), e;
      }
      getSubject() {
        return this.getHeader("subject");
      }
      setHeader(e, t2) {
        return this.headers.set(e, t2), e;
      }
      getHeader(e) {
        return this.headers.get(e);
      }
      setHeaders(e) {
        return Object.keys(e).map((t2) => this.setHeader(t2, e[t2]));
      }
      getHeaders() {
        return this.headers.toObject();
      }
      toBase64(e) {
        return this.envctx.toBase64(e);
      }
      toBase64WebSafe(e) {
        return this.envctx.toBase64WebSafe(e);
      }
      generateBoundaries() {
        this.boundaries = { mixed: Math.random().toString(36).slice(2), alt: Math.random().toString(36).slice(2), related: Math.random().toString(36).slice(2) };
      }
      isArray(e) {
        return !!e && e.constructor === Array;
      }
      isObject(e) {
        return !!e && e.constructor === Object;
      }
    };
    h = { toBase64: /* @__PURE__ */ __name(function(e) {
      return Buffer.from(e).toString("base64");
    }, "toBase64"), toBase64WebSafe: /* @__PURE__ */ __name(function(e) {
      return Buffer.from(e).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }, "toBase64WebSafe"), eol: EOL, validateContentType: /* @__PURE__ */ __name((e) => t.contentType(e), "validateContentType") };
    __name(u, "u");
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/aave/aave.mjs
var aave_exports = {};
__export(aave_exports, {
  schema: () => schema
});
var schema;
var init_aave = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/aave/aave.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema = {
      namespace: "aave",
      name: "AAVE Protocol API",
      description: "Fetch and analyze liquidity and account data from AAVE v3 via The Graph subgraph",
      docs: ["https://thegraph.com/explorer/subgraphs/aave/protocol-v3", "https://docs.aave.com/developers/"],
      tags: ["defi", "lending", "protocol"],
      flowMCP: "1.2.0",
      root: "https://gateway.thegraph.com",
      requiredServerParams: ["THEGRAPH_API_KEY"],
      headers: { Authorization: "Bearer {{THEGRAPH_API_KEY}}" },
      routes: {
        getReserves: {
          requestMethod: "POST",
          description: "Returns AAVE reserves data including symbols, liquidity, rates, and timestamps from Ethereum mainnet.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/Cd2gEDVeqnjBn1hSeqFMitw8Q1iiyV9FYUZkLNRcL87g",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["default(20)", "min(1)", "max(100)"] } }
          ],
          tests: [
            { _description: "Fetch top 20 AAVE reserves", first: 20 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildReservesQuery" }
          ]
        },
        getUserData: {
          requestMethod: "POST",
          description: "Fetches user-specific reserve data like debt and balances from AAVE subgraph.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/Cd2gEDVeqnjBn1hSeqFMitw8Q1iiyV9FYUZkLNRcL87g",
          parameters: [
            { position: { key: "userAddress", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["length(42)"] } },
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["default(10)", "min(1)", "max(50)"] } }
          ],
          tests: [
            { _description: "Get user reserves data", userAddress: "0x1234567890abcdef1234567890abcdef12345678", first: 10 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildUserDataQuery" }
          ]
        },
        getProtocolData: {
          requestMethod: "POST",
          description: "Get general AAVE protocol statistics and market overview.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/Cd2gEDVeqnjBn1hSeqFMitw8Q1iiyV9FYUZkLNRcL87g",
          parameters: [],
          tests: [
            { _description: "Get protocol statistics" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildProtocolDataQuery" }
          ]
        }
      },
      handlers: {
        buildReservesQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first } = userParams;
          const query = `
                query GetReserves($first: Int!) {
                    reserves(first: $first, orderBy: totalLiquidity, orderDirection: desc) {
                        id
                        underlyingAsset
                        symbol
                        name
                        decimals
                        totalLiquidity
                        availableLiquidity
                        liquidityRate
                        variableBorrowRate
                        stableBorrowRate
                        lastUpdateTimestamp
                        price {
                            priceInEth
                        }
                    }
                }
            `;
          payload.body = {
            query,
            variables: { first }
          };
          return { struct, payload };
        }, "buildReservesQuery"),
        buildUserDataQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { userAddress, first } = userParams;
          const query = `
                query GetUserData($userAddress: String!, $first: Int!) {
                    userReserves(where: { user: $userAddress }, first: $first) {
                        reserve {
                            symbol
                            underlyingAsset
                            liquidityRate
                            variableBorrowRate
                            stableBorrowRate
                        }
                        currentATokenBalance
                        currentTotalDebt
                        scaledVariableDebt
                        principalStableDebt
                        lastUpdateTimestamp
                    }
                    user(id: $userAddress) {
                        id
                        borrowedReservesCount
                        unclaimedRewards
                    }
                }
            `;
          payload.body = {
            query,
            variables: { userAddress: userAddress.toLowerCase(), first }
          };
          return { struct, payload };
        }, "buildUserDataQuery"),
        buildProtocolDataQuery: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const query = `
                query GetProtocolData {
                    protocol(id: "1") {
                        id
                        pools
                    }
                    reserves(first: 5, orderBy: totalLiquidity, orderDirection: desc) {
                        symbol
                        totalLiquidity
                        totalCurrentVariableDebt
                        utilizationRate
                    }
                }
            `;
          payload.body = { query };
          return { struct, payload };
        }, "buildProtocolDataQuery")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/alternative-me/fearAndGreed.mjs
var fearAndGreed_exports = {};
__export(fearAndGreed_exports, {
  schema: () => schema2
});
var schema2;
var init_fearAndGreed = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/alternative-me/fearAndGreed.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema2 = {
      namespace: "alternative",
      name: "FearGreedIndex",
      description: "Fetches and analyzes the Crypto Fear & Greed Index from alternative.me.",
      docs: ["https://alternative.me/crypto/api/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.alternative.me/fng",
      requiredServerParams: [],
      headers: {},
      routes: {
        getCurrentFng: {
          requestMethod: "GET",
          description: "Retrieve the latest Fear & Greed Index.",
          route: "/",
          parameters: [],
          tests: [
            { _description: "Get current FNG value" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatCurrentFng" }
          ]
        },
        getHistoricalFng: {
          requestMethod: "GET",
          description: "Get historical Fear & Greed Index values for past days.",
          route: "/",
          parameters: [
            {
              position: { key: "days", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(100)", "default(7)"] }
            }
          ],
          tests: [
            { _description: "Fetch FNG for past 5 days", days: 5 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatHistoricalFng" }
          ]
        },
        analyzeFngTrend: {
          requestMethod: "GET",
          description: "Analyze the trend of the Fear & Greed Index over a number of days.",
          route: "/",
          parameters: [
            {
              position: { key: "days", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(100)", "default(7)"] }
            }
          ],
          tests: [
            { _description: "Analyze FNG trend for last 10 days", days: 10 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatFngTrend" }
          ]
        }
      },
      handlers: {
        formatCurrentFng: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.fng = payload?.content?.[0]?.text || "";
          return { struct, payload };
        }, "formatCurrentFng"),
        formatHistoricalFng: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.history = payload?.content?.[0]?.text || "";
          return { struct, payload };
        }, "formatHistoricalFng"),
        formatFngTrend: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.analysis = payload?.content?.[0]?.text || "";
          return { struct, payload };
        }, "formatFngTrend")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/berlin-de/events.mjs
var events_exports = {};
__export(events_exports, {
  schema: () => schema3
});
var schema3;
var init_events = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/berlin-de/events.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema3 = {
      namespace: "berlinevents",
      name: "Berlin Events API",
      description: "Access to Berlin city events data including markets, festivals, and public assemblies",
      docs: ["https://www.berlin.de/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://www.berlin.de",
      requiredServerParams: [],
      headers: {},
      routes: {
        markets_festivals: {
          requestMethod: "GET",
          description: "Weekly and flea markets in Berlin",
          route: "/sen/web/service/maerkte-feste/wochen-troedelmaerkte/index.php/index/all.json",
          parameters: [],
          tests: [
            { _description: "Get all weekly and flea markets in Berlin" }
          ],
          modifiers: []
        },
        street_festivals: {
          requestMethod: "GET",
          description: "Street and folk festivals in Berlin",
          route: "/sen/web/service/maerkte-feste/strassen-volksfeste/index.php/index/all.json",
          parameters: [],
          tests: [
            { _description: "Get all street and folk festivals in Berlin" }
          ],
          modifiers: []
        },
        christmas_markets: {
          requestMethod: "GET",
          description: "Christmas markets in Berlin",
          route: "/sen/web/service/maerkte-feste/weihnachtsmaerkte/index.php/index/all.json",
          parameters: [],
          tests: [
            { _description: "Get all christmas markets in Berlin" }
          ],
          modifiers: []
        },
        police_assemblies: {
          requestMethod: "GET",
          description: "Police registered assemblies and demonstrations in Berlin",
          route: "/polizei/service/versammlungsbehoerde/versammlungen-aufzuege/index.php/index/all.json",
          parameters: [],
          tests: [
            { _description: "Get all police registered assemblies and demonstrations" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/berlin-de/funds.mjs
var funds_exports = {};
__export(funds_exports, {
  schema: () => schema4
});
var schema4;
var init_funds = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/berlin-de/funds.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema4 = {
      namespace: "berlinfunds",
      name: "Berlin Funds API",
      description: "Access to Berlin funding opportunities and educational programs",
      docs: ["https://www.berlin.de/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://www.berlin.de",
      requiredServerParams: [],
      headers: {},
      routes: {
        funding_opportunities: {
          requestMethod: "GET",
          description: "Funding opportunities from Berlin-Treptow-K\xF6penick district",
          route: "/ba-treptow-koepenick/politik-und-verwaltung/beauftragte/integration/foerderungen-finanzen/simplesearch/index.php/index/all.json",
          parameters: [],
          tests: [
            { _description: "Get all funding opportunities from Treptow-K\xF6penick district" }
          ],
          modifiers: []
        },
        continuing_education: {
          requestMethod: "GET",
          description: "Continuing education and professional development courses (Bildungszeit)",
          route: "/sen/arbeit/weiterbildung/bildungszeit/suche/index.php/index/all.json",
          parameters: [],
          tests: [
            { _description: "Get all continuing education courses in Berlin" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/berlin-de/vhs.mjs
var vhs_exports = {};
__export(vhs_exports, {
  schema: () => schema5
});
var schema5;
var init_vhs = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/berlin-de/vhs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema5 = {
      namespace: "berlinvhs",
      name: "Berlin VHS API",
      description: "Access to Berlin Volkshochschule (VHS) course catalog with detailed course information",
      docs: ["https://www.vhsit.berlin.de/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://www.vhsit.berlin.de",
      requiredServerParams: [],
      headers: {},
      routes: {
        all_courses: {
          requestMethod: "GET",
          description: "Complete catalog of VHS courses across all Berlin districts",
          route: "/VHSKURSE/OpenData/Kurse.json",
          parameters: [],
          tests: [
            { _description: "Get all VHS courses from Berlin" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/berlin-de/wfs-locations.mjs
var wfs_locations_exports = {};
__export(wfs_locations_exports, {
  schema: () => schema6
});
var schema6;
var init_wfs_locations = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/berlin-de/wfs-locations.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema6 = {
      namespace: "berlinwfs",
      name: "Berlin WFS Locations API",
      description: "Access to Berlin geographic data including dog parks and BBQ areas via WFS services",
      docs: ["https://gdi.berlin.de/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://gdi.berlin.de",
      requiredServerParams: [],
      headers: {},
      routes: {
        dog_parks: {
          requestMethod: "GET",
          description: "All dog parks (Hundefreil\xE4ufe) in Berlin as GeoJSON FeatureCollection",
          route: "/services/wfs/hundefreilauf?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=hundefreilauf%3Ahundefreilauf&OUTPUTFORMAT=application/json",
          parameters: [],
          tests: [
            { _description: "Get all dog parks in Berlin as GeoJSON" }
          ],
          modifiers: []
        },
        bbq_areas: {
          requestMethod: "GET",
          description: "All BBQ areas (Grillfl\xE4chen) in Berlin as GeoJSON FeatureCollection",
          route: "/services/wfs/grillflaechen?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=grillflaechen%3Agrillflaechen&OUTPUTFORMAT=application/json",
          parameters: [],
          tests: [
            { _description: "Get all BBQ areas in Berlin as GeoJSON" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/bicscan/bicscan.mjs
var bicscan_exports = {};
__export(bicscan_exports, {
  schema: () => schema7
});
var schema7;
var init_bicscan = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/bicscan/bicscan.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema7 = {
      namespace: "bicscan",
      name: "BICScan API",
      description: "Risk score and asset scanning API for blockchain addresses via BICScan.",
      docs: ["https://api.bicscan.io/docs"],
      tags: ["security", "risk", "scanning"],
      flowMCP: "1.2.0",
      root: "https://api.bicscan.io/v1/scan",
      requiredServerParams: ["BICSCAN_API_KEY"],
      headers: { "X-Api-Key": "{{BICSCAN_API_KEY}}" },
      routes: {
        getRiskScore: {
          requestMethod: "POST",
          description: "Retrieves a risk score from 0 (safe) to 100 (high risk) for a given crypto address or domain.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["min(3)"] } }
          ],
          tests: [
            { _description: "Test risk score lookup for ENS name", query: "vitalik.eth" },
            { _description: "Test risk score lookup for crypto address", query: "0xd8da6bf26964af9d7eed9e03e53415d37aa96045" }
          ],
          modifiers: [{ phase: "pre", handlerName: "proxyRiskScore" }]
        },
        getAssets: {
          requestMethod: "POST",
          description: "Fetches the asset holdings of a given crypto address using OFAC engine.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["min(3)"] } },
            { position: { key: "engines", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "array()", options: ['default(["ofac"])'] } }
          ],
          tests: [
            { _description: "Test asset scan for wallet address", query: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e", engines: ["ofac"] }
          ],
          modifiers: [{ phase: "pre", handlerName: "proxyAssets" }]
        }
      },
      handlers: {
        proxyRiskScore: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { query } = userParams;
          payload.body = { query, sync: true, assets: false };
          return { struct, payload };
        }, "proxyRiskScore"),
        proxyAssets: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { query, engines } = userParams;
          payload.body = { query, sync: true, assets: true, engines };
          return { struct, payload };
        }, "proxyAssets")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/bitget/bitget.mjs
var bitget_exports = {};
__export(bitget_exports, {
  schema: () => schema8
});
var schema8;
var init_bitget = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/bitget/bitget.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema8 = {
      namespace: "bitget",
      name: "Bitget Crypto Tools",
      description: "Provides crypto data utilities like token prices, announcements, and coin info via Bitget API.",
      docs: ["https://www.bitget.com/api-doc"],
      tags: ["production", "exchange", "trading", "price"],
      flowMCP: "1.2.0",
      root: "https://api.bitget.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTokenPrice: {
          requestMethod: "GET",
          description: "Get the current price of a specific token in USDT pair",
          route: "/api/v2/spot/market/tickers",
          parameters: [
            { position: { key: "symbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get latest price for BTC", symbol: "BTC" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "getTokenPrice" }
          ]
        },
        getAnnoucements: {
          requestMethod: "GET",
          description: "Search for cryptocurrency announcements within the last month by type",
          route: "/api/v2/public/annoucements",
          parameters: [
            { position: { key: "annType", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(latest_news,coin_listings,trading_competitions_promotions,maintenance_system_updates,symbol_delisting,)", options: [] } },
            { position: { key: "language", value: "zh_CN", location: "query" }, z: { primitive: "string()", options: ["default(zh_CN)"] } }
          ],
          tests: [
            { _description: "Get all announcements", annType: "" },
            { _description: "Get latest news", annType: "latest_news" }
          ],
          modifiers: [
            { phase: "execute", handlerName: "getAnnoucements" }
          ]
        },
        getCoinInfo: {
          requestMethod: "GET",
          description: "Get full metadata and chain support info for a spot coin",
          route: "/api/v2/spot/public/coins",
          parameters: [
            { position: { key: "coin", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get coin info for ETH", coin: "ETH" }
          ],
          modifiers: [
            { phase: "execute", handlerName: "getCoinInfo" }
          ]
        }
      },
      handlers: {
        getTokenPrice: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { symbol: symbol17 } = userParams;
          const symbolWithUsdt = symbol17.endsWith("USDT") ? symbol17 : `${symbol17}USDT`;
          payload.url = payload.url.replace(/\?symbol=.*$/, `?symbol=${symbolWithUsdt}`);
          return { struct, payload };
        }, "getTokenPrice"),
        getAnnoucements: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          try {
            const annType = userParams.annType;
            const url2 = `https://api.bitget.com/api/v2/public/annoucements?language=zh_CN&annType=${annType}`;
            const res = await fetch(url2);
            const data = await res.json();
            struct.data = data;
          } catch (e) {
            struct.status = false;
            struct.messages.push(e.message);
          }
          return { struct, payload };
        }, "getAnnoucements"),
        getCoinInfo: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          try {
            const coin = userParams.coin;
            const url2 = `https://api.bitget.com/api/v2/spot/public/coins?coin=${coin}`;
            const res = await fetch(url2);
            const data = await res.json();
            struct.data = data;
          } catch (e) {
            struct.status = false;
            struct.messages.push(e.message);
          }
          return { struct, payload };
        }, "getCoinInfo")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/blockberry-one/mina-mainnet.mjs
var mina_mainnet_exports = {};
__export(mina_mainnet_exports, {
  schema: () => schema9
});
var schema9;
var init_mina_mainnet = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/blockberry-one/mina-mainnet.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema9 = {
      namespace: "blockberry",
      name: "Blockberry Mina Mainnet API",
      description: "Mina blockchain data API for blocks, accounts, and ZkApps (working endpoints only)",
      docs: ["https://docs.blockberry.one/", "https://docs.blockberry.one/reference/mina-mainnet-quickstart"],
      tags: ["production", "blockchain", "explorer", "mina"],
      flowMCP: "1.2.0",
      root: "https://api.blockberry.one/mina-mainnet/v1",
      requiredServerParams: ["BLOCKBERRY_API_KEY"],
      headers: {
        "accept": "application/json",
        "x-api-key": "{{BLOCKBERRY_API_KEY}}"
      },
      routes: {
        // Working Endpoints Only
        getDashboardInfo: {
          requestMethod: "GET",
          description: "Get key Mina blockchain parameters including price, supply, block height, and validator count",
          route: "/info",
          parameters: [],
          tests: [
            { _description: "Get Mina blockchain dashboard info" }
          ],
          modifiers: []
        },
        // Working Account Endpoints
        getAccountByHash: {
          requestMethod: "GET",
          description: "Get detailed account information by public key hash",
          route: "/accounts/{publicKeyHash}",
          parameters: [
            { position: { key: "publicKeyHash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get account details", publicKeyHash: "B62qrAWZFqvgJbfU95t1owLAMKtsDTAGgSZzsBJYUzeQZ7Xwh9CWsEY" }
          ],
          modifiers: []
        },
        getAccountBalance: {
          requestMethod: "GET",
          description: "Get current balance for a specific Mina account",
          route: "/accounts/{publicKeyHash}/balance",
          parameters: [
            { position: { key: "publicKeyHash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get account balance", publicKeyHash: "B62qrAWZFqvgJbfU95t1owLAMKtsDTAGgSZzsBJYUzeQZ7Xwh9CWsEY" }
          ],
          modifiers: []
        },
        // Working Block Endpoints
        getBlocks: {
          requestMethod: "GET",
          description: "Get list of Mina blocks (canonical and orphaned) with pagination",
          route: "/blocks",
          parameters: [
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "default(0)", "optional()"] } },
            { position: { key: "size", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(20)", "optional()"] } },
            { position: { key: "orderBy", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ASC,DESC)", options: ["default(DESC)", "optional()"] } },
            { position: { key: "sortBy", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(HEIGHT,TIMESTAMP)", options: ["default(HEIGHT)", "optional()"] } },
            { position: { key: "type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ALL,CANONICAL,ORPHANED)", options: ["default(ALL)", "optional()"] } }
          ],
          tests: [
            { _description: "Get latest 10 blocks", page: 0, size: 10, orderBy: "DESC", sortBy: "HEIGHT", type: "ALL" }
          ],
          modifiers: []
        },
        // Working ZkApp Endpoints
        getZkAppTransactions: {
          requestMethod: "GET",
          description: "Get list of ZkApp transactions with filtering options",
          route: "/zkapps/transactions",
          parameters: [
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "default(0)", "optional()"] } },
            { position: { key: "size", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(20)", "optional()"] } }
          ],
          tests: [
            { _description: "Get 15 ZkApp transactions", page: 0, size: 15 }
          ],
          modifiers: []
        },
        getZkAppByAddress: {
          requestMethod: "GET",
          description: "Get ZkApp information by account address",
          route: "/zkapps/{address}",
          parameters: [
            { position: { key: "address", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get ZkApp details", address: "B62qrAWZFqvgJbfU95t1owLAMKtsDTAGgSZzsBJYUzeQZ7Xwh9CWsEY" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/blocknative/gasprice.mjs
var gasprice_exports = {};
__export(gasprice_exports, {
  schema: () => schema10
});
var schema10;
var init_gasprice = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/blocknative/gasprice.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema10 = {
      namespace: "blocknative",
      name: "Gas Price Estimator",
      description: "Accurate next-block gas price predictions for Ethereum, Bitcoin, and other supported chains.",
      docs: ["https://docs.blocknative.com"],
      tags: ["new"],
      flowMCP: "1.2.0",
      root: "https://api.blocknative.com",
      requiredServerParams: ["BLOCKNATIVE_API_KEY"],
      headers: { Authorization: "{{BLOCKNATIVE_API_KEY}}" },
      routes: {
        getGasPrices: {
          requestMethod: "GET",
          description: "Returns a range of gas price estimates for the next block across defined confidence levels.",
          route: "/gasprices/blockprices",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ARBITRUM_ONE,AVALANCHE,BASE,BERACHAIN_MAINNET,BINANCE_MAINNET,BITCOIN_MAINNET,BLAST_MAINNET,BOB_MAINNET,CHILIZ_MAINNET,CRONOS_MAINNET,ETHEREUM_MAINNET,FANTOM_MAINNET,FRAXTAL_MAINNET,GNOSIS_MAINNET,IMMUTABLE_ZKEVM_MAINNET,INK_MAINNET,LENS_SEPOLIA_TESTNET,LINEA_MAINNET,LISK_MAINNET,MANTLE_MAINNET,METIS_MAINNET,MODE_TESTNET,MOONBEAM_MAINNET,OPBNB_MAINNET,OPTIMISN_MAINNET,PALM_MAINNET,POLYGON_MAINNET,POLYGONZK_MAINNET,RONIN_MAINNET,RSK_MAINNET,SCROLL_MAINNET,SEI_MAINNET,SNAXCHAIN_MAINNET,SONEIUM_MAINNET,STORY_MAINNET,TAIKO_MAINNET,UNICHAIN_MAINNET,WORLDCHAIN_MAINNET,ZETACHAIN_MAINNET,ZKSYNC_MAINNET,ZORA_MAINNET)", options: [] } },
            { position: { key: "system", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "network", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "confidenceLevels", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "array()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Ethereum default alias", chainName: "ETHEREUM_MAINNET" },
            { _description: "Zora alias + confidence levels", chainName: "ZORA_MAINNET", confidenceLevels: "70,90,99" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "formatBlockPrices" }
          ]
        }
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = userParams.alias?.toUpperCase();
          const chainId = chainIdOptions[alias];
          payload["url"] = payload["url"].replace(`chainName=${alias}`, `chainid=${chainId}`);
          return { struct, payload };
        }, "modifyQuery"),
        formatBlockPrices: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct.data || !struct.data.blockPrices) {
            struct.status = false;
            struct.messages.push("No blockPrices data in response");
            return { struct, payload };
          }
          struct.data = {
            network: struct.data.network,
            system: struct.data.system,
            blockNumber: struct.data.currentBlockNumber,
            estimates: struct.data.blockPrices.map((bp) => ({
              block: bp.blockNumber,
              baseFee: bp.baseFeePerGas,
              estimatedPrices: bp.estimatedPrices.map((p) => ({
                confidence: p.confidence,
                price: p.price,
                priorityFee: p.maxPriorityFeePerGas,
                maxFee: p.maxFeePerGas
              }))
            }))
          };
          return { struct, payload };
        }, "formatBlockPrices")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/bridgerates/bridgerates.mjs
var bridgerates_exports = {};
__export(bridgerates_exports, {
  schema: () => schema11
});
var schema11;
var init_bridgerates = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/bridgerates/bridgerates.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema11 = {
      namespace: "bridgeRates",
      name: "LiFi Bridge API",
      description: "Fetches bridge quotes, supported chains, tools, and cross-chain transfer data from LiFi API",
      docs: ["https://docs.li.fi/", "https://li.quest/v1"],
      tags: ["bridge", "crosschain", "defi"],
      flowMCP: "1.2.0",
      root: "https://li.quest/v1",
      requiredServerParams: [],
      headers: {},
      routes: {
        getSupportedChains: {
          requestMethod: "GET",
          description: "Get information about all currently supported chains for cross-chain transfers.",
          route: "/chains",
          parameters: [],
          tests: [
            { _description: "Get all supported blockchains" }
          ],
          modifiers: []
        },
        getSupportedTools: {
          requestMethod: "GET",
          description: "Get information about the bridges and exchanges available through LiFi service.",
          route: "/tools",
          parameters: [],
          tests: [
            { _description: "Get all available bridges and exchanges" }
          ],
          modifiers: []
        },
        getConnections: {
          requestMethod: "GET",
          description: "Returns all possible connections based on chain filters. At least one filter parameter is required.",
          route: "/connections",
          parameters: [
            { position: { key: "fromChain", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "toChain", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "fromToken", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "toToken", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get connections from Ethereum", fromChain: "1" },
            { _description: "Get connections to Optimism", toChain: "10" }
          ],
          modifiers: []
        },
        getTransferStatus: {
          requestMethod: "GET",
          description: "Check the status of a cross-chain transfer by transaction hash.",
          route: "/status",
          parameters: [
            { position: { key: "txHash", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["length(66)"] } },
            { position: { key: "fromChain", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "toChain", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "bridge", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Check transfer status with example hash", txHash: "0x1234567890123456789012345678901234567890123456789012345678901234", fromChain: "1" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/bscscan/getContractBinance.mjs
var getContractBinance_exports = {};
__export(getContractBinance_exports, {
  schema: () => schema12
});
var schema12;
var init_getContractBinance = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/bscscan/getContractBinance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema12 = {
      namespace: "bscscan",
      name: "BSC Scan",
      description: "BSC Scan API",
      docs: ["https://docs.bscscan.com/"],
      tags: ["test"],
      flowMCP: "1.2.0",
      root: "https://api.bscscan.com/",
      requiredServerParams: ["BSCSCAN_API_KEY"],
      headers: {},
      routes: {
        getContractABI: {
          requestMethod: "GET",
          description: "Returns the Contract ABI of a verified smart contract.",
          route: "/api",
          parameters: [
            { position: { key: "module", value: "contract", location: "body" } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getabi", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(42)", "max(42)"] } },
            { position: { key: "apikey", value: "{{BSCSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Basic test for getContractABI", address: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getContractSourceCode: {
          requestMethod: "GET",
          description: "Returns the Solidity source code of a verified smart contract.",
          route: "/api",
          parameters: [
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getsourcecode", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(42)", "max(42)"] } },
            { position: { key: "apikey", value: "{{BSCSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Basic test for getContractSourceCode", address: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].status !== "1") {
            struct["status"] = false;
            struct["messages"].push(struct.data.message);
            return { struct, payload };
          }
          struct["data"] = struct["data"].result;
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/chainlist/chainlist.mjs
var chainlist_exports = {};
__export(chainlist_exports, {
  schema: () => schema13
});
async function testRPCSpeed(url2, expectedChainId) {
  const startTime = Date.now();
  let result = {
    url: url2,
    status: false,
    timeInMs: null,
    networkId: null
  };
  try {
    const response = await fetch(url2, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_chainId",
        params: [],
        id: 1
      }),
      signal: AbortSignal.timeout(5e3)
    });
    const endTime = Date.now();
    result.timeInMs = endTime - startTime;
    if (response.ok) {
      const data = await response.json();
      if (data.result) {
        result.networkId = parseInt(data.result, 16);
        result.status = !isNaN(result.networkId) && result.networkId === expectedChainId;
      }
    }
  } catch (error42) {
    result.timeInMs = Date.now() - startTime;
  }
  return result;
}
async function testWebSocketSpeed(url2, expectedChainId) {
  return new Promise((resolve) => {
    const startTime = Date.now();
    let result = {
      url: url2,
      status: false,
      timeInMs: null,
      networkId: null
    };
    setTimeout(() => {
      result.timeInMs = Date.now() - startTime;
      result.status = false;
      resolve(result);
    }, 1e3);
  });
}
var schema13;
var init_chainlist = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/chainlist/chainlist.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(testRPCSpeed, "testRPCSpeed");
    __name(testWebSocketSpeed, "testWebSocketSpeed");
    schema13 = {
      namespace: "chainlist",
      name: "Chainlist Tools",
      description: "Query chain metadata (RPCs, explorers, currencies) from Chainlist static feed.",
      docs: ["https://chainlist.org"],
      tags: ["production", "blockchain", "rpc", "network"],
      flowMCP: "1.2.0",
      root: "https://chainlist.org/rpcs.json",
      requiredServerParams: [],
      headers: {},
      routes: {
        getChainById: {
          requestMethod: "GET",
          description: "Returns detailed information for a chain given its numeric chainId.",
          route: "/",
          parameters: [
            { position: { key: "chain_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Fetch Ethereum Mainnet", chain_id: 1 }
          ],
          modifiers: [{ phase: "execute", handlerName: "getChainById" }]
        },
        getChainsByKeyword: {
          requestMethod: "GET",
          description: "Returns all chains that match a keyword substring (case-insensitive).",
          route: "/",
          parameters: [
            { position: { key: "keyword", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(2)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(5)", "min(1)"] } }
          ],
          tests: [
            { _description: "Search for Ethereum", keyword: "eth" },
            { _description: "Search for ZK", keyword: "zk", limit: 2 }
          ],
          modifiers: [{ phase: "execute", handlerName: "getChainsByKeyword" }]
        },
        getExplorerURLs: {
          requestMethod: "GET",
          description: "Returns all block explorer URLs for a specific chain ID.",
          route: "/",
          parameters: [
            { position: { key: "chain_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get Ethereum explorers", chain_id: 1 },
            { _description: "Get Polygon explorers", chain_id: 137 }
          ],
          modifiers: [{ phase: "execute", handlerName: "getExplorerURLs" }]
        },
        getRPCEndpoints: {
          requestMethod: "GET",
          description: "Returns all HTTP RPC endpoints for a specific chain ID with speed testing. Filters out endpoints slower than 5 seconds and sorts by response time.",
          route: "/",
          parameters: [
            { position: { key: "chain_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)"] } },
            { position: { key: "test_speed", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()", "default(false)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(10)", "min(1)"] } }
          ],
          tests: [
            { _description: "Get Ethereum RPC endpoints", chain_id: 1 },
            { _description: "Get Arbitrum RPCs with speed test", chain_id: 42161, test_speed: "true", limit: 5 }
          ],
          modifiers: [{ phase: "execute", handlerName: "getRPCEndpoints" }]
        },
        getWebsocketEndpoints: {
          requestMethod: "GET",
          description: "Returns all WebSocket RPC endpoints for a specific chain ID with speed testing. Filters out endpoints slower than 5 seconds and sorts by response time.",
          route: "/",
          parameters: [
            { position: { key: "chain_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)"] } },
            { position: { key: "test_speed", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()", "default(false)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(5)", "min(1)"] } }
          ],
          tests: [
            { _description: "Get Ethereum WebSocket endpoints", chain_id: 1 },
            { _description: "Get BSC WebSockets with speed test", chain_id: 56, test_speed: "true", limit: 3 }
          ],
          modifiers: [{ phase: "execute", handlerName: "getWebsocketEndpoints" }]
        }
      },
      handlers: {
        getChainById: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { chain_id } = userParams;
          const response = await fetch("https://chainlist.org/rpcs.json");
          const chains = await response.json();
          const chain = chains.find((c) => c.chainId === Number(chain_id));
          if (!chain) {
            struct.status = false;
            struct.messages.push(`No chain found with ID ${chain_id}`);
          } else {
            struct.data = chain;
          }
          return { struct, payload };
        }, "getChainById"),
        getChainsByKeyword: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { keyword, limit = 5 } = userParams;
          const response = await fetch("https://chainlist.org/rpcs.json");
          const chains = await response.json();
          const matches = chains.filter((c) => c.name?.toLowerCase().includes(keyword.toLowerCase()));
          if (!matches.length) {
            struct.status = false;
            struct.messages.push(`No chains found matching '${keyword}'`);
          } else {
            struct.data = matches.slice(0, limit);
          }
          return { struct, payload };
        }, "getChainsByKeyword"),
        getExplorerURLs: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { chain_id } = userParams;
          const response = await fetch("https://chainlist.org/rpcs.json");
          const chains = await response.json();
          const chain = chains.find((c) => c.chainId === Number(chain_id));
          if (!chain) {
            struct.status = false;
            struct.messages.push(`No chain found with ID ${chain_id}`);
          } else if (!chain.explorers || chain.explorers.length === 0) {
            struct.status = false;
            struct.messages.push(`No explorers found for chain ${chain.name} (ID: ${chain_id})`);
          } else {
            struct.data = {
              chainId: chain.chainId,
              chainName: chain.name,
              explorers: chain.explorers
            };
          }
          return { struct, payload };
        }, "getExplorerURLs"),
        getRPCEndpoints: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { chain_id, test_speed = "false", limit = 10 } = userParams;
          const response = await fetch("https://chainlist.org/rpcs.json");
          const chains = await response.json();
          const chain = chains.find((c) => c.chainId === Number(chain_id));
          if (!chain) {
            struct.status = false;
            struct.messages.push(`No chain found with ID ${chain_id}`);
            return { struct, payload };
          }
          const httpEndpoints = chain.rpc.filter((rpc) => rpc.url.startsWith("http"));
          if (httpEndpoints.length === 0) {
            struct.status = false;
            struct.messages.push(`No HTTP RPC endpoints found for chain ${chain.name} (ID: ${chain_id})`);
            return { struct, payload };
          }
          if (test_speed === "true") {
            const testResults = [];
            const endpointsToTest = httpEndpoints.slice(0, Math.min(limit, 15));
            for (const rpc of endpointsToTest) {
              const result = await testRPCSpeed(rpc.url, Number(chain_id));
              result.tracking = rpc.tracking || "unknown";
              result.isOpenSource = rpc.isOpenSource || false;
              testResults.push(result);
            }
            const workingEndpoints = testResults.filter((r2) => r2.status && r2.timeInMs <= 5e3).sort((a2, b) => a2.timeInMs - b.timeInMs);
            struct.data = {
              chainId: chain.chainId,
              chainName: chain.name,
              totalTested: testResults.length,
              workingEndpoints: workingEndpoints.length,
              fastestEndpoints: workingEndpoints,
              speedTestPerformed: true
            };
          } else {
            struct.data = {
              chainId: chain.chainId,
              chainName: chain.name,
              totalEndpoints: httpEndpoints.length,
              rpcEndpoints: httpEndpoints,
              speedTestPerformed: false
            };
          }
          return { struct, payload };
        }, "getRPCEndpoints"),
        getWebsocketEndpoints: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { chain_id, test_speed = "false", limit = 5 } = userParams;
          const response = await fetch("https://chainlist.org/rpcs.json");
          const chains = await response.json();
          const chain = chains.find((c) => c.chainId === Number(chain_id));
          if (!chain) {
            struct.status = false;
            struct.messages.push(`No chain found with ID ${chain_id}`);
            return { struct, payload };
          }
          const wsEndpoints = chain.rpc.filter((rpc) => rpc.url.startsWith("ws"));
          if (wsEndpoints.length === 0) {
            struct.status = false;
            struct.messages.push(`No WebSocket endpoints found for chain ${chain.name} (ID: ${chain_id})`);
            return { struct, payload };
          }
          if (test_speed === "true") {
            const testResults = [];
            const endpointsToTest = wsEndpoints.slice(0, Math.min(limit, 10));
            for (const rpc of endpointsToTest) {
              const result = await testWebSocketSpeed(rpc.url, Number(chain_id));
              result.tracking = rpc.tracking || "unknown";
              testResults.push(result);
            }
            const workingEndpoints = testResults.filter((r2) => r2.status && r2.timeInMs <= 5e3).sort((a2, b) => a2.timeInMs - b.timeInMs);
            struct.data = {
              chainId: chain.chainId,
              chainName: chain.name,
              totalTested: testResults.length,
              workingEndpoints: workingEndpoints.length,
              fastestEndpoints: workingEndpoints,
              speedTestPerformed: true
            };
          } else {
            struct.data = {
              chainId: chain.chainId,
              chainName: chain.name,
              totalEndpoints: wsEndpoints.length,
              websocketEndpoints: wsEndpoints,
              speedTestPerformed: false
            };
          }
          return { struct, payload };
        }, "getWebsocketEndpoints")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/chart-img-com/tradingview-charts.mjs
var tradingview_charts_exports = {};
__export(tradingview_charts_exports, {
  schema: () => schema14
});
var schema14;
var init_tradingview_charts = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/chart-img-com/tradingview-charts.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema14 = {
      namespace: "chartImg",
      name: "Chart Image API",
      description: "High-quality TradingView chart screenshots and financial chart image generation service",
      docs: ["https://doc.chart-img.com"],
      tags: ["charts", "visualization", "trading"],
      flowMCP: "1.2.0",
      root: "https://api.chart-img.com",
      requiredServerParams: ["CHART_IMG_API_KEY"],
      headers: { "x-api-key": "{{CHART_IMG_API_KEY}}" },
      handlers: {
        rateLimitHandler: /* @__PURE__ */ __name(async ({ struct, payload, userParams, server }) => {
          const maxRetries = 3;
          const baseDelay = 2e3;
          for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
              const response = await fetch(payload.url, {
                method: payload.method,
                headers: payload.headers,
                body: JSON.stringify(payload.body)
              });
              if (response.status === 429) {
                if (attempt < maxRetries) {
                  const delay = baseDelay * Math.pow(2, attempt);
                  struct.messages.push(`Rate limited, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries + 1})`);
                  await new Promise((resolve) => setTimeout(resolve, delay));
                  continue;
                } else {
                  struct.status = false;
                  struct.messages.push(`Rate limit exceeded after ${maxRetries + 1} attempts`);
                  return { struct, payload };
                }
              }
              struct.httpStatus = response.status;
              struct.responseHeaders = Object.fromEntries(response.headers.entries());
              struct.dataAsString = await response.text();
              if (response.ok) {
                try {
                  struct.data = JSON.parse(struct.dataAsString);
                } catch {
                  struct.data = { rawResponse: struct.dataAsString };
                }
              } else {
                struct.status = false;
                struct.messages.push(`HTTP ${response.status}: ${response.statusText}`);
              }
              return { struct, payload };
            } catch (error42) {
              if (attempt < maxRetries) {
                const delay = baseDelay * Math.pow(2, attempt);
                struct.messages.push(`Request failed, retrying in ${delay}ms: ${error42.message}`);
                await new Promise((resolve) => setTimeout(resolve, delay));
                continue;
              } else {
                struct.status = false;
                struct.messages.push(`Request failed after ${maxRetries + 1} attempts: ${error42.message}`);
                return { struct, payload };
              }
            }
          }
        }, "rateLimitHandler")
      },
      routes: {
        getAdvancedChart: {
          requestMethod: "POST",
          description: "Capture a high-quality screenshot of a TradingView advanced chart with specified symbol and settings",
          route: "/v2/tradingview/advanced-chart",
          parameters: [
            { position: { key: "symbol", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "enum(1m,3m,5m,15m,30m,45m,1h,4h,1D,1W,1M)", options: ["default(15m)", "optional()"] } },
            { position: { key: "theme", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "enum(light,dark)", options: ["default(dark)", "optional()"] } },
            { position: { key: "width", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(400)", "max(2000)", "default(1200)", "optional()"] } },
            { position: { key: "height", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(300)", "max(1500)", "default(800)", "optional()"] } },
            { position: { key: "session", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "enum(regular,extended)", options: ["default(extended)", "optional()"] } },
            { position: { key: "timezone", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["default(America/New_York)", "optional()"] } }
          ],
          tests: [
            { _description: "Screenshot Tesla stock", symbol: "NASDAQ:TSLA", interval: "15m", theme: "dark", height: 600 }
          ],
          modifiers: [{ phase: "execute", handlerName: "rateLimitHandler" }]
        }
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coincap/assets.mjs
var assets_exports = {};
__export(assets_exports, {
  schema: () => schema15
});
var schema15;
var init_assets = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coincap/assets.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema15 = {
      namespace: "coincap",
      name: "AssetsAPI",
      description: "Retrieve data about crypto assets and markets",
      docs: ["https://pro.coincap.io/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://rest.coincap.io/v3",
      requiredServerParams: ["COINCAP_API_KEY"],
      headers: {
        Authorization: "Bearer {{COINCAP_API_KEY}}"
      },
      routes: {
        listAssets: {
          requestMethod: "GET",
          description: "Retrieve a list of assets",
          route: "/assets",
          parameters: [
            { position: { key: "search", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(100)"] } },
            { position: { key: "offset", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(0)"] } }
          ],
          tests: [
            { _description: "Fetch first 10 assets", limit: 10 },
            { _description: "Search for bitcoin", search: "bitcoin" }
          ],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        singleAsset: {
          requestMethod: "GET",
          description: "Retrieve details for a specific asset",
          route: "/assets/:slug",
          parameters: [
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Fetch Bitcoin data", slug: "bitcoin" }
          ],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        assetMarkets: {
          requestMethod: "GET",
          description: "Retrieve market data for an asset",
          route: "/assets/:slug/markets",
          parameters: [
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(100)"] } },
            { position: { key: "offset", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(0)"] } }
          ],
          tests: [
            { _description: "Markets for bitcoin", slug: "bitcoin" }
          ],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        assetHistory: {
          requestMethod: "GET",
          description: "Retrieve historical data for an asset",
          route: "/assets/:slug/history",
          parameters: [
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(m1,m5,m15,m30,h1,h2,h6,h12,d1)", options: [] } },
            { position: { key: "start", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "end", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "1-day history for bitcoin", slug: "bitcoin", interval: "d1" }
          ],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coincap/exchanges.mjs
var exchanges_exports = {};
__export(exchanges_exports, {
  schema: () => schema16
});
var schema16;
var init_exchanges = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coincap/exchanges.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema16 = {
      namespace: "coincap",
      name: "CoinCapExchanges",
      description: "Access exchange data from CoinCap including metadata and volume",
      docs: ["https://pro.coincap.io/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://rest.coincap.io/v3",
      requiredServerParams: ["COINCAP_API_KEY"],
      headers: {
        Authorization: "Bearer {{COINCAP_API_KEY}}"
      },
      routes: {
        listExchanges: {
          requestMethod: "GET",
          description: "Retrieve a list of exchanges",
          route: "/exchanges",
          parameters: [
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(10)", "optional()"] } },
            { position: { key: "offset", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(0)", "optional()"] } }
          ],
          tests: [
            { _description: "List 5 exchanges", limit: 5 },
            { _description: "List exchanges with offset", offset: 2 }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getExchangeById: {
          requestMethod: "GET",
          description: "Retrieve details for a specific exchange",
          route: "/exchanges/:exchange",
          parameters: [
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Fetch Binance.US exchange", exchange: "binanceus" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coincap/markets.mjs
var markets_exports = {};
__export(markets_exports, {
  schema: () => schema17
});
var schema17;
var init_markets = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coincap/markets.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema17 = {
      namespace: "coincap",
      name: "CoinCapMarkets",
      description: "Access CoinCap market data including price, volume, and exchange metadata",
      docs: ["https://pro.coincap.io/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://rest.coincap.io/v3",
      requiredServerParams: ["COINCAP_API_KEY"],
      headers: {
        Authorization: "Bearer {{COINCAP_API_KEY}}"
      },
      routes: {
        listMarkets: {
          requestMethod: "GET",
          description: "Retrieve a list of markets with optional filters",
          route: "/markets",
          parameters: [
            { position: { key: "exchangeId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "baseSymbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "baseId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "quoteSymbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "quoteId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "assetSymbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "assetId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(10)", "optional()"] } },
            { position: { key: "offset", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(0)", "optional()"] } }
          ],
          tests: [
            { _description: "Default market list" },
            { _description: "Markets from BinanceUS", exchangeId: "binanceus" },
            { _description: "Markets for base asset BTC", baseSymbol: "BTC" },
            { _description: "Limit results to 5", limit: 5 }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coincap/rates.mjs
var rates_exports = {};
__export(rates_exports, {
  schema: () => schema18
});
var schema18;
var init_rates = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coincap/rates.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema18 = {
      namespace: "coincap",
      name: "CoinCapRates",
      description: "Access fiat and crypto conversion rates from CoinCap",
      docs: ["https://pro.coincap.io/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://rest.coincap.io/v3",
      requiredServerParams: ["COINCAP_API_KEY"],
      headers: {
        Authorization: "Bearer {{COINCAP_API_KEY}}"
      },
      routes: {
        listRates: {
          requestMethod: "GET",
          description: "Retrieve all conversion rates or filter by comma-separated slugs",
          route: "/rates",
          parameters: [
            { position: { key: "ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get all rates" },
            { _description: "Filter rates by bitcoin,ethereum", ids: "bitcoin,ethereum" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getRateBySlug: {
          requestMethod: "GET",
          description: "Retrieve a specific conversion rate by slug",
          route: "/rates/:slug",
          parameters: [
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get bitcoin rate", slug: "bitcoin" },
            { _description: "Get invalid rate", slug: "invalid-slug" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/coingecko-stablecoins.mjs
var coingecko_stablecoins_exports = {};
__export(coingecko_stablecoins_exports, {
  schema: () => schema19
});
var schema19;
var init_coingecko_stablecoins = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/coingecko-stablecoins.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema19 = {
      namespace: "coingecko",
      name: "CoinGecko Stablecoins API",
      description: "Access and analyze stablecoin data including market metrics, peg stability and historical trends via CoinGecko API",
      docs: ["https://docs.coingecko.com/reference/simple-price", "https://docs.coingecko.com/reference/coins-id-market-chart"],
      tags: ["price", "market", "stablecoins"],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getSupportedStablecoins: {
          requestMethod: "GET",
          description: "Get list of all stablecoins from CoinGecko with market data.",
          route: "/coins/markets",
          parameters: [
            { position: { key: "vs_currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(usd)"] } },
            { position: { key: "category", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(stablecoins)"] } },
            { position: { key: "order", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(market_cap_desc)"] } },
            { position: { key: "per_page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(50)", "min(1)", "max(250)"] } }
          ],
          tests: [
            { _description: "Get top 50 stablecoins by market cap", vs_currency: "usd", category: "stablecoins", order: "market_cap_desc", per_page: 50 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatStablecoinData" }
          ]
        },
        getCurrentPrice: {
          requestMethod: "GET",
          description: "Fetches current prices for major stablecoins with peg stability analysis.",
          route: "/simple/price",
          parameters: [
            { position: { key: "ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(tether,usd-coin,dai,ethena-usde,first-digital-usd,paypal-usd,true-usd)"] } },
            { position: { key: "vs_currencies", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(usd)"] } },
            { position: { key: "include_24hr_change", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["default(true)"] } }
          ],
          tests: [
            { _description: "Get current prices for major stablecoins", ids: "tether,usd-coin,dai", vs_currencies: "usd", include_24hr_change: true }
          ],
          modifiers: [
            { phase: "post", handlerName: "analyzePegStability" }
          ]
        },
        getHistoricalData: {
          requestMethod: "GET",
          description: "Fetch historical market chart data for a specific stablecoin.",
          route: "/coins/:id/market_chart",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(tether,usd-coin,dai,ethena-usde,first-digital-usd,paypal-usd,true-usd,frax,gemini-dollar,paxos-standard)", options: [] } },
            { position: { key: "vs_currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(usd)"] } },
            { position: { key: "days", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(7)", "min(1)", "max(90)"] } }
          ],
          tests: [
            { _description: "Get 7-day historical data for USDT", id: "tether", vs_currency: "usd", days: 7 },
            { _description: "Get 30-day historical data for USDC", id: "usd-coin", vs_currency: "usd", days: 30 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatHistoricalData" }
          ]
        },
        analyzePegStability: {
          requestMethod: "GET",
          description: "Analyze peg stability for multiple stablecoins by comparing current prices to $1.00.",
          route: "/simple/price",
          parameters: [
            { position: { key: "ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(tether,usd-coin,dai,ethena-usde,first-digital-usd)"] } },
            { position: { key: "vs_currencies", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["default(usd)"] } },
            { position: { key: "include_24hr_change", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["default(true)"] } }
          ],
          tests: [
            { _description: "Analyze peg stability for top 5 stablecoins", ids: "tether,usd-coin,dai,ethena-usde,first-digital-usd", vs_currencies: "usd", include_24hr_change: true }
          ],
          modifiers: [
            { phase: "post", handlerName: "calculatePegDeviations" }
          ]
        }
      },
      handlers: {
        formatStablecoinData: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct.data || !Array.isArray(struct.data)) {
            return { struct, payload };
          }
          const stablecoins = struct.data.map((coin) => ({
            name: coin.name,
            symbol: coin.symbol.toUpperCase(),
            current_price: coin.current_price,
            market_cap: coin.market_cap,
            market_cap_rank: coin.market_cap_rank,
            price_change_24h: coin.price_change_percentage_24h,
            peg_deviation: Math.abs(coin.current_price - 1) * 100
          }));
          struct.data = {
            total_stablecoins: stablecoins.length,
            stablecoins
          };
          return { struct, payload };
        }, "formatStablecoinData"),
        analyzePegStability: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct.data) {
            return { struct, payload };
          }
          const analysis = Object.entries(struct.data).map(([coinId, data]) => {
            const price = data.usd;
            const change24h = data.usd_24h_change || 0;
            const deviation = Math.abs(price - 1) * 100;
            let stability_status;
            if (deviation < 0.1) stability_status = "Excellent";
            else if (deviation < 0.5) stability_status = "Good";
            else if (deviation < 1) stability_status = "Moderate";
            else stability_status = "Poor";
            return {
              coin_id: coinId,
              current_price: price,
              peg_deviation_percent: deviation.toFixed(3),
              change_24h_percent: change24h.toFixed(3),
              stability_status
            };
          });
          struct.data = {
            analysis_timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            stablecoin_analysis: analysis
          };
          return { struct, payload };
        }, "analyzePegStability"),
        formatHistoricalData: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct.data || !struct.data.prices) {
            return { struct, payload };
          }
          const prices = struct.data.prices;
          const volumes = struct.data.total_volumes || [];
          const priceValues = prices.map((p) => p[1]);
          const avgPrice = priceValues.reduce((a2, b) => a2 + b, 0) / priceValues.length;
          const maxPrice = Math.max(...priceValues);
          const minPrice = Math.min(...priceValues);
          const maxDeviation = Math.max(
            Math.abs(maxPrice - 1),
            Math.abs(minPrice - 1)
          ) * 100;
          struct.data = {
            period_summary: {
              average_price: avgPrice.toFixed(6),
              max_price: maxPrice.toFixed(6),
              min_price: minPrice.toFixed(6),
              max_peg_deviation_percent: maxDeviation.toFixed(3),
              total_data_points: prices.length
            },
            price_data: prices.slice(0, 50),
            // Limit to first 50 points for readability
            volume_data: volumes.slice(0, 50)
          };
          return { struct, payload };
        }, "formatHistoricalData"),
        calculatePegDeviations: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct.data) {
            return { struct, payload };
          }
          const deviations = Object.entries(struct.data).map(([coinId, data]) => {
            const price = data.usd;
            const change24h = data.usd_24h_change || 0;
            const deviation = Math.abs(price - 1) * 100;
            return {
              coin_id: coinId,
              current_price: price,
              deviation_from_peg: deviation.toFixed(4),
              change_24h: change24h.toFixed(4),
              risk_level: deviation < 0.1 ? "Low" : deviation < 0.5 ? "Medium" : "High"
            };
          }).sort((a2, b) => parseFloat(b.deviation_from_peg) - parseFloat(a2.deviation_from_peg));
          struct.data = {
            analysis_timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            most_stable: deviations[deviations.length - 1],
            least_stable: deviations[0],
            all_deviations: deviations
          };
          return { struct, payload };
        }, "calculatePegDeviations")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/coins.mjs
var coins_exports = {};
__export(coins_exports, {
  schema: () => schema20
});
var schema20;
var init_coins = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/coins.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema20 = {
      namespace: "coingecko",
      name: "CoinGeckoCoins",
      description: "Fetch coins list, markets, details, history, tickers, and token info from CoinGecko",
      docs: ["https://docs.coingecko.com/reference/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getCoinsList: {
          requestMethod: "GET",
          description: "Fetch the list of all coins (id, symbol, name)",
          route: "/coins/list",
          parameters: [],
          tests: [{ _description: "Test getCoinsList - should return list of coins" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        getCoinsMarkets: {
          requestMethod: "GET",
          description: "Fetch market data for coins",
          route: "/coins/markets",
          parameters: [
            { position: { key: "vs_currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [{ _description: "Test getCoinsMarkets - should return BTC market data", vs_currency: "usd", ids: "bitcoin" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        getCoinById: {
          requestMethod: "GET",
          description: "Fetch detailed info for a specific coin",
          route: "/coins/:id",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test getCoinById - should return Bitcoin details", id: "bitcoin" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        getCoinMarketChart: {
          requestMethod: "GET",
          description: "Fetch historical market chart data for a coin",
          route: "/coins/:id/market_chart",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "vs_currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "days", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test getCoinMarketChart - should return BTC 7d chart", id: "bitcoin", vs_currency: "usd", days: "7" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        getCoinHistory: {
          requestMethod: "GET",
          description: "Fetch historical coin data by date",
          route: "/coins/:id/history",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "date", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test getCoinHistory - should return BTC data for 30-12-2020", id: "bitcoin", date: "30-12-2024" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        getCoinTickers: {
          requestMethod: "GET",
          description: "Fetch all trading pairs (tickers) for a coin",
          route: "/coins/:id/tickers",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test getCoinTickers - should return tickers for Bitcoin", id: "bitcoin" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        getCoinContractInfo: {
          requestMethod: "GET",
          description: "Fetch coin information by contract address",
          route: "/coins/:id/contract/:contract_address",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "contract_address", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test getCoinContractInfo - should return PEPE token info on Ethereum", id: "ethereum", contract_address: "0x6982508145454ce325ddbe47a25d4ec3d2311933" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/derivatives.mjs
var derivatives_exports = {};
__export(derivatives_exports, {
  schema: () => schema21
});
var schema21;
var init_derivatives = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/derivatives.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema21 = {
      namespace: "coingecko",
      name: "CoinGeckoDerivatives",
      description: "Retrieve derivatives markets and derivative exchanges from CoinGecko",
      docs: ["https://docs.coingecko.com/reference/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getDerivativeExchangeIds: {
          requestMethod: "GET",
          description: "Fetch the list of derivative exchanges",
          route: "/derivatives/exchanges",
          parameters: [],
          tests: [
            { _description: "Test getDerivativesExchanges - should return a list of derivative exchanges" }
          ],
          modifiers: [
            { phase: "post", handlerName: "getDerivativeExchangeIds" }
          ]
        },
        getDerivativeExchangesByIds: {
          requestMethod: "GET",
          description: "Fetch the list of derivative exchanges by IDs",
          route: "/derivatives/exchanges/",
          parameters: [
            { position: { key: "exchange_ids", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "array()", options: [] } }
          ],
          tests: [
            { _description: "Test getExchangesByIds - should return a list of derivative exchanges by IDs", exchange_ids: ["binance_futures", "okex_futures"] }
          ],
          modifiers: [
            { phase: "post", handlerName: "getDerivativeExchangesByIds" }
          ]
        },
        getDerivativeProductsByExchangeId: {
          requestMethod: "GET",
          description: "Fetch the list of derivative products by exchange ID",
          route: "/derivatives/",
          parameters: [
            { position: { key: "exchange_id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "minimal_output", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Test getDerivativesByExchangeId - should return a list of derivative products by exchange ID", exchange_id: "binance_futures" },
            { _description: "Test getDerivativesByExchangeId - should return a list of derivative products by exchange ID", exchange_id: "binance_futures", minimal_output: "false" }
          ],
          modifiers: []
        }
        /*
              getDerivativesExchanges: {
                requestMethod: "GET",
                description: "Fetch the list of derivative exchanges",
                route: "/derivatives/exchanges",
                parameters: [],
                tests: [
                  { _description: "Test getDerivativesExchanges - should return a list of derivative exchanges" }
                ],
                modifiers: []
              },
              getDerivatives: {
                requestMethod: "GET",
                description: "Fetch the list of derivatives products like Futures and Perpetuals",
                route: "/derivatives",
                parameters: [],
                tests: [
                  { _description: "Test getDerivatives - should return a list of derivative products" } 
                ],
                modifiers: [
                  { phase: "post", handlerName: "extractDerivatives" }
                ]
              }
        */
      },
      handlers: {
        getDerivativeExchangeIds: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct["data"] = {
            "exchange_ids": struct["data"].map((c) => c["id"])
          };
          return { struct, payload };
        }, "getDerivativeExchangeIds"),
        getDerivativeExchangesByIds: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { exchange_ids } = userParams;
          struct["data"] = exchange_ids.reduce((acc, id) => {
            const item = struct["data"].filter((c) => c["id"] === id);
            acc[id] = item ? item[0] : null;
            return acc;
          }, {});
          return { struct, payload };
        }, "getDerivativeExchangesByIds"),
        getDerivativeProductsByExchangeId: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { exchange_id, minimal_output } = userParams;
          if (!minimal_output) {
            struct["data"] = struct["data"].filter((c) => c["exchange_id"] === exchange_id);
          } else {
            struct["data"] = struct["data"].filter((c) => c["exchange_id"] === exchange_id).map((c) => {
              const { symbol: symbol17, contract_type } = c;
              return { symbol: symbol17, contract_type };
            });
          }
          return { struct, payload };
        }, "getDerivativeProductsByExchangeId")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/exchanges.mjs
var exchanges_exports2 = {};
__export(exchanges_exports2, {
  schema: () => schema22
});
var schema22;
var init_exchanges2 = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/exchanges.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema22 = {
      namespace: "coingecko",
      name: "CoinGeckoExchanges",
      description: "Fetch exchanges list, exchange details, and exchange trading pairs from CoinGecko",
      docs: ["https://docs.coingecko.com/reference/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getExchangesList: {
          requestMethod: "GET",
          description: "Fetch the list of all supported exchanges",
          route: "/exchanges/list",
          parameters: [],
          tests: [{ _description: "Test getExchangesList - should return a list of exchanges" }],
          modifiers: [
            // { phase: "post", handlerName: "extractExchangesList" }
          ]
        },
        getExchangeById: {
          requestMethod: "GET",
          description: "Fetch details of a specific exchange",
          route: "/exchanges/:id",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test getExchangeById - should return Binance details", id: "binance" }],
          modifiers: [
            { phase: "post", handlerName: "getExchangeById" }
          ]
        },
        getExchangeTickers: {
          requestMethod: "GET",
          description: "Fetch trading pairs (tickers) for a specific exchange",
          route: "/exchanges/:id/tickers",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test getExchangeTickers - should return tickers for Binance", id: "binance" }],
          modifiers: [
            { phase: "post", handlerName: "getExchangeTickers" }
          ]
        }
      },
      handlers: {
        getExchangeById: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct["data"]["tickers"] = struct["data"]["tickers"].map((t2) => {
            const { base, target, last, volume } = t2;
            const result = { base, target, last_price: last, volume };
            return result;
          });
          return { struct, payload };
        }, "getExchangeById"),
        getExchangeTickers: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct["data"] = struct["data"]["tickers"];
          return { struct, payload };
        }, "getExchangeTickers")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/getCategories.mjs
var getCategories_exports = {};
__export(getCategories_exports, {
  schema: () => schema23
});
var schema23;
var init_getCategories = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/getCategories.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema23 = {
      namespace: "coingecko",
      name: "CoinGeckoCategories",
      description: "Retrieve coin categories and category names using CoinGecko public API",
      docs: ["https://docs.coingecko.com/reference/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getAvailableCoinCategoryIds: {
          requestMethod: "GET",
          description: "Fetch a short list of coin category names",
          route: "/coins/categories/list",
          parameters: [],
          tests: [
            { _description: "Test getCoinCategoriesList - should return a list of category names" }
          ],
          modifiers: [
            { phase: "post", handlerName: "getAvailableCoinCategoryIds" }
          ]
        },
        getCoinCategoryDetailsByIds: {
          requestMethod: "GET",
          description: "Fetch the full list of coin categories including detailed metrics",
          route: "/coins/categories",
          parameters: [
            { position: { key: "category_ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "array()", options: [] } }
          ],
          tests: [
            { _description: "Test getCoinCategories - should return a list of categories", category_ids: ["base-meme-coins", "meme-token"] }
          ],
          modifiers: [{ phase: "post", handlerName: "getCoinCategoryDetailsByIds" }]
        }
      },
      handlers: {
        getAvailableCoinCategoryIds: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.data = struct["data"] = {
            "category_ids": struct["data"].map((c) => c["category_id"])
          };
          return { struct, payload };
        }, "getAvailableCoinCategoryIds"),
        getCoinCategoryDetailsByIds: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { category_ids } = userParams;
          const itemsByCategory = category_ids.reduce((acc, id) => {
            const item = struct["data"].filter((c) => c["id"] === id);
            acc[id] = item ? item[0] : null;
            return acc;
          }, {});
          struct["data"] = itemsByCategory;
          return { struct, payload };
        }, "getCoinCategoryDetailsByIds")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/global.mjs
var global_exports = {};
__export(global_exports, {
  schema: () => schema24
});
var schema24;
var init_global = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/global.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema24 = {
      namespace: "coingecko",
      name: "CoinGeckoGlobal",
      description: "Fetch global and DeFi global market data from CoinGecko",
      docs: ["https://docs.coingecko.com/reference/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getGlobalData: {
          requestMethod: "GET",
          description: "Fetch overall global market data",
          route: "/global",
          parameters: [],
          tests: [
            { _description: "Test getGlobalData - should return global market info" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getDeFiGlobalData: {
          requestMethod: "GET",
          description: "Fetch global DeFi market data",
          route: "/global/decentralized_finance_defi",
          parameters: [],
          tests: [
            { _description: "Test getDeFiGlobalData - should return global DeFi stats" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct["data"] = struct["data"]["data"] || [];
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/simplePrice.mjs
var simplePrice_exports = {};
__export(simplePrice_exports, {
  schema: () => schema25
});
var schema25;
var init_simplePrice = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/simplePrice.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema25 = {
      namespace: "coingecko",
      name: "CoinGeckoSimplePrice",
      description: "Fetch current prices for coins and tokens using CoinGecko's Simple API",
      docs: ["https://docs.coingecko.com/reference/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getSimplePrice: {
          requestMethod: "GET",
          description: "Fetch current price for one or more coins",
          route: "/simple/price",
          parameters: [
            { position: { key: "ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "array()", options: [] } },
            { position: { key: "vs_currencies", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test getSimplePrice - should return BTC in USD", ids: ["bitcoin", "ethereum"], vs_currencies: "usd" }
          ],
          modifiers: [
            { phase: "post", handlerName: "extractSimplePrices" }
          ]
        },
        getTokenPrice: {
          requestMethod: "GET",
          description: "Fetch token price by contract address and chain",
          route: "/simple/token_price/:id",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "contract_addresses", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "vs_currencies", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            {
              _description: "Test getTokenPrice - should return PEPE token price in USD on Ethereum",
              id: "ethereum",
              contract_addresses: "0x6982508145454ce325ddbe47a25d4ec3d2311933",
              vs_currencies: "usd"
            }
          ],
          modifiers: [
            { phase: "post", handlerName: "extractTokenPrices" }
          ]
        }
      },
      handlers: {
        extractSimplePrices: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          console.log(struct["data"]);
          struct["data"] = Object.entries(struct["data"]).map(([id, prices]) => ({ id, prices }));
          console.log(">>>", struct["data"]);
          return { struct, payload };
        }, "extractSimplePrices"),
        extractTokenPrices: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          console.log(struct["data"]);
          struct["data"] = Object.entries(struct["data"]).map(([contract, prices]) => ({ contract, prices }));
          return { struct, payload };
        }, "extractTokenPrices")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/trending.mjs
var trending_exports = {};
__export(trending_exports, {
  schema: () => schema26
});
var schema26;
var init_trending = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coingecko-com/trending.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema26 = {
      namespace: "coingecko",
      name: "CoinGeckoTrending",
      description: "Retrieve trending coins, NFTs, and categories from CoinGecko trending search",
      docs: ["https://docs.coingecko.com/reference/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.coingecko.com/api/v3",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTrendingCoins: {
          requestMethod: "GET",
          description: "Fetch trending coins from CoinGecko",
          route: "/search/trending",
          parameters: [],
          tests: [
            { _description: "Test getTrendingCoins - should return a list of trending coins" }
          ],
          modifiers: [
            { phase: "post", handlerName: "extractTrendingCoins" }
          ]
        },
        getTrendingNfts: {
          requestMethod: "GET",
          description: "Fetch trending NFTs from CoinGecko",
          route: "/search/trending",
          parameters: [],
          tests: [
            { _description: "Test getTrendingNfts - should return a list of trending NFTs" }
          ],
          modifiers: [
            { phase: "post", handlerName: "extractTrendingNfts" }
          ]
        },
        getTrendingCategories: {
          requestMethod: "GET",
          description: "Fetch trending categories from CoinGecko",
          route: "/search/trending",
          parameters: [],
          tests: [
            { _description: "Test getTrendingCategories - should return a list of trending categories" }
          ],
          modifiers: [
            { phase: "post", handlerName: "extractTrendingCategories" }
          ]
        }
      },
      handlers: {
        extractTrendingCoins: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const items = struct["data"]["coins"].map((item) => {
            item = item["item"];
            delete item["small"];
            delete item["large"];
            item["data"]["price_change_percentage_24h"] = item["data"]["price_change_percentage_24h"]["usd"];
            Object.entries(item["data"]).forEach(([key, value]) => {
              item[`_data.${key}`] = value;
              delete item["data"][key];
            });
            delete item["data"];
            return item;
          });
          struct["data"] = {
            "total": items.length,
            "items": items
          };
          return { struct, payload };
        }, "extractTrendingCoins"),
        extractTrendingNfts: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          struct["data"] = struct["data"]["nfts"].map((item) => {
            Object.entries(item["data"]).forEach(([key, value]) => {
              item[`_data.${key}`] = value;
              delete item["data"][key];
            });
            delete item["data"];
            return item;
          });
          return { struct, payload };
        }, "extractTrendingNfts"),
        extractTrendingCategories: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          struct["data"] = struct["data"]["categories"].map((item) => {
            item["data"]["market_cap_change_percentage_24h"] = item["data"]["market_cap_change_percentage_24h"]["usd"];
            Object.entries(item["data"]).forEach(([key, value]) => {
              item[`_data.${key}`] = value;
              delete item["data"][key];
            });
            delete item["data"];
            return item;
          });
          return { struct, payload };
        }, "extractTrendingCategories")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/category.mjs
var category_exports = {};
__export(category_exports, {
  schema: () => schema27
});
var schema27;
var init_category = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/category.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema27 = {
      namespace: "coinmarketcap",
      name: "CoinMarketCap Categories",
      description: "Retrieve information about cryptocurrency categories from CoinMarketCap.",
      docs: ["https://coinmarketcap.com/api/documentation/v1/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://pro-api.coinmarketcap.com",
      requiredServerParams: ["CMC_API_KEY"],
      headers: {
        "X-CMC_PRO_API_KEY": "{{CMC_API_KEY}}"
      },
      routes: {
        getCategories: {
          requestMethod: "GET",
          description: "Get a list of all cryptocurrency categories.",
          route: "/v1/cryptocurrency/categories",
          parameters: [
            { position: { key: "start", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(5000)", "optional()"] } },
            { position: { key: "id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "symbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Fetch categories with default pagination" }
            // { _description: "Fetch categories starting from 10, limit 100", start: 10, limit: 100 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modify" },
            { phase: "post", handlerName: "modify" }
          ]
        },
        getCategory: {
          requestMethod: "GET",
          description: "Get information about a single cryptocurrency category.",
          route: "/v1/cryptocurrency/category",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "start", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(1000)", "optional()"] } },
            { position: { key: "convert", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "convert_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Fetch a category by ID", id: "605e2ce9d41eae1066535f7c" }
            // { _description: "Fetch a category by ID with pagination", id: "605e2ce9d41eae1066535f7c", start: 1, limit: 50 }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        },
        getIdMap: {
          requestMethod: "GET",
          description: "Get a mapping of all cryptocurrencies to unique CoinMarketCap IDs.",
          route: "/v1/cryptocurrency/map",
          parameters: [
            { position: { key: "listing_status", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(active,inactive,untracked)", options: ["optional()"] } },
            { position: { key: "start", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(5000)", "optional()"] } },
            { position: { key: "sort", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(id,cmc_rank)", options: ["optional()"] } },
            { position: { key: "symbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            {
              position: { key: "aux", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            }
          ],
          tests: [
            { _description: "Fetch active cryptocurrency ID map", listing_status: "active" },
            { _description: "Fetch limited ID map sorted by cmc_rank", sort: "cmc_rank", limit: 50 }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        },
        getMetadataV2: {
          requestMethod: "GET",
          description: "Get static metadata for one or more cryptocurrencies including logo, description, website URLs, and social links.",
          route: "/v2/cryptocurrency/info",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "symbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "skip_invalid", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } },
            { position: { key: "aux", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Fetch metadata for Bitcoin by ID", id: "1" },
            { _description: "Fetch metadata for Ethereum by slug", slug: "ethereum" },
            { _description: "Fetch metadata by symbol and allow skipping invalids", symbol: "BTC,ETH", skip_invalid: true }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        },
        getQuotesLatestV2: {
          requestMethod: "GET",
          description: "Get the latest market quote for one or more cryptocurrencies, supporting multiple conversions.",
          route: "/v2/cryptocurrency/quotes/latest",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "symbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "convert", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "convert_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "aux", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            {
              position: { key: "skip_invalid", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "boolean()", options: ["optional()"] }
            }
          ],
          tests: [
            { _description: "Fetch latest quote for Bitcoin by ID", id: "1" },
            { _description: "Fetch latest quote for Ethereum and Bitcoin by symbol", symbol: "BTC,ETH", convert: "USD" },
            { _description: "Fetch quote using slug and skip invalids", slug: "bitcoin,ethereum", skip_invalid: true }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        }
      },
      handlers: {
        modify: /* @__PURE__ */ __name(async ({ struct, payload, phase }) => {
          return { struct, payload };
        }, "modify")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/cmc-index.mjs
var cmc_index_exports = {};
__export(cmc_index_exports, {
  schema: () => schema28
});
var schema28;
var init_cmc_index = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/cmc-index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema28 = {
      namespace: "coinmarketcap",
      name: "CoinMarketCap100",
      description: "Retrieve historical and latest CoinMarketCap 100 Index data.",
      docs: ["https://coinmarketcap.com/api/documentation/v1/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://pro-api.coinmarketcap.com",
      requiredServerParams: ["CMC_API_KEY"],
      headers: {
        "X-CMC_PRO_API_KEY": "{{CMC_API_KEY}}"
      },
      routes: {
        getHistorical: {
          requestMethod: "GET",
          description: "Fetch a historical range of CoinMarketCap 100 Index values.",
          route: "/v3/index/cmc100-historical",
          parameters: [
            { position: { key: "time_start", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "time_end", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "count", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(5m,15m,daily)", options: [, "optional()"] } }
          ],
          tests: [
            { _description: "Fetch historical data without specifying time." }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        },
        getLatest: {
          requestMethod: "GET",
          description: "Fetch the latest CoinMarketCap 100 Index value.",
          route: "/v3/index/cmc100-latest",
          parameters: [],
          tests: [
            { _description: "Fetch latest data." }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        }
      },
      handlers: {
        modify: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modify")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/fear-and-greed.mjs
var fear_and_greed_exports = {};
__export(fear_and_greed_exports, {
  schema: () => schema29
});
var schema29;
var init_fear_and_greed = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/fear-and-greed.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema29 = {
      namespace: "coinmarketcap",
      name: "CMCCryptoFearAndGreed",
      description: "Retrieve historical and latest CMC Crypto Fear and Greed Index data.",
      docs: ["https://coinmarketcap.com/api/documentation/v1/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://pro-api.coinmarketcap.com",
      requiredServerParams: ["CMC_API_KEY"],
      headers: {
        "X-CMC_PRO_API_KEY": "{{CMC_API_KEY}}"
      },
      routes: {
        getFearAndGreedHistorical: {
          requestMethod: "GET",
          description: "Fetch historical CMC Crypto Fear and Greed values.",
          route: "/v3/fear-and-greed/historical",
          parameters: [
            { position: { key: "start", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(500)", "optional()"] } }
          ],
          tests: [
            { _description: "Fetch first 5 historical Fear and Greed values.", start: 1, limit: 5 },
            { _description: "Fetch historical values without pagination parameters." }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        },
        getFearAndGreedLatest: {
          requestMethod: "GET",
          description: "Fetch the latest CMC Crypto Fear and Greed value.",
          route: "/v3/fear-and-greed/latest",
          parameters: [],
          tests: [
            { _description: "Fetch latest Fear and Greed value." }
          ],
          modifiers: [
            { phase: "post", handlerName: "modify" }
          ]
        }
      },
      handlers: {
        modify: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modify")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/listings.mjs
var listings_exports = {};
__export(listings_exports, {
  schema: () => schema30
});
var schema30;
var init_listings = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coinmarketcap-com/listings.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema30 = {
      namespace: "coinmarketcap",
      name: "CoinMarketCapListingsLatest",
      description: "Returns a paginated list of all active cryptocurrencies with latest market data.",
      docs: ["https://coinmarketcap.com/api/documentation/v1/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://pro-api.coinmarketcap.com/v1",
      requiredServerParams: ["CMC_API_KEY"],
      headers: {
        "X-CMC_PRO_API_KEY": "{{CMC_API_KEY}}"
      },
      routes: {
        listingsLatest: {
          requestMethod: "GET",
          description: "Get latest listings of cryptocurrencies sorted and paginated.",
          route: "/cryptocurrency/listings/latest",
          parameters: [
            { position: { key: "start", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(5000)", "optional()"] } },
            { position: { key: "price_min", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "price_max", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "market_cap_min", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "market_cap_max", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "volume_24h_min", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "volume_24h_max", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "circulating_supply_min", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "circulating_supply_max", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "optional()"] } },
            { position: { key: "percent_change_24h_min", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(-100)", "optional()"] } },
            { position: { key: "percent_change_24h_max", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(-100)", "optional()"] } },
            { position: { key: "convert", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "convert_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sort", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(market_cap,market_cap_strict,name,symbol,date_added,price,circulating_supply,total_supply,max_supply,num_market_pairs,market_cap_by_total_supply_strict,volume_24h,percent_change_1h,percent_change_24h,percent_change_7d,volume_7d,volume_30d)", options: ["optional()"] } },
            { position: { key: "sort_dir", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(asc,desc)", options: ["optional()"] } },
            { position: { key: "cryptocurrency_type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(all,coins,tokens)", options: ["optional()"] } },
            { position: { key: "tag", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "aux", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Basic call without parameters" },
            { _description: "Paginated call with start=10 and limit=50", start: 10, limit: 50 },
            { _description: "Filter by market cap and sort descending by price", market_cap_min: 1e7, sort: "price", sort_dir: "desc" },
            { _description: "Filter using convert with USD", convert: "USD" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "standardHandler" },
            { phase: "post", handlerName: "defaultHandler" }
          ]
        }
      },
      handlers: {
        standardHandler: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "standardHandler"),
        defaultHandler: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "defaultHandler")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/coinstats/mixed.mjs
var mixed_exports = {};
__export(mixed_exports, {
  schema: () => schema31
});
var schema31;
var init_mixed = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/coinstats/mixed.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema31 = {
      namespace: "cryptodata",
      name: "Get Coins",
      description: "Retrieve comprehensive data about all cryptocurrencies including prices, market cap, volume, price changes, supply info, trading metrics, and metadata.",
      docs: ["https://your.api.documentation/coins"],
      tags: ["production", "price", "market", "data"],
      flowMCP: "1.2.0",
      root: "https://openapiv1.coinstats.app",
      requiredServerParams: [
        "COINSTATS_API_KEY"
      ],
      headers: {
        "X-API-KEY": "{{COINSTATS_API_KEY}}",
        "accept": "application/json"
      },
      routes: {
        getCoins: {
          requestMethod: "GET",
          description: "Get comprehensive data about all cryptocurrencies: Price, market cap, and volume. Price changes (1h, 24h, 7d). Supply information. Trading metrics. Social links and metadata.",
          route: "/coins",
          parameters: [
            { position: { key: "name", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } },
            { position: { key: "currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()", "default('USD')"] } },
            { position: { key: "symbol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "blockchains", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "includeRiskScore", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "categories", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sortBy", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sortDir", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(['asc','desc'])", options: ["optional()"] } },
            // Numeric filters
            ...[
              "marketCap",
              "fullyDilutedValuation",
              "volume",
              "priceChange1h",
              "priceChange1d",
              "priceChange7d",
              "availableSupply",
              "totalSupply",
              "rank",
              "price",
              "riskScore"
            ].flatMap((field) => [
              { position: { key: `${field}-greaterThan`, value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
              { position: { key: `${field}-equals`, value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
              { position: { key: `${field}-lessThan`, value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } }
            ])
          ],
          tests: [
            { _description: "Get top 20 coins in USD" },
            { _description: "Search coins by name", name: "bitcoin" },
            { _description: "Get memecoins with high market cap", categories: "memecoins", "marketCap-greaterThan": 1e9 },
            { _description: "Filter coins with price < $1", "price-lessThan": 1, currency: "USD" },
            { _description: "Sort by rank ascending", sortBy: "rank", sortDir: "asc" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getCoinById: {
          requestMethod: "GET",
          description: "Get detailed information about a specific cryptocurrency based on its unique identifier.",
          route: "/coins/:coinId",
          parameters: [
            { position: { key: "coinId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get Bitcoin details in USD", coinId: "bitcoin", currency: "USD" },
            { _description: "Get Ethereum details with default currency", coinId: "ethereum" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getCoinChartById: {
          requestMethod: "GET",
          description: "Get chart data for a specific cryptocurrency based on its unique identifier, specifying different time ranges.",
          route: "/coins/:coinId/charts",
          parameters: [
            { position: { key: "coinId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "period", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(['all','24h','1w','1m','3m','6m','1y'])", options: [] } }
          ],
          tests: [
            { _description: "Get Bitcoin chart for 1 month", coinId: "bitcoin", period: "1m" },
            { _description: "Get Ethereum chart for 24 hours", coinId: "ethereum", period: "24h" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getCoinAvgPrice: {
          requestMethod: "GET",
          description: "Get the historical average price for a specific cryptocurrency based on its unique identifier and a specific date.",
          route: "/coins/price/avg",
          parameters: [
            { position: { key: "coinId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "timestamp", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: [] } }
          ],
          tests: [
            { _description: "Get average price of Bitcoin at a specific timestamp", coinId: "bitcoin", timestamp: 1636315200 },
            { _description: "Get average price of Ethereum at a specific timestamp", coinId: "ethereum", timestamp: 1636315200 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getCoinExchangePrice: {
          requestMethod: "GET",
          description: "Get the historical price data for a specific cryptocurrency on a particular exchange.",
          route: "/coins/price/exchange",
          parameters: [
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "timestamp", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: [] } }
          ],
          tests: [
            { _description: "BTC to ETH price on Binance at timestamp", exchange: "Binance", from: "BTC", to: "ETH", timestamp: 1636315200 },
            { _description: "ETH to EUR price on Kraken at timestamp", exchange: "Kraken", from: "BTC", to: "USD", timestamp: 1636315200 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getTickerExchanges: {
          requestMethod: "GET",
          description: "Get a list of supported exchanges.",
          route: "/tickers/exchanges",
          parameters: [],
          tests: [
            { _description: "Retrieve all supported exchanges" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getTickerMarkets: {
          requestMethod: "GET",
          description: "Get a list of tickers for a specific cryptocurrency across different exchanges.",
          route: "/tickers/markets",
          parameters: [
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } },
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "fromCoin", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "toCoin", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "coinId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "onlyVerified", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get first page of verified tickers for Bitcoin", coinId: "bitcoin", onlyVerified: true },
            { _description: "List tickers for ETH to USD on Binance", fromCoin: "ETH", toCoin: "USD", exchange: "binance" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getBlockchains: {
          requestMethod: "GET",
          description: "Get a list of supported blockchains by CoinStats.",
          route: "/wallet/blockchains",
          parameters: [],
          tests: [
            { _description: "Retrieve supported blockchains list" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getWalletBalance: {
          requestMethod: "GET",
          description: "Get the balance data for a provided wallet address on a specific blockchain network.",
          route: "/wallet/balance",
          parameters: [
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "connectionId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get balance for Ethereum address using a known connectionId", address: "0x123456789abcdef123456789abcdef1234567890", connectionId: "ethereum" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getWalletBalances: {
          requestMethod: "GET",
          description: "Get the balance data for a provided wallet address on all CoinStats supported networks.",
          route: "/wallet/balances",
          parameters: [
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "networks", value: "all", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get all network balances for wallet", address: "0x123456789abcdef123456789abcdef1234567890" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        /*
                getWalletSyncStatus: {
                    requestMethod: "GET",
                    description: "Get the syncing status of the wallet with the blockchain network.",
                    route: "/wallet/status",
                    parameters: [
                        { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "connectionId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
                    ],
                    tests: [
                        { _description: "Check sync status of a wallet on Ethereum", address: "0x123456789abcdef123456789abcdef1234567890", connectionId: "ethereum" }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        /*
                getWalletTransactions: {
                    requestMethod: "GET",
                    description: "Get transaction data for a specific wallet. Ensure transactions are synced by calling PATCH /transactions first.",
                    route: "/wallet/transactions",
                    parameters: [
                        { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "connectionId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
                        { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } },
                        { position: { key: "from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()", "default('USD')"] } },
                        { position: { key: "types", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "txId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
                    ],
                    tests: [
                        { _description: "Get first page of Ethereum wallet transactions", address: "0x123456789abcdef123456789abcdef1234567890", connectionId: "ethereum" },
                        { _description: "Get deposit transactions with pagination", address: "0x123456789abcdef123456789abcdef1234567890", connectionId: "ethereum", types: "deposit", page: 2, limit: 10 }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        /*
                transactionsSync: {
                    requestMethod: "PATCH",
                    description: "Initiate the syncing process to update transaction data for a specific wallet.",
                    route: "/wallet/transactions",
                    parameters: [
                        { position: { key: "address", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "connectionId", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } }
                    ],
                    tests: [
                        { _description: "Initiate sync for Ethereum wallet", address: "0x123456789abcdef123456789abcdef1234567890", connectionId: "ethereum" }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        getExchanges: {
          requestMethod: "GET",
          description: "Get a list of supported exchange portfolio connections by CoinStats.",
          route: "/exchange/support",
          parameters: [],
          tests: [
            { _description: "Retrieve supported exchanges" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        /*
                getExchangeBalance: {
                    requestMethod: "POST",
                    description: "Get the balance data for a provided Exchange.",
                    route: "/exchange/balance",
                    parameters: [
                        { position: { key: "connectionFields", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "object()", options: [] } },
                        { position: { key: "connectionId", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } }
                    ],
                    tests: [
                        { _description: "Retrieve balance with API credentials", connectionId: "binance-main", connectionFields: { key: "abc123", secret: "xyz789" } }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        /*
                getExchangeSyncStatus: {
                    requestMethod: "GET",
                    description: "Get the syncing status of the exchange portfolio.",
                    route: "/exchange/status",
                    parameters: [
                        { position: { key: "portfolioId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
                    ],
                    tests: [
                        { _description: "Check sync status of Binance portfolio", portfolioId: "binance-portfolio-001" }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        /*
                getExchangeTransactions: {
                    requestMethod: "GET",
                    description: "Get transaction data for a specific exchange.",
                    route: "/exchange/transactions",
                    parameters: [
                        { position: { key: "portfolioId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
                        { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } },
                        { position: { key: "from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()", "default('USD')"] } },
                        { position: { key: "types", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
                    ],
                    tests: [
                        { _description: "Get exchange transactions for portfolio ID", portfolioId: "binance-portfolio-001" },
                        { _description: "Get deposit transactions in EUR from Jan 1 to Feb 1", portfolioId: "binance-portfolio-001", types: "deposit", currency: "EUR", from: "2024-01-01", to: "2024-02-01" }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        getFiatCurrencies: {
          requestMethod: "GET",
          description: "Get a list of fiat currencies supported by CoinStats.",
          route: "/fiats",
          parameters: [],
          tests: [
            { _description: "Retrieve list of supported fiat currencies" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getNewsSources: {
          requestMethod: "GET",
          description: "Get news sources.",
          route: "/news/sources",
          parameters: [],
          tests: [
            { _description: "Retrieve list of news sources" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getNews: {
          requestMethod: "GET",
          description: "Get news articles with pagination.",
          route: "/news",
          parameters: [
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } },
            { position: { key: "from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get first page of news articles" },
            { _description: "Get news between Jan 1 and Feb 1", from: "2024-01-01", to: "2024-02-01" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getNewsByType: {
          requestMethod: "GET",
          description: "Get news articles based on a type.",
          route: "/news/type/:type",
          parameters: [
            { position: { key: "type", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(['handpicked','trending','latest','bullish','bearish'])", options: [] } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } }
          ],
          tests: [
            { _description: "Get latest news articles", type: "latest" },
            { _description: "Get trending news, page 2", type: "trending", page: 2 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getNewsById: {
          requestMethod: "GET",
          description: "Get news by id.",
          route: "/news/:id",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get news article by ID", id: "ddbfd0792cfa149044c448eb9c681af4599f15156085980c3d85afe950fc6d8d" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getMarketCap: {
          requestMethod: "GET",
          description: "Get global market data.",
          route: "/markets",
          parameters: [],
          tests: [
            { _description: "Get global market cap and related data" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        /*
                getPortfolioCoins: {
                    requestMethod: "GET",
                    description: "Get a list of portfolio coins with P/L and other data displayed on CoinStats web.",
                    route: "/portfolio/coins",
                    parameters: [
                        { position: { key: "shareToken", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
                        { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } },
                        { position: { key: "includeRiskScore", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
                    ],
                    tests: [
                        { _description: "Get portfolio coins with default pagination" },
                        { _description: "Get shared portfolio with risk score", shareToken: "abc123", includeRiskScore: "true" }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        /*
                getPortfolioChart: {
                    requestMethod: "GET",
                    description: "Get portfolio performance chart data.",
                    route: "/portfolio/chart",
                    parameters: [
                        { position: { key: "shareToken", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
                    ],
                    tests: [
                        { _description: "Get 1-month chart for shared portfolio", shareToken: "abc123", type: "1m" },
                        { _description: "Get all-time chart for default portfolio", type: "all" }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        /*
                getPortfolioTransactions: {
                    requestMethod: "GET",
                    description: "Get a list of portfolio transactions.",
                    route: "/portfolio/transactions",
                    parameters: [
                        { position: { key: "shareToken", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(1)"] } },
                        { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "default(20)"] } },
                        { position: { key: "currency", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "coinId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
                    ],
                    tests: [
                        { _description: "Get portfolio transactions in USD", currency: "USD" },
                        { _description: "Get BTC transactions from shared portfolio", shareToken: "abc123", currency: "USD", coinId: "bitcoin" }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        /*
                addPortfolioTransaction: {
                    requestMethod: "POST",
                    description: "Add a transaction to a manual portfolio.",
                    route: "/portfolio/transaction",
                    parameters: [
                        { position: { key: "shareToken", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["optional()"] } },
                        { position: { key: "coinId", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "type", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "date", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } },
                        { position: { key: "amount", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: [] } },
                        { position: { key: "price", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: [] } },
                        { position: { key: "fee", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["optional()"] } },
                        { position: { key: "notes", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["optional()"] } }
                    ],
                    tests: [
                        {
                            _description: "Add BTC buy transaction to manual portfolio",
                            coinId: "bitcoin",
                            type: "buy",
                            date: "2024-01-01T00:00:00Z",
                            amount: 0.5,
                            price: 30000,
                            fee: 10,
                            notes: "Bought during dip"
                        }
                    ],
                    modifiers: [
                        { phase: 'pre', handlerName: 'preparePayload' },
                        { phase: 'post', handlerName: 'modifyResult' }
                    ]
                },
        */
        getCurrencies: {
          requestMethod: "GET",
          description: "Get a list of fiat currencies supported by CoinStats.",
          route: "/currencies",
          parameters: [],
          tests: [
            { _description: "Retrieve list of supported currencies" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "preparePayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        preparePayload: /* @__PURE__ */ __name(({ struct, payload }) => {
          payload["headers"]["X-API-KEY"] = payload["headers"]["X-API-KEY"] + "=";
          return { struct, payload };
        }, "preparePayload"),
        modifyResult: /* @__PURE__ */ __name(({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/context-7/getDocumentation.mjs
var getDocumentation_exports = {};
__export(getDocumentation_exports, {
  schema: () => schema32
});
var schema32;
var init_getDocumentation = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/context-7/getDocumentation.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema32 = {
      namespace: "context7",
      name: "Context7 Library Docs",
      description: "Accesses searchable documentation and examples for programming libraries using Context7.",
      docs: ["https://context7.com/docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://context7.com/api",
      requiredServerParams: [],
      headers: {
        "X-Context7-Source": "mcp-server"
      },
      routes: {
        searchLibraryId: {
          requestMethod: "GET",
          description: "Resolves a library name into a Context7-compatible library ID and returns top matches.",
          route: "/v1/search",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Resolve React library", query: "n8n" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifySearchLibraryResults" }
          ]
        },
        getLibraryDocs: {
          requestMethod: "GET",
          description: "Fetches documentation for a specific library using its Context7-compatible library ID.",
          route: "/v1/{{libraryId}}",
          parameters: [
            { position: { key: "libraryId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "tokens", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "topic", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
            // { position: { key: "folders", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [ "optional()"] } }
          ],
          tests: [
            { _description: "Get docs for nextjs", libraryId: "/n8n-io/n8n", tokens: 12e3 }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResults" }
          ]
        }
      },
      handlers: {
        modifySearchLibraryResults: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].results === void 0) {
            struct.status = false;
            struct.messages.push("No results found");
            return { struct, payload };
          }
          struct["data"] = struct["data"]["results"];
          return { struct, payload };
        }, "modifySearchLibraryResults"),
        modifyResults: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResults")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/cryptopanic/getNews.mjs
var getNews_exports = {};
__export(getNews_exports, {
  schema: () => schema33
});
var schema33;
var init_getNews = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/cryptopanic/getNews.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema33 = {
      namespace: "cryptopanic",
      name: "CryptoPanic",
      description: "Fetches cryptocurrency news headlines from CryptoPanic across different content types.",
      docs: ["https://cryptopanic.com/developers/api/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://cryptopanic.com/api/v1/posts",
      requiredServerParams: ["CRYPTOPANIC_API_KEY"],
      headers: {},
      routes: {
        getCryptoCryptopanicNews: {
          requestMethod: "GET",
          description: "Get a list of crypto news headlines from CryptoPanic.",
          route: "/",
          parameters: [
            { position: { key: "kind", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(news,media,analysis)", options: ["default(news)"] } },
            { position: { key: "num_pages", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(10)", "default(1)"] } },
            { position: { key: "auth_token", value: "{{CRYPTOPANIC_API_KEY}}", location: "query" } },
            { position: { key: "regions", value: "en", location: "query" } }
          ],
          tests: [
            { _description: "Get general crypto news headlines from 2 pages", kind: "news", num_pages: 2 }
          ],
          modifiers: [
            // { phase: "post", handlerName: "formatCryptoPanicNews" }
          ]
        }
      },
      handlers: {
        formatCryptoPanicNews: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.headlines = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatCryptoPanicNews")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/cryptowizards-net/analytics.mjs
var analytics_exports = {};
__export(analytics_exports, {
  schema: () => schema34
});
var schema34;
var init_analytics = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/cryptowizards-net/analytics.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema34 = {
      namespace: "cryptowizards",
      name: "CryptoWizards Analytics API",
      description: "Statistical finance endpoints for backtesting, correlation, cointegration, and copula analysis using real market data.",
      docs: ["https://api.cryptowizards.net", "https://github.com/cryptowizards"],
      tags: ["production", "analytics", "trading", "backtest"],
      flowMCP: "1.2.0",
      root: "https://api.cryptowizards.net",
      requiredServerParams: ["CRYPTOWIZARDS_API_KEY"],
      headers: { "X-api-key": "{{CRYPTOWIZARDS_API_KEY}}" },
      routes: {
        runBacktest: {
          requestMethod: "GET",
          description: "Runs a backtest using real market data from exchanges with comprehensive trading metrics.",
          route: "/v1beta/backtest",
          parameters: [
            { position: { key: "symbol_1", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "symbol_2", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Binance,BinanceUs,ByBit,Coinbase,Dydx,Forex,Stocks)", options: [] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Daily,Hourly,Min5)", options: [] } },
            { position: { key: "period", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(30)", "max(1000)"] } },
            { position: { key: "strategy", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Spread,ZScoreRoll,Copula)", options: [] } },
            { position: { key: "spread_type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Dynamic,Ou,Static)", options: ["default(Dynamic)", "optional()"] } },
            { position: { key: "roll_w", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(42)", "optional()"] } },
            { position: { key: "with_history", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["default(false)", "optional()"] } },
            { position: { key: "entry_level", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "exit_level", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "x_weighting", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(0.5)", "optional()"] } },
            { position: { key: "slippage_rate", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "commission_rate", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "stop_loss_rate", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "BTC/ETH pair trading backtest", symbol_1: "BTCUSDT", symbol_2: "ETHUSDT", exchange: "BinanceUs", interval: "Daily", period: 365, strategy: "ZScoreRoll", spread_type: "Static", with_history: false }
          ],
          modifiers: []
        },
        checkCointegration: {
          requestMethod: "GET",
          description: "Performs Engle-Granger cointegration test using real market data from exchanges.",
          route: "/v1beta/cointegration",
          parameters: [
            { position: { key: "symbol_1", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "symbol_2", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Binance,BinanceUs,ByBit,Coinbase,Dydx,Forex,Stocks)", options: [] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Daily,Hourly,Min5)", options: [] } },
            { position: { key: "period", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(30)", "max(1000)"] } },
            { position: { key: "spread_type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Dynamic,Ou,Static)", options: ["default(Dynamic)", "optional()"] } },
            { position: { key: "roll_w", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(42)", "optional()"] } },
            { position: { key: "with_history", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["default(false)", "optional()"] } }
          ],
          tests: [
            { _description: "BTC/ETH cointegration analysis", symbol_1: "BTCUSDT", symbol_2: "ETHUSDT", exchange: "Binance", interval: "Daily", period: 365, spread_type: "Static", with_history: false }
          ],
          modifiers: []
        },
        getCorrelations: {
          requestMethod: "GET",
          description: "Computes Pearson, Spearman and Kendall correlations using real market data from exchanges.",
          route: "/v1beta/correlations",
          parameters: [
            { position: { key: "symbol_1", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "symbol_2", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Binance,BinanceUs,ByBit,Coinbase,Dydx,Forex,Stocks)", options: [] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Daily,Hourly,Min5)", options: [] } },
            { position: { key: "period", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(30)", "max(1000)"] } }
          ],
          tests: [
            { _description: "BTC/ETH correlation analysis", symbol_1: "BTCUSDT", symbol_2: "ETHUSDT", exchange: "Binance", interval: "Daily", period: 365 }
          ],
          modifiers: []
        },
        analyzeCopula: {
          requestMethod: "GET",
          description: "Computes copula-based dependency modeling using real market data from exchanges.",
          route: "/v1beta/copula",
          parameters: [
            { position: { key: "symbol_1", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "symbol_2", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Binance,BinanceUs,ByBit,Coinbase,Dydx,Forex,Stocks)", options: [] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Daily,Hourly,Min5)", options: [] } },
            { position: { key: "period", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(30)", "max(1000)"] } }
          ],
          tests: [
            { _description: "BTC/ETH copula dependency analysis", symbol_1: "BTCUSDT", symbol_2: "ETHUSDT", exchange: "Binance", interval: "Daily", period: 365 }
          ],
          modifiers: []
        },
        analyzeSpread: {
          requestMethod: "GET",
          description: "Calculates spread metrics using real market data with Dynamic, OU, or Static methods.",
          route: "/v1beta/spread",
          parameters: [
            { position: { key: "symbol_1", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "symbol_2", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Binance,BinanceUs,ByBit,Coinbase,Dydx,Forex,Stocks)", options: [] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Daily,Hourly,Min5)", options: [] } },
            { position: { key: "period", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(30)", "max(1000)"] } },
            { position: { key: "spread_type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Dynamic,Ou,Static)", options: ["default(Dynamic)", "optional()"] } },
            { position: { key: "roll_w", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(42)", "optional()"] } },
            { position: { key: "with_history", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["default(false)", "optional()"] } }
          ],
          tests: [
            { _description: "BTC/ETH spread analysis", symbol_1: "BTCUSDT", symbol_2: "ETHUSDT", exchange: "Binance", interval: "Daily", period: 365, spread_type: "Static", with_history: false }
          ],
          modifiers: []
        },
        analyzeZScores: {
          requestMethod: "GET",
          description: "Computes rolling z-scores using real market data to identify trading opportunities.",
          route: "/v1beta/zscores",
          parameters: [
            { position: { key: "symbol_1", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "symbol_2", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "exchange", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Binance,BinanceUs,ByBit,Coinbase,Dydx,Forex,Stocks)", options: [] } },
            { position: { key: "interval", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Daily,Hourly,Min5)", options: [] } },
            { position: { key: "period", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(30)", "max(1000)"] } },
            { position: { key: "spread_type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Dynamic,Ou,Static)", options: ["default(Dynamic)", "optional()"] } },
            { position: { key: "roll_w", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["default(42)", "optional()"] } },
            { position: { key: "with_history", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["default(false)", "optional()"] } }
          ],
          tests: [
            { _description: "BTC/ETH z-score analysis", symbol_1: "BTCUSDT", symbol_2: "ETHUSDT", exchange: "Binance", interval: "Daily", period: 365, spread_type: "Static", with_history: false }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/defilama/api.mjs
var api_exports = {};
__export(api_exports, {
  schema: () => schema35
});
var schema35;
var init_api = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/defilama/api.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema35 = {
      namespace: "defillama",
      name: "DeFi Llama MCP",
      description: "Provides access to DeFi protocol and liquidity data from DeFi Llama",
      docs: ["https://docs.llama.fi"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.llama.fi",
      requiredServerParams: [],
      headers: {},
      routes: {
        getProtocols: {
          requestMethod: "GET",
          description: "Retrieve a list of all DeFi protocols from DeFi Llama (first 20)",
          route: "/protocols",
          parameters: [],
          tests: [
            { _description: "Test fetching protocols" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getProtocolTvl: {
          requestMethod: "GET",
          description: "Get TVL data for a specific DeFi protocol",
          route: "/protocol/:protocol",
          parameters: [
            { position: { key: "protocol", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test Aave protocol TVL", protocol: "aave" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getChainTvl: {
          requestMethod: "GET",
          description: "Retrieve historical TVL data for a specific blockchain",
          route: "/v2/historicalChainTvl/:chain",
          parameters: [
            { position: { key: "chain", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Ethereum chain TVL", chain: "ethereum" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/defilama/coins.mjs
var coins_exports2 = {};
__export(coins_exports2, {
  schema: () => schema36
});
var sources, schema36;
var init_coins2 = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/defilama/coins.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    sources = [
      "coingecko"
      /*"cmc", "defillama"*/
    ];
    schema36 = {
      namespace: "defillama",
      name: "DeFi Llama Token Prices",
      description: "Provides current token price data using DeFi Llama",
      docs: ["https://docs.llama.fi"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://coins.llama.fi",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTokenPrices: {
          requestMethod: "GET",
          description: "Get current price information for a specific token",
          route: "/prices/current/_tokenName_",
          parameters: [
            { position: { key: "source", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: `enum(${sources.join(",")})`, options: [] } },
            { position: { key: "token", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test price for Ethereum via CoinGecko ID", source: "coingecko", token: "ethereum" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "addTokenName" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        addTokenName: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { source, token } = userParams;
          const tokenName = `${source}:${token}`;
          payload["url"] = payload["url"].replace("_tokenName_", tokenName);
          return { struct, payload };
        }, "addTokenName"),
        modifyResult: /* @__PURE__ */ __name(({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/defilama/yields.mjs
var yields_exports = {};
__export(yields_exports, {
  schema: () => schema37
});
var schema37;
var init_yields = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/defilama/yields.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema37 = {
      namespace: "defillama",
      name: "DeFi Llama Liquidity Pools",
      description: "Provides access to current DeFi Llama liquidity pool data and TVL charts",
      docs: ["https://docs.llama.fi"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://yields.llama.fi",
      requiredServerParams: [],
      headers: {},
      routes: {
        getPools: {
          requestMethod: "GET",
          description: "Retrieve a list of all liquidity pools from DeFi Llama (first 30)",
          route: "/pools",
          parameters: [],
          tests: [
            { _description: "Test fetching pools" }
          ],
          modifiers: []
        },
        getPoolTvl: {
          requestMethod: "GET",
          description: "Get detailed information about a specific liquidity pool by its ID",
          route: "/chart/{{pool}}",
          parameters: [
            { position: { key: "pool", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test pool chart data", pool: "747c1d2a-c668-4682-b9f9-296708a3dd90" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(({ struct, payload }) => {
          if (struct["data"]["status"] === "success") {
            struct["data"] = struct["data"]["data"];
          } else {
            struct["status"] = false;
            struct["messages"].push(`Fetch Error`);
          }
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/boosted.mjs
var boosted_exports = {};
__export(boosted_exports, {
  schema: () => schema38
});
var schema38;
var init_boosted = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/boosted.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema38 = {
      namespace: "dexscreener",
      name: "dexscreener-boosted",
      description: "DexScreener API \u2013 Boosted token insights",
      docs: ["https://docs.dexscreener.com/api/reference"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.dexscreener.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        getLatestBoostedTokens: {
          requestMethod: "GET",
          description: "Get the latest boosted tokens",
          route: "/token-boosts/latest/v1",
          parameters: [],
          tests: [{ _description: "Fetch latest boosted tokens" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        },
        getMostActiveBoostedTokens: {
          requestMethod: "GET",
          description: "Get tokens with most active boosts",
          route: "/token-boosts/top/v1",
          parameters: [],
          tests: [{ _description: "Fetch most active boosted tokens" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        }
      },
      handlers: {
        normalizeResponse: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "normalizeResponse")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/pairs.mjs
var pairs_exports = {};
__export(pairs_exports, {
  schema: () => schema39
});
var schema39;
var init_pairs = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/pairs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema39 = {
      namespace: "dexscreener",
      name: "Dexscreener Pairs",
      description: "DexScreener API \u2013 Pair data and token orders by chain",
      docs: ["https://docs.dexscreener.com/api/reference"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.dexscreener.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        getPairByChainAndAddress: {
          requestMethod: "GET",
          description: "Get pair by chain and pair address",
          route: "/latest/dex/pairs/:chainId/:pairAddress",
          parameters: [
            { position: { key: "chainId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "pairAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [{ _description: "Get pair data", chainId: "bsc", pairAddress: "0x0FCeAc6f12dF0c11f4534534fc4ae68751B5862D" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        },
        checkTokenOrders: {
          requestMethod: "GET",
          description: "Check token orders by chain and token address",
          route: "/orders/v1/:chainId/:tokenAddress",
          parameters: [
            { position: { key: "chainId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [{ _description: "Check token orders", chainId: "solana", tokenAddress: "5i3WMss2Ldnkw3CnrBoGrkPiVwpAKuGoHULPdbaxpump" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        }
      },
      handlers: {
        normalizeResponse: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "normalizeResponse")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/tokenInfo.mjs
var tokenInfo_exports = {};
__export(tokenInfo_exports, {
  schema: () => schema40
});
var schema40;
var init_tokenInfo = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/tokenInfo.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema40 = {
      namespace: "dexscreener",
      name: "dexscreener-tokeninfo",
      description: "DexScreener API \u2013 Token search and profile data",
      docs: ["https://docs.dexscreener.com/api/reference"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.dexscreener.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        getLatestTokenProfiles: {
          requestMethod: "GET",
          description: "Get the latest token profiles",
          route: "/token-profiles/latest/v1",
          parameters: [],
          tests: [{ _description: "Fetch latest token profiles" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        },
        searchPairs: {
          requestMethod: "GET",
          description: "Search pairs by query string",
          route: "/latest/dex/search",
          parameters: [
            { position: { key: "q", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [{ _description: "Search pairs by query", q: "SOL/USDC" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        },
        getPairsByToken: {
          requestMethod: "GET",
          description: "Get pairs by token address",
          route: "/tokens/v1/:chainId/:tokenAddress",
          parameters: [
            { position: { key: "chainId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [{ _description: "Get token pairs", chainId: "ethereum", tokenAddress: "0x6982508145454Ce325dDbE47a25d4ec3d2311933" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        },
        getTokenPools: {
          requestMethod: "GET",
          description: "Get token pools by chain and address",
          route: "/token-pairs/v1/:chainId/:tokenAddress",
          parameters: [
            { position: { key: "chainId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [{ _description: "Get token pools", chainId: "bsc", tokenAddress: "0xD279E8f1fE8F893e4b1CB18fAAeb4fc2a0d14444" }],
          modifiers: [{ phase: "post", handlerName: "normalizeResponse" }]
        }
      },
      handlers: {
        normalizeResponse: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "normalizeResponse")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/tokenpairs.mjs
var tokenpairs_exports = {};
__export(tokenpairs_exports, {
  schema: () => schema41
});
var schema41;
var init_tokenpairs = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/dexscreener-com/tokenpairs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema41 = {
      namespace: "dexscreener",
      name: "DexScreener Token Pairs API",
      description: "Access token pair data, price information, and trading metrics from DexScreener across multiple DEX platforms",
      docs: ["https://docs.dexscreener.com/api/reference"],
      tags: ["dex", "trading", "pairs"],
      flowMCP: "1.2.0",
      root: "https://api.dexscreener.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTokenPairs: {
          requestMethod: "GET",
          description: "Get token pairs by token address on specific blockchain",
          route: "/latest/dex/tokens/:tokenAddress",
          parameters: [
            {
              position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["min(1)"] }
            }
          ],
          tests: [
            { _description: "Get pairs for WETH token", tokenAddress: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2" },
            { _description: "Get pairs for USDC token", tokenAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" }
          ],
          modifiers: []
        },
        searchPairs: {
          requestMethod: "GET",
          description: "Search for token pairs by query string (token name, symbol, or address)",
          route: "/latest/dex/search",
          parameters: [
            {
              position: { key: "q", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["min(2)"] }
            }
          ],
          tests: [
            { _description: "Search for WETH pairs", q: "WETH" },
            { _description: "Search for specific token address", q: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2" },
            { _description: "Search for USDC pairs", q: "USDC" }
          ],
          modifiers: []
        },
        getLatestPairs: {
          requestMethod: "GET",
          description: "Get specific token pair by chain and pair address",
          route: "/latest/dex/pairs/:chainId/:pairId",
          parameters: [
            {
              position: { key: "chainId", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "enum(ethereum,bsc,polygon,avalanche,fantom,cronos,arbitrum,optimism,base,solana)", options: [] }
            },
            {
              position: { key: "pairId", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["min(1)"] }
            }
          ],
          tests: [
            { _description: "Get specific pair on Ethereum", chainId: "ethereum", pairId: "0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640" }
          ],
          modifiers: []
        },
        getPairsByChain: {
          requestMethod: "GET",
          description: "Get trending token pairs by chain",
          route: "/orders/v1/:chainId/:sortBy",
          parameters: [
            {
              position: { key: "chainId", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "enum(ethereum,bsc,polygon,avalanche,fantom,cronos,arbitrum,optimism,base,solana)", options: [] }
            },
            {
              position: { key: "sortBy", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "enum(volume,gainers,losers)", options: ["default(volume)"] }
            }
          ],
          tests: [
            { _description: "Get trending pairs on Ethereum by volume", chainId: "ethereum", sortBy: "volume" },
            { _description: "Get top gainers on BSC", chainId: "bsc", sortBy: "gainers" },
            { _description: "Get trending pairs on Polygon", chainId: "polygon", sortBy: "volume" }
          ],
          modifiers: []
        },
        getSpecificPair: {
          requestMethod: "GET",
          description: "Get detailed information about a specific token pair by chain and address",
          route: "/latest/dex/pairs/:chainId/:pairAddress",
          parameters: [
            {
              position: { key: "chainId", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "enum(ethereum,bsc,polygon,avalanche,fantom,cronos,arbitrum,optimism,base,solana)", options: [] }
            },
            {
              position: { key: "pairAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["min(1)"] }
            }
          ],
          tests: [
            { _description: "Get specific pair on Ethereum", chainId: "ethereum", pairAddress: "0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640" },
            { _description: "Get specific pair on BSC", chainId: "bsc", pairAddress: "0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/dune-analytics/farcaster.mjs
var farcaster_exports = {};
__export(farcaster_exports, {
  schema: () => schema42
});
var schema42;
var init_farcaster = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/dune-analytics/farcaster.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema42 = {
      namespace: "duneAnalytics",
      name: "FarcasterTrends",
      description: "Fetches trending memecoins, channels, and users from Farcaster via Dune Analytics.",
      docs: ["https://docs.dune.com/api-reference/overview/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.dune.com/api/v1/farcaster/trends",
      requiredServerParams: ["DUNE_API_KEY"],
      headers: {
        "X-Dune-Api-Key": "{{DUNE_API_KEY}}"
      },
      routes: {
        farcasterGetTrendingMemecoins: {
          requestMethod: "GET",
          description: "Get trending Farcaster memecoins from Dune Analytics.",
          route: "/memecoins",
          parameters: [
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] }
            },
            {
              position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            },
            {
              position: { key: "filters", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            },
            {
              position: { key: "columns", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            }
          ],
          tests: [
            { _description: "Fetch top 5 memecoins", limit: 5 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatMemecoinList" }
          ]
        },
        farcasterGetTrendingChannels: {
          requestMethod: "GET",
          description: "Get trending Farcaster channels from Dune Analytics.",
          route: "/channels",
          parameters: [
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] }
            },
            {
              position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            },
            {
              position: { key: "filters", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            },
            {
              position: { key: "columns", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            }
          ],
          tests: [
            { _description: "Fetch top 3 channels", limit: 3 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatChannelList" }
          ]
        },
        farcasterGetTrendingUsers: {
          requestMethod: "GET",
          description: "Get trending Farcaster users who casted in the last 14 days.",
          route: "/users",
          parameters: [
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] }
            },
            {
              position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            },
            {
              position: { key: "filters", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            },
            {
              position: { key: "columns", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: ["optional()"] }
            }
          ],
          tests: [
            { _description: "Fetch top 5 users", limit: 5 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatUserList" }
          ]
        }
      },
      handlers: {
        formatMemecoinList: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.memecoins = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatMemecoinList"),
        formatChannelList: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.channels = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatChannelList"),
        formatUserList: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.users = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatUserList")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/dune-analytics/getResults.mjs
var getResults_exports = {};
__export(getResults_exports, {
  schema: () => schema43
});
var schema43;
var init_getResults = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/dune-analytics/getResults.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema43 = {
      namespace: "duneAnalytics",
      name: "DuneAnalytics",
      description: "Interface with Dune Analytics to execute and retrieve query results.",
      docs: ["https://docs.dune.com/api-reference/overview/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.dune.com/api/v1",
      requiredServerParams: ["DUNE_API_KEY"],
      headers: {
        "X-Dune-API-Key": "{{DUNE_API_KEY}}"
      },
      routes: {
        getLatestResult: {
          requestMethod: "GET",
          description: "Fetch latest result for a Dune query ID (returns CSV string).",
          route: "/query/:query_id/results",
          parameters: [
            {
              position: { key: "query_id", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "number()", options: [] }
            }
          ],
          tests: [
            { _description: "Retrieve latest result from query ID", query_id: 4032586 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatCSVResult" }
          ]
        }
        /*
              runQuery: {
                requestMethod: "POST",
                description: "Execute a Dune query by ID and return results as CSV string.",
                route: "/query/execute/:query_id",
                parameters: [
                  {
                    position: { key: "query_id", value: "{{USER_PARAM}}", location: "insert" },
                    z: { primitive: "number()", options: [] }
                  }
                ],
                tests: [
                  { _description: "Run query by ID and return results", query_id: 4856405 }
                ],
                modifiers: [
                  { phase: "post", handlerName: "formatCSVResult" }
                ]
              }
        */
      },
      handlers: {
        formatCSVResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.csv = payload?.content?.[0]?.text || "";
          return { struct, payload };
        }, "formatCSVResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/dune-analytics/trendingContracts.mjs
var trendingContracts_exports = {};
__export(trendingContracts_exports, {
  schema: () => schema44
});
var schema44;
var init_trendingContracts = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/dune-analytics/trendingContracts.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema44 = {
      namespace: "duneAnalytics",
      name: "DexAndContracts",
      description: "Provides insights into DEX trading pairs, trending contracts, and market share across chains via Dune Analytics.",
      docs: ["https://docs.dune.com/api-reference/overview/introduction"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.dune.com/api/v1",
      requiredServerParams: ["DUNE_API_KEY"],
      headers: {
        "X-Dune-Api-Key": "{{DUNE_API_KEY}}"
      },
      routes: {
        getDexPairStats: {
          requestMethod: "GET",
          description: "Get DEX pair statistics for a given blockchain.",
          route: "/dex/pairs/:chain",
          parameters: [
            { position: { key: "chain", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(arbitrum,base,bnb,celo,ethereum,fantom,gnosis,optimism,polygon,scroll,zk_sync,solana)", options: [] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] } },
            { position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "filters", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "columns", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get DEX pairs for optimism", chain: "optimism", limit: 5 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatDexPairsHandler" }
          ]
        },
        getTrendingContracts: {
          requestMethod: "GET",
          description: "Get trending contracts deployed on EVM chains based on the last 30 days.",
          route: "/trends/evm/contracts/:chain",
          parameters: [
            { position: { key: "chain", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(arbitrum,base,bnb,celo,ethereum,fantom,gnosis,optimism,polygon,scroll,zk_sync,solana)", options: [] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] } },
            { position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "filters", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "columns", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get trending contracts on base", chain: "base", limit: 3 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatContractsHandler" }
          ]
        },
        getMarketShare: {
          requestMethod: "GET",
          description: "Get DEX or NFT market share on a specific chain.",
          route: "/marketshare/:market/:chain",
          parameters: [
            { position: { key: "market", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(dex,nft)", options: [] } },
            { position: { key: "chain", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] } },
            { position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "filters", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "columns", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get DEX market share for polygon", market: "dex", chain: "polygon", limit: 5 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatMarketShareHandler" }
          ]
        }
      },
      handlers: {
        formatDexPairsHandler: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.pairs = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatDexPairsHandler"),
        formatContractsHandler: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.contracts = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatContractsHandler"),
        formatMarketShareHandler: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.market = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatMarketShareHandler")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/epo-org/patent-search.mjs
var patent_search_exports = {};
__export(patent_search_exports, {
  schema: () => schema45
});
var schema45;
var init_patent_search = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/epo-org/patent-search.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema45 = {
      namespace: "epo",
      name: "European Patent Office RSS Search",
      description: "Search European patents via RSS feeds from the European Patent Office register",
      docs: ["https://register.epo.org/", "https://www.epo.org/searching-for-patents/"],
      tags: ["patents", "research", "search"],
      flowMCP: "1.2.0",
      root: "https://register.epo.org",
      requiredServerParams: [],
      headers: {},
      routes: {
        searchPatents: {
          requestMethod: "GET",
          description: "Search for patents using custom query and language",
          route: "/rssSearch",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "lng", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(de,en,fr)", options: ["default(en)", "optional()"] } }
          ],
          tests: [
            { _description: "Search for AI patents in English", query: "txt = artificial and txt = intelligence", lng: "en" },
            { _description: "Search for blockchain patents in German", query: "txt = blockchain", lng: "de" },
            { _description: "Search for renewable energy patents", query: "txt = renewable and txt = energy", lng: "en" }
          ],
          modifiers: [{ phase: "execute", handlerName: "parsePatentRSS" }]
        },
        searchByTechnology: {
          requestMethod: "GET",
          description: "Search patents by predefined technology areas",
          route: "/rssSearch",
          parameters: [
            { position: { key: "technology", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(artificial intelligence,machine learning,blockchain,renewable energy,biotechnology,nanotechnology,quantum computing,robotics,autonomous vehicles,5G)", options: [] } },
            { position: { key: "lng", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(de,en,fr)", options: ["default(en)", "optional()"] } }
          ],
          tests: [
            { _description: "Search AI technology patents", technology: "artificial intelligence", lng: "en" },
            { _description: "Search blockchain technology patents", technology: "blockchain", lng: "en" },
            { _description: "Search quantum computing patents in German", technology: "quantum computing", lng: "de" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "formatTechnologyQuery" },
            { phase: "execute", handlerName: "parsePatentRSS" }
          ]
        },
        searchByKeywords: {
          requestMethod: "GET",
          description: "Search patents using multiple keywords with AND/OR operators",
          route: "/rssSearch",
          parameters: [
            { position: { key: "keywords", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "array()", options: ["min(1)"] } },
            { position: { key: "operator", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(AND,OR)", options: ["default(AND)", "optional()"] } },
            { position: { key: "field", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(txt,ti,ab,in)", options: ["default(txt)", "optional()"] } },
            { position: { key: "lng", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(de,en,fr)", options: ["default(en)", "optional()"] } }
          ],
          tests: [
            { _description: "Search patents with multiple keywords", keywords: ["neural", "network", "deep"], operator: "AND", field: "txt", lng: "en" },
            { _description: "Search by title keywords", keywords: ["solar", "panel"], operator: "AND", field: "ti", lng: "en" },
            { _description: "Search abstract with OR operator", keywords: ["battery", "fuel cell"], operator: "OR", field: "ab", lng: "de" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "formatKeywordQuery" },
            { phase: "execute", handlerName: "parsePatentRSS" }
          ]
        },
        searchByDate: {
          requestMethod: "GET",
          description: "Search patents within specific date ranges",
          route: "/rssSearch",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "from_date", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "to_date", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "lng", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(de,en,fr)", options: ["default(en)", "optional()"] } }
          ],
          tests: [
            { _description: "Search recent AI patents", query: "txt = artificial intelligence", from_date: "2023-01-01", to_date: "2024-12-31", lng: "en" },
            { _description: "Search historical blockchain patents", query: "txt = blockchain", from_date: "2008-01-01", to_date: "2020-12-31", lng: "en" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "formatDateQuery" },
            { phase: "execute", handlerName: "parsePatentRSS" }
          ]
        }
      },
      handlers: {
        formatTechnologyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { technology } = userParams;
          const formattedQuery = `txt = ${technology.replace(/\s+/g, " and txt = ")}`;
          payload.url = payload.url.replace(/query=[^&]*/, `query=${encodeURIComponent(formattedQuery)}`);
          return { struct, payload };
        }, "formatTechnologyQuery"),
        formatKeywordQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { keywords, operator = "AND", field = "txt" } = userParams;
          const connector = operator === "AND" ? " and " : " or ";
          const formattedQuery = keywords.map((keyword) => `${field} = ${keyword}`).join(connector);
          payload.url = payload.url.replace(/keywords=[^&]*/, `query=${encodeURIComponent(formattedQuery)}`);
          return { struct, payload };
        }, "formatKeywordQuery"),
        formatDateQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { query, from_date, to_date } = userParams;
          let formattedQuery = query;
          if (from_date) {
            formattedQuery += ` and pd >= ${from_date}`;
          }
          if (to_date) {
            formattedQuery += ` and pd <= ${to_date}`;
          }
          payload.url = payload.url.replace(/query=[^&]*/, `query=${encodeURIComponent(formattedQuery)}`);
          return { struct, payload };
        }, "formatDateQuery"),
        parsePatentRSS: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          try {
            const response = await fetch(payload.url);
            if (!response.ok) {
              struct.status = false;
              struct.messages.push(`HTTP ${response.status}: ${response.statusText}`);
              return { struct, payload };
            }
            const xmlText = await response.text();
            const itemRegex = /<item>(.*?)<\/item>/gs;
            const titleRegex = /<title><!\[CDATA\[(.*?)\]\]><\/title>/s;
            const linkRegex = /<link>(.*?)<\/link>/s;
            const pubDateRegex = /<pubDate>(.*?)<\/pubDate>/s;
            const descriptionRegex = /<description><!\[CDATA\[(.*?)\]\]><\/description>/s;
            const guidRegex = /<guid.*?>(.*?)<\/guid>/s;
            const patents = [];
            let match;
            while ((match = itemRegex.exec(xmlText)) !== null) {
              const itemXml = match[1];
              const titleMatch = titleRegex.exec(itemXml);
              const linkMatch = linkRegex.exec(itemXml);
              const pubDateMatch = pubDateRegex.exec(itemXml);
              const descriptionMatch = descriptionRegex.exec(itemXml);
              const guidMatch = guidRegex.exec(itemXml);
              const patent = {
                title: titleMatch ? titleMatch[1] : null,
                link: linkMatch ? linkMatch[1] : null,
                pubDate: pubDateMatch ? pubDateMatch[1] : null,
                description: descriptionMatch ? descriptionMatch[1].replace(/<[^>]*>/g, "").substring(0, 300) + "..." : null,
                patentId: guidMatch ? guidMatch[1].split("/").pop() : null
              };
              patents.push(patent);
            }
            struct.data = {
              source: "European Patent Office",
              feedUrl: payload.url,
              patentCount: patents.length,
              patents
            };
          } catch (error42) {
            struct.status = false;
            struct.messages.push(`Error parsing patent RSS feed: ${error42.message}`);
          }
          return { struct, payload };
        }, "parsePatentRSS")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/erc725/profileJump.mjs
var profileJump_exports = {};
__export(profileJump_exports, {
  schema: () => schema46
});
var schema46;
var init_profileJump = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/erc725/profileJump.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema46 = {
      namespace: "profilejump",
      name: "ProfileJump",
      description: "Schema for interacting with the ProfileJump API",
      docs: ["https://profilejump.com"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.profilejump.com",
      requiredServerParams: [],
      headers: {
        Referer: "https://profilejump.com/"
      },
      routes: {
        prices: {
          requestMethod: "GET",
          description: "Fetch price data",
          route: "/api/prices",
          parameters: [],
          tests: [{ _description: "Fetch default prices" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        hotProfiles: {
          requestMethod: "GET",
          description: "Fetch hot profiles",
          route: "/api/profiles/hot-profiles",
          parameters: [],
          tests: [{ _description: "Fetch trending profiles" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        tokensList: {
          requestMethod: "GET",
          description: "Fetch list of tokens with pagination",
          route: "/api/tokens-list",
          parameters: [
            { position: { key: "limit", value: "100", location: "query" } },
            { position: { key: "offset", value: "0", location: "query" } }
          ],
          tests: [{ _description: "Fetch tokens list" }],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        profilesList: {
          requestMethod: "GET",
          description: "Fetch list of profiles filtered by view",
          route: "/api/profiles-list",
          parameters: [
            { position: { key: "limit", value: "100", location: "query" } },
            { position: { key: "offset", value: "0", location: "query" } },
            { position: { key: "view", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(social,wealth)", options: [] } }
          ],
          tests: [
            { _description: "Fetch social view", view: "social" },
            { _description: "Fetch wealth view", view: "wealth" }
          ],
          modifiers: [{ phase: "post", handlerName: "modifyResult" }]
        },
        profileByAddress: {
          requestMethod: "GET",
          description: "Fetch profile details by wallet address",
          route: "/api/profiles/:address",
          parameters: [
            { position: { key: "address", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$)"] } }
          ],
          tests: [
            { _description: "Valid address profile fetch", address: "0x02e2ae57Ed6058e41F19C402173939d99ecC05C3" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/etherscan/getContractEthereum.mjs
var getContractEthereum_exports = {};
__export(getContractEthereum_exports, {
  schema: () => schema47
});
var schema47;
var init_getContractEthereum = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/etherscan/getContractEthereum.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema47 = {
      namespace: "etherscan",
      name: "Etherscan",
      description: "Etherscan API",
      docs: ["https://docs.etherscan.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.etherscan.io",
      requiredServerParams: ["ETHERSCAN_API_KEY"],
      headers: {},
      routes: {
        getContractABI: {
          requestMethod: "GET",
          description: "Returns the Contract ABI of a verified smart contract.",
          route: "/api",
          parameters: [
            { position: { key: "module", value: "contract", location: "body" } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getabi", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(42)", "max(42)"] } },
            { position: { key: "apikey", value: "{{ETHERSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Basic test for getContractABI", address: "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getContractSourceCode: {
          requestMethod: "GET",
          description: "Returns the Solidity source code of a verified smart contract.",
          route: "/api",
          parameters: [
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getsourcecode", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(42)", "max(42)"] } },
            { position: { key: "apikey", value: "{{ETHERSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Basic test for getContractSourceCode", address: "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].status !== "1") {
            struct["status"] = false;
            struct["messages"].push(struct.data.message);
            return { struct, payload };
          }
          struct["data"] = struct["data"].result;
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/etherscan/getContractMultichain.mjs
var getContractMultichain_exports = {};
__export(getContractMultichain_exports, {
  schema: () => schema48
});
var chainsByAlias, schema48;
var init_getContractMultichain = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/etherscan/getContractMultichain.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    chainsByAlias = {
      ETHEREUM_MAINNET: { "chainId": 1, "name": "Ethereum Mainnet" },
      SEPOLIA_TESTNET: { "chainId": 11155111, "name": "Sepolia Testnet" },
      HOLESKY_TESTNET: { "chainId": 17e3, "name": "Holesky Testnet" },
      ABSTRACT_MAINNET: { "chainId": 2741, "name": "Abstract Mainnet" },
      ABSTRACT_SEPOLIA_TESTNET: { "chainId": 11124, "name": "Abstract Sepolia Testnet" },
      APECHAIN_CURTIS_TESTNET: { "chainId": 33111, "name": "ApeChain Curtis Testnet" },
      APECHAIN_MAINNET: { "chainId": 33139, "name": "ApeChain Mainnet" },
      ARBITRUM_NOVA_MAINNET: { "chainId": 42170, "name": "Arbitrum Nova Mainnet" },
      ARBITRUM_ONE_MAINNET: { "chainId": 42161, "name": "Arbitrum One Mainnet" },
      ARBITRUM_SEPOLIA_TESTNET: { "chainId": 421614, "name": "Arbitrum Sepolia Testnet" },
      AVALANCHE_CCHAIN: { "chainId": 43114, "name": "Avalanche C-Chain" },
      AVALANCHE_FUJI_TESTNET: { "chainId": 43113, "name": "Avalanche Fuji Testnet" },
      BASE_MAINNET: { "chainId": 8453, "name": "Base Mainnet" },
      BASE_SEPOLIA_TESTNET: { "chainId": 84532, "name": "Base Sepolia Testnet" },
      BERACHAIN_MAINNET: { "chainId": 80094, "name": "Berachain Mainnet" },
      BERACHAIN_BEPOLIA_TESTNET: { "chainId": 80069, "name": "Berachain Bepolia Testnet" },
      BITTORRENT_MAINNET: { "chainId": 199, "name": "BitTorrent Chain Mainnet" },
      BITTORRENT_TESTNET: { "chainId": 1028, "name": "BitTorrent Chain Testnet" },
      BLAST_MAINNET: { "chainId": 81457, "name": "Blast Mainnet" },
      BLAST_SEPOLIA_TESTNET: { "chainId": 168587773, "name": "Blast Sepolia Testnet" },
      BINANCE_MAINNET: { "chainId": 56, "name": "BNB Smart Chain Mainnet" },
      BINANCE_TESTNET: { "chainId": 97, "name": "BNB Smart Chain Testnet" },
      CELO_ALFAJORES_TESTNET: { "chainId": 44787, "name": "Celo Alfajores Testnet" },
      CELO_MAINNET: { "chainId": 42220, "name": "Celo Mainnet" },
      CRONOS_MAINNET: { "chainId": 25, "name": "Cronos Mainnet" },
      FRAXTAL_MAINNET: { "chainId": 252, "name": "Fraxtal Mainnet" },
      FRAXTAL_TESTNET: { "chainId": 2522, "name": "Fraxtal Testnet" },
      GNOSIS_MAINNET: { "chainId": 100, "name": "Gnosis" },
      LINEA_MAINNET: { "chainId": 59144, "name": "Linea Mainnet" },
      LINEA_SEPOLIA_TESTNET: { "chainId": 59141, "name": "Linea Sepolia Testnet" },
      MANTLE_MAINNET: { "chainId": 5e3, "name": "Mantle Mainnet" },
      MANTLE_SEPOLIA_TESTNET: { "chainId": 5003, "name": "Mantle Sepolia Testnet" },
      MEMECORE_MAINNET: { "chainId": 4352, "name": "Memecore Mainnet" },
      MEMECORE_TESTNET: { "chainId": 43521, "name": "Memecore Testnet" },
      MOONBASE_ALPHA_TESTNET: { "chainId": 1287, "name": "Moonbase Alpha Testnet" },
      MOONBEAM_MAINNET: { "chainId": 1284, "name": "Moonbeam Mainnet" },
      MOONRIVER_MAINNET: { "chainId": 1285, "name": "Moonriver Mainnet" },
      OPTIMISN_MAINNET: { "chainId": 10, "name": "OP Mainnet" },
      OPTIMISN_SEPOLIA_TESTNET: { "chainId": 11155420, "name": "OP Sepolia Testnet" },
      POLYGON_AMOY_TESTNET: { "chainId": 80002, "name": "Polygon Amoy Testnet" },
      POLYGON_MAINNET: { "chainId": 137, "name": "Polygon Mainnet" },
      POLYGONZK_CARDONA_TESTNET: { "chainId": 2442, "name": "Polygon zkEVM Cardona Testnet" },
      POLYGONZK_MAINNET: { "chainId": 1101, "name": "Polygon zkEVM Mainnet" },
      SCROLL_MAINNET: { "chainId": 534352, "name": "Scroll Mainnet" },
      SCROLL_SEPOLIA_TESTNET: { "chainId": 534351, "name": "Scroll Sepolia Testnet" },
      SONIC_BLAZE_TESTNET: { "chainId": 57054, "name": "Sonic Blaze Testnet" },
      SONIC_MAINNET: { "chainId": 146, "name": "Sonic Mainnet" },
      SOPHON_MAINNET: { "chainId": 50104, "name": "Sophon Mainnet" },
      SOPHON_SEPOLIA_TESTNET: { "chainId": 531050104, "name": "Sophon Sepolia Testnet" },
      SWELLCHAIN_MAINNET: { "chainId": 1923, "name": "Swellchain Mainnet" },
      SWELLCHAIN_TESTNET: { "chainId": 1924, "name": "Swellchain Testnet" },
      TAIKO_HEKLA_L2_TESTNET: { "chainId": 167009, "name": "Taiko Hekla L2 Testnet" },
      TAIKO_MAINNET: { "chainId": 167e3, "name": "Taiko Mainnet" },
      UNICHAIN_MAINNET: { "chainId": 130, "name": "Unichain Mainnet" },
      UNICHAIN_SEPOLIA_TESTNET: { "chainId": 1301, "name": "Unichain Sepolia Testnet" },
      WEMIX3_MAINNET: { "chainId": 1111, "name": "WEMIX3.0 Mainnet" },
      WEMIX3_TESTNET: { "chainId": 1112, "name": "WEMIX3.0 Testnet" },
      WORLD_MAINNET: { "chainId": 480, "name": "World Mainnet" },
      WORLD_SEPOLIA_TESTNET: { "chainId": 4801, "name": "World Sepolia Testnet" },
      XAI_MAINNET: { "chainId": 660279, "name": "Xai Mainnet" },
      XAI_SEPOLIA_TESTNET: { "chainId": 37714555429, "name": "Xai Sepolia Testnet" },
      XINFIN_TESTNET: { "chainId": 51, "name": "XDC Apothem Testnet" },
      XINFIN_MAINNET: { "chainId": 50, "name": "XDC Mainnet" },
      ZKSYNC_MAINNET: { "chainId": 324, "name": "zkSync Mainnet" },
      ZKSYNC_SEPOLIA_TESTNET: { "chainId": 300, "name": "zkSync Sepolia Testnet" }
    };
    schema48 = {
      namespace: "etherscan",
      name: "SmartContractExplorer",
      description: "Provides available chains and fetches smart contract source code",
      docs: ["https://docs.etherscan.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.etherscan.io/v2/api",
      requiredServerParams: ["ETHERSCAN_API_KEY"],
      headers: {},
      routes: {
        getAvailableChains: {
          requestMethod: "GET",
          description: "List available blockchain aliases",
          route: "/chains",
          parameters: [],
          tests: [{ _description: "Fetch available chains" }],
          modifiers: [{ phase: "execute", handlerName: "getAvailableChains" }]
        },
        getSmartContractAbi: {
          requestMethod: "GET",
          description: "Fetch smart contract source code by alias",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ETHEREUM_MAINNET,SEPOLIA_TESTNET,HOLESKY_TESTNET,ABSTRACT_MAINNET,ABSTRACT_SEPOLIA_TESTNET,APECHAIN_CURTIS_TESTNET,APECHAIN_MAINNET,ARBITRUM_NOVA_MAINNET,ARBITRUM_ONE_MAINNET,ARBITRUM_SEPOLIA_TESTNET,AVALANCHE_CCHAIN,AVALANCHE_FUJI_TESTNET,BASE_MAINNET,BASE_SEPOLIA_TESTNET,BERACHAIN_MAINNET,BERACHAIN_BEPOLIA_TESTNET,BITTORRENT_MAINNET,BITTORRENT_TESTNET,BLAST_MAINNET,BLAST_SEPOLIA_TESTNET,BINANCE_MAINNET,BINANCE_TESTNET,CELO_ALFAJORES_TESTNET,CELO_MAINNET,CRONOS_MAINNET,FRAXTAL_MAINNET,FRAXTAL_TESTNET,GNOSIS_MAINNET,LINEA_MAINNET,LINEA_SEPOLIA_TESTNET,MANTLE_MAINNET,MANTLE_SEPOLIA_TESTNET,MEMECORE_MAINNET,MEMECORE_TESTNET,MOONBASE_ALPHA_TESTNET,MOONBEAM_MAINNET,MOONRIVER_MAINNET,OPTIMISN_MAINNET,OPTIMISN_SEPOLIA_TESTNET,POLYGON_AMOY_TESTNET,POLYGON_MAINNET,POLYGONZK_CARDONA_TESTNET,POLYGONZK_MAINNET,SCROLL_MAINNET,SCROLL_SEPOLIA_TESTNET,SONIC_BLAZE_TESTNET,SONIC_MAINNET,SOPHON_MAINNET,SOPHON_SEPOLIA_TESTNET,SWELLCHAIN_MAINNET,SWELLCHAIN_TESTNET,TAIKO_HEKLA_L2_TESTNET,TAIKO_MAINNET,UNICHAIN_MAINNET,UNICHAIN_SEPOLIA_TESTNET,WEMIX3_MAINNET,WEMIX3_TESTNET,WORLD_MAINNET,WORLD_SEPOLIA_TESTNET,XAI_MAINNET,XAI_SEPOLIA_TESTNET,XINFIN_TESTNET,XINFIN_MAINNET,ZKSYNC_MAINNET,ZKSYNC_SEPOLIA_TESTNET)", options: [] } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getabi", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(42)", "max(42)"] } },
            { position: { key: "apikey", value: "{{ETHERSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Uniswap V2 Factory on Ethereum", chainName: "ETHEREUM_MAINNET", address: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f" },
            { _description: "Uniswap V3 Factory on Ethereum", chainName: "ETHEREUM_MAINNET", address: "0x1F98431c8aD98523631AE4a59f267346ea31F984" },
            { _description: "QuickSwap Factory on Polygon", chainName: "POLYGON_MAINNET", address: "0x5757371414417b8c6caad45baef941abc7d3ab32" },
            { _description: "PancakeSwap V2 Factory on BNB Chain", chainName: "BINANCE_MAINNET", address: "0xca143ce32fe78f1f7019d7d551a6402fc5350c73" },
            { _description: "Trader Joe V2.1 Factory on Avalanche", chainName: "AVALANCHE_CCHAIN", address: "0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" },
            { phase: "post", handlerName: "modifyAbi" }
          ]
        },
        getSourceCode: {
          requestMethod: "GET",
          description: "Fetch smart contract source code by alias",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ETHEREUM_MAINNET,SEPOLIA_TESTNET,HOLESKY_TESTNET,ABSTRACT_MAINNET,ABSTRACT_SEPOLIA_TESTNET,APECHAIN_CURTIS_TESTNET,APECHAIN_MAINNET,ARBITRUM_NOVA_MAINNET,ARBITRUM_ONE_MAINNET,ARBITRUM_SEPOLIA_TESTNET,AVALANCHE_CCHAIN,AVALANCHE_FUJI_TESTNET,BASE_MAINNET,BASE_SEPOLIA_TESTNET,BERACHAIN_MAINNET,BERACHAIN_BEPOLIA_TESTNET,BITTORRENT_MAINNET,BITTORRENT_TESTNET,BLAST_MAINNET,BLAST_SEPOLIA_TESTNET,BINANCE_MAINNET,BINANCE_TESTNET,CELO_ALFAJORES_TESTNET,CELO_MAINNET,CRONOS_MAINNET,FRAXTAL_MAINNET,FRAXTAL_TESTNET,GNOSIS_MAINNET,LINEA_MAINNET,LINEA_SEPOLIA_TESTNET,MANTLE_MAINNET,MANTLE_SEPOLIA_TESTNET,MEMECORE_MAINNET,MEMECORE_TESTNET,MOONBASE_ALPHA_TESTNET,MOONBEAM_MAINNET,MOONRIVER_MAINNET,OPTIMISN_MAINNET,OPTIMISN_SEPOLIA_TESTNET,POLYGON_AMOY_TESTNET,POLYGON_MAINNET,POLYGONZK_CARDONA_TESTNET,POLYGONZK_MAINNET,SCROLL_MAINNET,SCROLL_SEPOLIA_TESTNET,SONIC_BLAZE_TESTNET,SONIC_MAINNET,SOPHON_MAINNET,SOPHON_SEPOLIA_TESTNET,SWELLCHAIN_MAINNET,SWELLCHAIN_TESTNET,TAIKO_HEKLA_L2_TESTNET,TAIKO_MAINNET,UNICHAIN_MAINNET,UNICHAIN_SEPOLIA_TESTNET,WEMIX3_MAINNET,WEMIX3_TESTNET,WORLD_MAINNET,WORLD_SEPOLIA_TESTNET,XAI_MAINNET,XAI_SEPOLIA_TESTNET,XINFIN_TESTNET,XINFIN_MAINNET,ZKSYNC_MAINNET,ZKSYNC_SEPOLIA_TESTNET)", options: [] } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getsourcecode", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(42)", "max(42)"] } },
            { position: { key: "apikey", value: "{{ETHERSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Uniswap V2 Factory on Ethereum", chainName: "ETHEREUM_MAINNET", address: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045" },
            { _description: "QuickSwap Factory on Polygon", chainName: "POLYGON_MAINNET", address: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045" },
            { _description: "PancakeSwap V2 Factory on BNB Chain", chainName: "BINANCE_MAINNET", address: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045" },
            { _description: "Trader Joe V2.1 Factory on Avalanche", chainName: "AVALANCHE_CCHAIN", address: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045" },
            { _description: "Trader Joe V2.1 Factory on Avalanche", chainName: "AVALANCHE_CCHAIN", address: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" },
            { phase: "post", handlerName: "modifySourceCode" }
          ]
        }
      },
      handlers: {
        getAvailableChains: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct["data"] = Object.keys(chainsByAlias);
          return { struct, payload };
        }, "getAvailableChains"),
        insertChainId: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const { chainId } = chainsByAlias[chainName];
          payload["url"] = payload["url"].replace(`chainName=${chainName}`, `chainid=${chainId}`);
          return { struct, payload };
        }, "insertChainId"),
        modifyAbi: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct["data"]) {
            return { struct, payload };
          }
          if (struct["data"].status !== "1") {
            struct["status"] = false;
            struct["messages"].push(struct.data.message);
            return { struct, payload };
          }
          struct["data"] = JSON.parse(struct["data"]?.result);
          return { struct, payload };
        }, "modifyAbi"),
        modifySourceCode: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct["data"]) {
            return { struct, payload };
          }
          if (struct["data"].status !== "1") {
            struct["status"] = false;
            struct["messages"].push(struct.data.message);
            return { struct, payload };
          }
          struct["data"] = struct["data"].result;
          return { struct, payload };
        }, "modifySourceCode")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/etherscan/getGaspriceMultichain.mjs
var getGaspriceMultichain_exports = {};
__export(getGaspriceMultichain_exports, {
  schema: () => schema49
});
var chainsByAlias2, schema49;
var init_getGaspriceMultichain = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/etherscan/getGaspriceMultichain.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    chainsByAlias2 = {
      ETHEREUM_MAINNET: { "chainId": 1, "name": "Ethereum Mainnet" },
      SEPOLIA_TESTNET: { "chainId": 11155111, "name": "Sepolia Testnet" },
      HOLESKY_TESTNET: { "chainId": 17e3, "name": "Holesky Testnet" },
      ABSTRACT_MAINNET: { "chainId": 2741, "name": "Abstract Mainnet" },
      ABSTRACT_SEPOLIA_TESTNET: { "chainId": 11124, "name": "Abstract Sepolia Testnet" },
      APECHAIN_CURTIS_TESTNET: { "chainId": 33111, "name": "ApeChain Curtis Testnet" },
      APECHAIN_MAINNET: { "chainId": 33139, "name": "ApeChain Mainnet" },
      ARBITRUM_NOVA_MAINNET: { "chainId": 42170, "name": "Arbitrum Nova Mainnet" },
      ARBITRUM_ONE_MAINNET: { "chainId": 42161, "name": "Arbitrum One Mainnet" },
      ARBITRUM_SEPOLIA_TESTNET: { "chainId": 421614, "name": "Arbitrum Sepolia Testnet" },
      AVALANCHE_CCHAIN: { "chainId": 43114, "name": "Avalanche C-Chain" },
      AVALANCHE_FUJI_TESTNET: { "chainId": 43113, "name": "Avalanche Fuji Testnet" },
      BASE_MAINNET: { "chainId": 8453, "name": "Base Mainnet" },
      BASE_SEPOLIA_TESTNET: { "chainId": 84532, "name": "Base Sepolia Testnet" },
      BERACHAIN_MAINNET: { "chainId": 80094, "name": "Berachain Mainnet" },
      BERACHAIN_BEPOLIA_TESTNET: { "chainId": 80069, "name": "Berachain Bepolia Testnet" },
      BITTORRENT_MAINNET: { "chainId": 199, "name": "BitTorrent Chain Mainnet" },
      BITTORRENT_TESTNET: { "chainId": 1028, "name": "BitTorrent Chain Testnet" },
      BLAST_MAINNET: { "chainId": 81457, "name": "Blast Mainnet" },
      BLAST_SEPOLIA_TESTNET: { "chainId": 168587773, "name": "Blast Sepolia Testnet" },
      BINANCE_MAINNET: { "chainId": 56, "name": "BNB Smart Chain Mainnet" },
      BINANCE_TESTNET: { "chainId": 97, "name": "BNB Smart Chain Testnet" },
      CELO_ALFAJORES_TESTNET: { "chainId": 44787, "name": "Celo Alfajores Testnet" },
      CELO_MAINNET: { "chainId": 42220, "name": "Celo Mainnet" },
      CRONOS_MAINNET: { "chainId": 25, "name": "Cronos Mainnet" },
      FRAXTAL_MAINNET: { "chainId": 252, "name": "Fraxtal Mainnet" },
      FRAXTAL_TESTNET: { "chainId": 2522, "name": "Fraxtal Testnet" },
      GNOSIS_MAINNET: { "chainId": 100, "name": "Gnosis" },
      LINEA_MAINNET: { "chainId": 59144, "name": "Linea Mainnet" },
      LINEA_SEPOLIA_TESTNET: { "chainId": 59141, "name": "Linea Sepolia Testnet" },
      MANTLE_MAINNET: { "chainId": 5e3, "name": "Mantle Mainnet" },
      MANTLE_SEPOLIA_TESTNET: { "chainId": 5003, "name": "Mantle Sepolia Testnet" },
      MEMECORE_MAINNET: { "chainId": 4352, "name": "Memecore Mainnet" },
      MEMECORE_TESTNET: { "chainId": 43521, "name": "Memecore Testnet" },
      MOONBASE_ALPHA_TESTNET: { "chainId": 1287, "name": "Moonbase Alpha Testnet" },
      MOONBEAM_MAINNET: { "chainId": 1284, "name": "Moonbeam Mainnet" },
      MOONRIVER_MAINNET: { "chainId": 1285, "name": "Moonriver Mainnet" },
      OPTIMISN_MAINNET: { "chainId": 10, "name": "OP Mainnet" },
      OPTIMISN_SEPOLIA_TESTNET: { "chainId": 11155420, "name": "OP Sepolia Testnet" },
      POLYGON_AMOY_TESTNET: { "chainId": 80002, "name": "Polygon Amoy Testnet" },
      POLYGON_MAINNET: { "chainId": 137, "name": "Polygon Mainnet" },
      POLYGONZK_CARDONA_TESTNET: { "chainId": 2442, "name": "Polygon zkEVM Cardona Testnet" },
      POLYGONZK_MAINNET: { "chainId": 1101, "name": "Polygon zkEVM Mainnet" },
      SCROLL_MAINNET: { "chainId": 534352, "name": "Scroll Mainnet" },
      SCROLL_SEPOLIA_TESTNET: { "chainId": 534351, "name": "Scroll Sepolia Testnet" },
      SONIC_BLAZE_TESTNET: { "chainId": 57054, "name": "Sonic Blaze Testnet" },
      SONIC_MAINNET: { "chainId": 146, "name": "Sonic Mainnet" },
      SOPHON_MAINNET: { "chainId": 50104, "name": "Sophon Mainnet" },
      SOPHON_SEPOLIA_TESTNET: { "chainId": 531050104, "name": "Sophon Sepolia Testnet" },
      SWELLCHAIN_MAINNET: { "chainId": 1923, "name": "Swellchain Mainnet" },
      SWELLCHAIN_TESTNET: { "chainId": 1924, "name": "Swellchain Testnet" },
      TAIKO_HEKLA_L2_TESTNET: { "chainId": 167009, "name": "Taiko Hekla L2 Testnet" },
      TAIKO_MAINNET: { "chainId": 167e3, "name": "Taiko Mainnet" },
      UNICHAIN_MAINNET: { "chainId": 130, "name": "Unichain Mainnet" },
      UNICHAIN_SEPOLIA_TESTNET: { "chainId": 1301, "name": "Unichain Sepolia Testnet" },
      WEMIX3_MAINNET: { "chainId": 1111, "name": "WEMIX3.0 Mainnet" },
      WEMIX3_TESTNET: { "chainId": 1112, "name": "WEMIX3.0 Testnet" },
      WORLD_MAINNET: { "chainId": 480, "name": "World Mainnet" },
      WORLD_SEPOLIA_TESTNET: { "chainId": 4801, "name": "World Sepolia Testnet" },
      XAI_MAINNET: { "chainId": 660279, "name": "Xai Mainnet" },
      XAI_SEPOLIA_TESTNET: { "chainId": 37714555429, "name": "Xai Sepolia Testnet" },
      XINFIN_TESTNET: { "chainId": 51, "name": "XDC Apothem Testnet" },
      XINFIN_MAINNET: { "chainId": 50, "name": "XDC Mainnet" },
      ZKSYNC_MAINNET: { "chainId": 324, "name": "zkSync Mainnet" },
      ZKSYNC_SEPOLIA_TESTNET: { "chainId": 300, "name": "zkSync Sepolia Testnet" }
    };
    schema49 = {
      namespace: "etherscan",
      name: "SmartContractExplorer",
      description: "Provides available chains and fetches smart contract source code",
      docs: ["https://docs.etherscan.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.etherscan.io/v2/api",
      requiredServerParams: ["ETHERSCAN_API_KEY"],
      headers: {},
      routes: {
        getGasOracle: {
          requestMethod: "GET",
          description: "Fetch current gas oracle data for a given chain",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ETHEREUM_MAINNET,SEPOLIA_TESTNET,ARBITRUM_ONE_MAINNET,POLYGON_MAINNET,BINANCE_MAINNET,AVALANCHE_CCHAIN)", options: [] } },
            { position: { key: "module", value: "gastracker", location: "query" } },
            { position: { key: "action", value: "gasoracle", location: "query" } },
            { position: { key: "apikey", value: "{{ETHERSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Gas oracle on Ethereum Mainnet", chainName: "ETHEREUM_MAINNET" },
            { _description: "Gas oracle on Arbitrum One", chainName: "CELO_MAINNET" },
            { _description: "Gas oracle on Polygon", chainName: "POLYGON_MAINNET" },
            { _description: "Gas oracle on Binance Smart Chain", chainName: "BINANCE_MAINNET" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        estimateGasCost: {
          requestMethod: "GET",
          description: "Estimate gas cost using a specific gas price for a given chain",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ETHEREUM_MAINNET,SEPOLIA_TESTNET,ARBITRUM_ONE_MAINNET,POLYGON_MAINNET,BINANCE_MAINNET,AVALANCHE_CCHAIN)", options: [] } },
            { position: { key: "module", value: "gastracker", location: "query" } },
            { position: { key: "action", value: "gasestimate", location: "query" } },
            { position: { key: "gasprice", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "apikey", value: "{{ETHERSCAN_API_KEY}}", location: "query" } }
          ],
          tests: [
            { _description: "Estimate gas cost on Ethereum with 2 Gwei", chainName: "ETHEREUM_MAINNET", gasprice: "2000000000" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        insertChainId: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const { chainId } = chainsByAlias2[chainName];
          payload["url"] = payload["url"].replace(`chainName=${chainName}`, `chainid=${chainId}`);
          return { struct, payload };
        }, "insertChainId"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct["data"]) {
            return { struct, payload };
          }
          if (struct["data"].status !== "1") {
            struct["status"] = false;
            struct["messages"].push(struct.data.message);
            return { struct, payload };
          }
          struct["data"] = struct["data"].result;
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/ethscriptions-com/ethscriptions-api.mjs
var ethscriptions_api_exports = {};
__export(ethscriptions_api_exports, {
  schema: () => schema50
});
var schema50;
var init_ethscriptions_api = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/ethscriptions-com/ethscriptions-api.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema50 = {
      namespace: "ethscriptions",
      name: "Ethscriptions API V2",
      description: "Access the Ethscriptions protocol - Ethereum-based digital artifacts and tokens",
      docs: ["https://api.ethscriptions.com/v2", "https://github.com/0xFacet/ethscriptions-indexer"],
      tags: ["nft", "ethereum", "inscriptions"],
      flowMCP: "1.2.0",
      root: "https://api.ethscriptions.com/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        listEthscriptions: {
          requestMethod: "GET",
          description: "Retrieve a list of ethscriptions with various filtering options",
          route: "/ethscriptions",
          parameters: [
            { position: { key: "current_owner", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "creator", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "initial_owner", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "mimetype", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "token_tick", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "token_protocol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "after_block", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } },
            { position: { key: "before_block", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } },
            { position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(newest_first,oldest_first)", options: ["default(newest_first)", "optional()"] } },
            { position: { key: "max_results", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(50)", "default(25)", "optional()"] } },
            { position: { key: "page_key", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get latest ethscriptions", max_results: 10 },
            { _description: "Get ethscriptions by owner", current_owner: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e", max_results: 5 },
            { _description: "Get ethscriptions by token tick", token_tick: "eths", max_results: 15 },
            { _description: "Get recent ethscriptions after block", after_block: 19e6, max_results: 20 }
          ],
          modifiers: []
        },
        getEthscription: {
          requestMethod: "GET",
          description: "Get detailed information about a specific ethscription by transaction hash or number",
          route: "/ethscriptions/:id",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get ethscription by transaction hash", id: "0x0ef100873db4e3b7446e9a3be0432ab8bc92119d009aa200f70c210ac9dcd4a6" },
            { _description: "Get ethscription by number", id: "5853618" }
          ],
          modifiers: []
        },
        getEthscriptionData: {
          requestMethod: "GET",
          description: "Retrieve the raw content data of an ethscription",
          route: "/ethscriptions/:id/data",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get ethscription data by transaction hash", id: "0x0ef100873db4e3b7446e9a3be0432ab8bc92119d009aa200f70c210ac9dcd4a6" },
            { _description: "Get ethscription data by number", id: "0" }
          ],
          modifiers: []
        },
        getEthscriptionAttachment: {
          requestMethod: "GET",
          description: "Retrieve the raw attachment data of an ethscription",
          route: "/ethscriptions/:id/attachment",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get ethscription attachment", id: "0xcf23d640184114e9d870a95f0fdc3aa65e436c5457d5b6ee2e3c6e104420abd1" }
          ],
          modifiers: []
        },
        checkEthscriptionExists: {
          requestMethod: "GET",
          description: "Check if an ethscription exists by its content SHA hash",
          route: "/ethscriptions/exists/:sha",
          parameters: [
            { position: { key: "sha", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Check ethscription existence by SHA", sha: "0x2817fd9cf901e4435253881550731a5edc5e519c19de46b08e2b19a18e95143e" }
          ],
          modifiers: []
        },
        checkMultipleEthscriptionsExistence: {
          requestMethod: "POST",
          description: "Check existence of multiple ethscriptions by SHA hashes (max 100)",
          route: "/ethscriptions/exists_multi",
          parameters: [
            { position: { key: "shas", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "array()", options: ["min(1)", "max(100)"] } }
          ],
          tests: [
            { _description: "Check multiple ethscriptions existence", shas: ["0x2817fd9cf901e4435253881550731a5edc5e519c19de46b08e2b19a18e95143e", "0xdcb130d85be00f8fd735ddafcba1cc83f99ba8dab0fc79c833401827b615c92b"] }
          ],
          modifiers: []
        },
        listTransfers: {
          requestMethod: "GET",
          description: "List ethscription transfers with filtering options",
          route: "/ethscription_transfers",
          parameters: [
            { position: { key: "from_address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "to_address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "ethscription_token_tick", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "ethscription_token_protocol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(newest_first,oldest_first)", options: ["default(newest_first)", "optional()"] } },
            { position: { key: "max_results", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(50)", "default(25)", "optional()"] } },
            { position: { key: "page_key", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get recent transfers", max_results: 10 },
            { _description: "Get transfers from address", from_address: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e", max_results: 5 },
            { _description: "Get transfers for token tick", ethscription_token_tick: "eths", max_results: 15 }
          ],
          modifiers: []
        },
        listTokens: {
          requestMethod: "GET",
          description: "List ethscription tokens with filtering options",
          route: "/tokens",
          parameters: [
            { position: { key: "protocol", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "tick", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(newest_first,oldest_first)", options: ["default(newest_first)", "optional()"] } },
            { position: { key: "max_results", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(50)", "default(25)", "optional()"] } },
            { position: { key: "page_key", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get all tokens", max_results: 20 },
            { _description: "Get erc-20 protocol tokens", protocol: "erc-20", max_results: 10 },
            { _description: "Get specific token tick", tick: "nodes", max_results: 5 }
          ],
          modifiers: []
        },
        getTokenDetails: {
          requestMethod: "GET",
          description: "Get detailed information about a specific token including balances",
          route: "/tokens/:protocol/:tick",
          parameters: [
            { position: { key: "protocol", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "tick", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get erc-20 nodes token details", protocol: "erc-20", tick: "nodes" },
            { _description: "Get erc-20 eths token details", protocol: "erc-20", tick: "eths" }
          ],
          modifiers: []
        },
        getTokenHistoricalState: {
          requestMethod: "GET",
          description: "Get historical state of a token at a specific block number",
          route: "/tokens/:protocol/:tick/historical_state",
          parameters: [
            { position: { key: "protocol", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "tick", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "as_of_block", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get token historical state", protocol: "erc-20", tick: "nodes", as_of_block: 19e6 }
          ],
          modifiers: []
        },
        getIndexerStatus: {
          requestMethod: "GET",
          description: "Get current status of the ethscriptions indexer",
          route: "/status",
          parameters: [],
          tests: [
            { _description: "Get indexer status" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/goldsky-nouns/goldsky-nouns.mjs
var goldsky_nouns_exports = {};
__export(goldsky_nouns_exports, {
  schema: () => schema51
});
var schema51;
var init_goldsky_nouns = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/goldsky-nouns/goldsky-nouns.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema51 = {
      namespace: "goldskyNouns",
      name: "Nouns DAO Subgraph",
      description: "Access various views into Nouns DAO data from the Goldsky-hosted subgraph.",
      docs: ["https://docs.goldsky.com", "https://nouns.wtf"],
      tags: ["production", "dao", "governance", "nft"],
      flowMCP: "1.2.0",
      root: "https://api.goldsky.com/api/public/project_cldf2o9pqagp43svvbk5u3kmo/subgraphs/nouns/prod/gn",
      requiredServerParams: [],
      headers: { "Content-Type": "application/json" },
      routes: {
        getRecentProposals: {
          requestMethod: "POST",
          description: "Retrieve recent proposals with detailed voting information.",
          route: "/",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] } }
          ],
          tests: [
            { _description: "Fetch recent proposals", first: 10 },
            { _description: "Fetch 5 proposals", first: 5 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetRecentProposals" }
          ]
        },
        getCurrentAuctions: {
          requestMethod: "POST",
          description: "Get current and recent auction data with bid information.",
          route: "/",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "max(50)", "default(5)"] } }
          ],
          tests: [
            { _description: "Fetch recent auctions", first: 5 },
            { _description: "Fetch 3 auctions", first: 3 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetCurrentAuctions" }
          ]
        },
        getNounDetails: {
          requestMethod: "POST",
          description: "Get detailed Noun information including traits, owner, and voting history.",
          route: "/",
          parameters: [
            { position: { key: "nounId", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get details for Noun #1", nounId: "1" },
            { _description: "Get details for Noun #100", nounId: "100" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetNounDetails" }
          ]
        },
        getTopDelegates: {
          requestMethod: "POST",
          description: "Get delegates with the highest voting power in the Nouns DAO.",
          route: "/",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "max(50)", "default(10)"] } }
          ],
          tests: [
            { _description: "Get top 10 delegates", first: 10 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetTopDelegates" }
          ]
        }
      },
      handlers: {
        buildGetRecentProposals: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          const query = `
                query GetRecentProposals($first: Int!) {
                    proposals(first: $first, orderBy: createdTimestamp, orderDirection: desc) {
                        id
                        title
                        description
                        status
                        createdTimestamp
                        proposer {
                            id
                        }
                        forVotes
                        againstVotes
                        abstainVotes
                    }
                }
            `;
          payload.body = {
            query,
            variables: { first }
          };
          return { struct, payload };
        }, "buildGetRecentProposals"),
        buildGetCurrentAuctions: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          const query = `
                query GetCurrentAuctions($first: Int!) {
                    auctions(first: $first, orderBy: startTime, orderDirection: desc) {
                        id
                        noun {
                            id
                        }
                        amount
                        startTime
                        endTime
                        bidder {
                            id
                        }
                        settled
                        bids(first: 5, orderBy: amount, orderDirection: desc) {
                            id
                            amount
                            bidder {
                                id
                            }
                            blockTimestamp
                        }
                    }
                }
            `;
          payload.body = {
            query,
            variables: { first }
          };
          return { struct, payload };
        }, "buildGetCurrentAuctions"),
        buildGetNounDetails: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { nounId } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          const query = `
                query GetNounDetails($nounId: String!) {
                    noun(id: $nounId) {
                        id
                        owner {
                            id
                        }
                        seed {
                            background
                            body
                            accessory
                            head
                            glasses
                        }
                        votes(first: 10, orderBy: blockTimestamp, orderDirection: desc) {
                            id
                            support
                            votes
                            proposal {
                                id
                                title
                            }
                        }
                    }
                }
            `;
          payload.body = {
            query,
            variables: { nounId }
          };
          return { struct, payload };
        }, "buildGetNounDetails"),
        buildGetTopDelegates: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          const query = `
                query GetTopDelegates($first: Int!) {
                    delegates(first: $first, orderBy: delegatedVotes, orderDirection: desc) {
                        id
                        delegatedVotes
                        tokenHoldersRepresentedAmount
                        proposals(first: 3) {
                            id
                            title
                        }
                        votes(first: 5, orderBy: blockTimestamp, orderDirection: desc) {
                            id
                            support
                            proposal {
                                id
                                title
                            }
                        }
                    }
                }
            `;
          payload.body = {
            query,
            variables: { first }
          };
          return { struct, payload };
        }, "buildGetTopDelegates")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/goldsky-nouns/lil-nouns.mjs
var lil_nouns_exports = {};
__export(lil_nouns_exports, {
  schema: () => schema52
});
var schema52;
var init_lil_nouns = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/goldsky-nouns/lil-nouns.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema52 = {
      namespace: "goldskyLilNouns",
      name: "Lil Nouns Subgraph",
      description: "Fetches proposal data from the Lil Nouns subgraph hosted on Goldsky.",
      docs: ["https://lilnouns.wtf", "https://docs.goldsky.com"],
      tags: ["production", "data", "api"],
      flowMCP: "1.2.0",
      root: "https://api.goldsky.com/api/public/project_cldjvjgtylso13swq3dre13sf/subgraphs/lil-nouns-subgraph/1.0.6/gn",
      requiredServerParams: [],
      headers: { "Content-Type": "application/json" },
      routes: {
        getProposals: {
          requestMethod: "POST",
          description: "Retrieves the first 1000 proposals ordered by createdBlock in ascending order.",
          route: "/",
          parameters: [],
          tests: [
            { _description: "Fetch first 1000 proposals from Lil Nouns subgraph" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetProposalsQuery" }
          ]
        },
        getProposalById: {
          requestMethod: "POST",
          description: "Fetch a single proposal by its numeric ID.",
          route: "/",
          parameters: [
            { position: { key: "id", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["regex(^\\\\d+$)"] } }
          ],
          tests: [
            { _description: "Fetch proposal with ID 327", id: "327" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetProposalByIdQuery" }
          ]
        }
      },
      handlers: {
        buildGetProposalsQuery: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          payload.url = payload.url.replace(/\/$/, "");
          payload.body = {
            variables: {},
            query: `{
  proposals(first: 1000, orderBy: createdTimestamp, orderDirection: desc) {
    id
    title
    status
    forVotes
    againstVotes
    abstainVotes
    createdTimestamp
    startBlock
    endBlock
    proposer {
      id
    }
    __typename
  }
}`
          };
          return { struct, payload };
        }, "buildGetProposalsQuery"),
        buildGetProposalByIdQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { id } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          payload.body = {
            variables: { id },
            query: `query GetProposalById($id: String!) {
  proposal(id: $id) {
    id
    title
    description
    status
    quorumVotes
    forVotes
    againstVotes
    abstainVotes
    createdTimestamp
    startBlock
    endBlock
    proposer {
      id
      __typename
    }
    __typename
  }
}`
          };
          return { struct, payload };
        }, "buildGetProposalByIdQuery")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/goldsky-nouns/nouns.mjs
var nouns_exports = {};
__export(nouns_exports, {
  schema: () => schema53
});
var schema53;
var init_nouns = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/goldsky-nouns/nouns.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema53 = {
      namespace: "goldskyNouns",
      name: "Nouns DAO Subgraph",
      description: "Access various views into Nouns DAO data from the Goldsky-hosted subgraph.",
      docs: ["https://docs.goldsky.com", "https://nouns.wtf"],
      tags: ["production", "dao", "governance", "nft"],
      flowMCP: "1.2.0",
      root: "https://api.goldsky.com/api/public/project_cldf2o9pqagp43svvbk5u3kmo/subgraphs/nouns/prod/gn",
      requiredServerParams: [],
      headers: { "Content-Type": "application/json" },
      routes: {
        getCandidateProposals: {
          requestMethod: "POST",
          description: "Retrieve up to 1000 candidate proposals from the subgraph.",
          route: "/",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "default(1000)"] } }
          ],
          tests: [
            { _description: "Fetch candidate proposals", first: 1e3 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetCandidateProposals" }
          ]
        },
        getActivePendingUpdatableProposers: {
          requestMethod: "POST",
          description: "Get proposers with ACTIVE or PENDING proposals where endBlock is still in the future.",
          route: "/",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "default(1000)"] } }
          ],
          tests: [
            { _description: "Fetch active and pending proposals", first: 1e3 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetActivePendingUpdatableProposers" }
          ]
        },
        getLatestAuctions: {
          requestMethod: "POST",
          description: "Fetch up to 1000 latest auctions and their bid data.",
          route: "/",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "default(1000)"] } },
            { position: { key: "skip", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["default(0)"] } }
          ],
          tests: [
            { _description: "Fetch 1000 latest auctions", first: 1e3, skip: 0 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetLatestAuctions" }
          ]
        }
      },
      handlers: {
        buildGetCandidateProposals: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          payload.body = {
            operationName: "GetCandidateProposals",
            variables: { first },
            query: `query GetCandidateProposals($first: Int!) {
  proposalCandidates(first: $first) {
    id
    slug
    proposer
    lastUpdatedTimestamp
    createdTransactionHash
    canceled
    versions {
      content { title __typename }
      __typename
    }
    latestVersion {
      content {
        title
        description
        targets
        values
        signatures
        calldatas
        encodedProposalHash
        proposalIdToUpdate
        contentSignatures {
          id
          signer {
            id
            proposals { id __typename }
            __typename
          }
          sig
          expirationTimestamp
          canceled
          reason
          __typename
        }
        matchingProposalIds
        __typename
      }
      __typename
    }
    __typename
  }
}`
          };
          return { struct, payload };
        }, "buildGetCandidateProposals"),
        buildGetActivePendingUpdatableProposers: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          payload.body = {
            operationName: "GetActivePendingUpdatableProposers",
            variables: { first },
            query: `query GetActivePendingUpdatableProposers($first: Int!) {
  proposals(
    first: $first
    where: {
      status_in: [ACTIVE, PENDING]
    }
  ) {
    id
    title
    status
    proposer { id __typename }
    __typename
  }
}`
          };
          return { struct, payload };
        }, "buildGetActivePendingUpdatableProposers"),
        buildGetLatestAuctions: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first, skip } = userParams;
          payload.url = payload.url.replace(/\/$/, "");
          payload.body = {
            variables: { first, skip },
            query: `query GetLatestAuctions($first: Int = 1000, $skip: Int = 0) {
  auctions(orderBy: startTime, orderDirection: desc, first: $first, skip: $skip) {
    id
    amount
    settled
    bidder { id }
    startTime
    endTime
    noun {
      id
      owner { id }
    }
    bids {
      id
      amount
      blockNumber
      blockTimestamp
      txHash
      txIndex
      bidder { id }
    }
  }
}`
          };
          return { struct, payload };
        }, "buildGetLatestAuctions")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/honeypot/honeypot.mjs
var honeypot_exports = {};
__export(honeypot_exports, {
  schema: () => schema54
});
var schema54;
var init_honeypot = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/honeypot/honeypot.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema54 = {
      namespace: "honeypot",
      name: "Honeypot Detector",
      description: "Checks if a token contract is a honeypot using honeypot.is API.",
      docs: ["https://honeypot.is"],
      tags: ["production", "security", "token", "validation"],
      flowMCP: "1.2.0",
      root: "https://api.honeypot.is/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        check: {
          requestMethod: "GET",
          description: "Checks if a token address is a honeypot on Ethereum, BSC, or Base.",
          route: "/IsHoneypot",
          parameters: [
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$)"] } }
          ],
          tests: [
            { _description: "Valid ETH token address", address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" },
            { _description: "Another valid ETH token address", address: "0xdAC17F958D2ee523a2206206994597C13D831ec7" }
          ],
          modifiers: [{ phase: "post", handlerName: "normalizeHoneypotResult" }]
        }
      },
      handlers: {
        normalizeHoneypotResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const data = struct.data || {};
          const isHoneypot = data?.honeypotResult?.isHoneypot ?? false;
          const tokenName = data?.token?.name || "Unknown";
          const risk = data?.summary?.risk || "unknown";
          const buyTax = data?.simulationResult?.buyTax ?? "N/A";
          const sellTax = data?.simulationResult?.sellTax ?? "N/A";
          const transferTax = data?.simulationResult?.transferTax ?? "N/A";
          const openSource = data?.contractCode?.openSource ?? "Unknown";
          struct.data = {
            tokenName,
            isHoneypot,
            risk,
            buyTax,
            sellTax,
            transferTax,
            openSource
          };
          return { struct, payload };
        }, "normalizeHoneypotResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/jupiter/jupiter-all.mjs
var jupiter_all_exports = {};
__export(jupiter_all_exports, {
  schema: () => schema55
});
var schema55;
var init_jupiter_all = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/jupiter/jupiter-all.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema55 = {
      namespace: "jupiter",
      name: "Jupiter Token Price Checker",
      description: "Fetches token prices from Jupiter DEX aggregator, priced by default against USDC, with optional vsToken.",
      docs: ["https://station.jup.ag/docs/api/lite-api", "https://dev.jup.ag/docs/price-api/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://lite-api.jup.ag",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTokenPrice: {
          requestMethod: "GET",
          description: "Returns the price of one or more tokens, optionally against a specified vsToken (defaults to USDC).",
          route: "/price/v2",
          parameters: [
            { position: { key: "ids", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
            //{ position: { key: "vsToken", value: "{{OPTIONAL_PARAM}}", location: "query" }, z: { primitive: "string()", options: [], default: "USDC" } }
          ],
          tests: [
            { _description: "Preis von JUP und SOL gegen USDC", ids: "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN,So11111111111111111111111111111111111111112" }
            // { _description: "Preis von JUP gegen SOL", tokenIds: "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN", vsToken: "So11111111111111111111111111111111111111112" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatPriceResponse" }
          ]
        },
        getTokenInfo: {
          requestMethod: "GET",
          description: "Get information about a token using its mint address.",
          route: "/tokens/v1/token/:mintAddress",
          parameters: [
            { position: { key: "mintAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Info for JUP token", mintAddress: "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatPriceResponse" }
          ]
        },
        getTokensInMarket: {
          requestMethod: "GET",
          description: "Get list of token mints belonging to a market address.",
          route: "/tokens/v1/market/:marketAddress/mints",
          parameters: [
            { position: { key: "marketAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Tokens in SOL-USDC market", marketAddress: "BVRbyLjjfSBcoyiYFuxbgKYnWuiFaF9CSXEa5vdSZ9Hh" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatPriceResponse" }
          ]
        },
        getAllTradableTokens: {
          requestMethod: "GET",
          description: "Retrieve a list of all tradable token mints on Jupiter.",
          route: "/tokens/v1/mints/tradable",
          parameters: [],
          tests: [
            { _description: "Fetch tradable token mints" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatPriceResponse" }
          ]
        },
        getTaggedTokens: {
          requestMethod: "GET",
          description: "Fetch token info for tokens matching specific tags.",
          route: "/tokens/v1/tagged/:tags",
          parameters: [
            { position: { key: "tags", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Fetch LST tagged tokens", tags: "lst" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatPriceResponse" }
          ]
        },
        getNewTokens: {
          requestMethod: "GET",
          description: "Retrieve new tokens, ordered by creation timestamp.",
          route: "/tokens/v1/new",
          parameters: [],
          tests: [
            { _description: "Fetch newly listed tokens" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatPriceResponse" }
          ]
        },
        getAllTokens: {
          requestMethod: "GET",
          description: "Fetch all tokens indexed by Jupiter. This is a large payload.",
          route: "/tokens/v1/all",
          parameters: [],
          tests: [
            { _description: "Fetch all token metadata" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatPriceResponse" }
          ]
        }
      },
      handlers: {
        formatPriceResponse: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          try {
          } catch (err) {
            struct.status = false;
            struct.messages.push("Error", err);
          }
          return { struct, payload };
        }, "formatPriceResponse")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/llama-fi/getPools.mjs
var getPools_exports = {};
__export(getPools_exports, {
  schema: () => schema56
});
var schema56;
var init_getPools = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/llama-fi/getPools.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema56 = {
      namespace: "llama",
      name: "DeFiYieldsServer",
      description: "Fetch and analyze DeFi yield pools from yields.llama.fi",
      docs: ["https://docs.llama.fi/pro-api"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://yields.llama.fi",
      requiredServerParams: [],
      headers: {},
      routes: {
        getProjectsByName: {
          requestMethod: "GET",
          description: "Fetch DeFi yield pools overview, optionally filtering by blockchain or project name",
          route: "/pools",
          parameters: [],
          tests: [{ _description: "Fetch all pools overview" }],
          modifiers: [{ phase: "post", handlerName: "getProjectsByName" }]
        },
        getPools: {
          requestMethod: "GET",
          description: "Fetch DeFi yield pools, optionally filtering by blockchain or project name",
          route: "/pools",
          parameters: [
            { position: { key: "chain", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "project", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Fetch all pools" },
            { _description: "Fetch pools filtered by chain", chain: "Ethereum" },
            { _description: "Fetch pools filtered by project", project: "aave-v3" },
            { _description: "Fetch pools filtered by chain and project", chain: "Ethereum", project: "lido" }
          ],
          modifiers: [{ phase: "post", handlerName: "getPools" }]
        }
      },
      handlers: {
        getProjectsByName: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const { data } = struct;
          if (data?.status !== "success") {
            struct["status"] = false;
            struct["messages"].push(data?.error || "Unknown error");
            return { struct, payload };
          }
          const d2 = data?.data || [];
          const projects = d2.reduce((acc, { chain, project }) => {
            if (!Object.hasOwn(acc, chain)) {
              acc[project] = [];
            }
            acc[project].push(chain);
            return acc;
          }, {});
          struct["data"] = Object.entries(projects).sort(([a2], [b]) => {
            if (a2 < b) return -1;
            if (a2 > b) return 1;
            return 0;
          }).reduce((acc, [key, value]) => {
            acc[key] = value;
            return acc;
          }, {});
          return { struct, payload };
        }, "getProjectsByName"),
        getPools: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { data } = struct;
          if (data?.status !== "success") {
            struct["status"] = false;
            struct["messages"].push(data?.error || "Unknown error");
            return { struct, payload };
          }
          struct["data"] = data?.data || [];
          struct["data"] = [
            ["chain", userParams["chain"]],
            ["project", userParams["project"]]
          ].reduce((acc, [key, user]) => {
            if (!user) return acc;
            if (key === "chain") {
              acc = acc.filter(({ chain }) => chain === user);
            } else if (key === "project") {
              acc = acc.filter(({ project }) => project === user);
            }
            return acc;
          }, struct["data"]);
          struct["data"] = {
            "totalResults": struct["data"].length,
            "results": struct["data"]
          };
          return { struct, payload };
        }, "getPools")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/address.mjs
var address_exports = {};
__export(address_exports, {
  schema: () => schema57
});
var schema57;
var init_address = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/address.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema57 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout Addresses",
      description: "All address-level endpoints for LUKSO BlockScout",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        listAddresses: {
          requestMethod: "GET",
          description: "List native coin holders",
          route: "/addresses",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } }
          ],
          tests: [
            { _description: "List holders on mainnet", chainName: "LUKSO_MAINNET" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getAddress: {
          requestMethod: "GET",
          description: "Basic address info",
          route: "/addresses/:address_hash",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$)"] } }
          ],
          tests: [
            { _description: "Get address details", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getAddressCounters: {
          requestMethod: "GET",
          description: "Address usage counters",
          route: "/addresses/:address_hash/counters",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get address counters", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getAddressTransactions: {
          requestMethod: "GET",
          description: "Get transactions by address",
          route: "/addresses/:address_hash/transactions",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get txs for address", chainName: "LUKSO_TESTNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getAddressTokenTransfers: {
          requestMethod: "GET",
          description: "Token transfers for address",
          route: "/addresses/:address_hash/token-transfers",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Token transfers for address", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getAddressInternalTxs: {
          requestMethod: "GET",
          description: "Internal txs for address",
          route: "/addresses/:address_hash/internal-transactions",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get internal txs", chainName: "LUKSO_TESTNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getAddressLogs: {
          requestMethod: "GET",
          description: "Logs emitted to/from address",
          route: "/addresses/:address_hash/logs",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get logs", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getBlocksValidated: {
          requestMethod: "GET",
          description: "Blocks validated by address",
          route: "/addresses/:address_hash/blocks-validated",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get validated blocks", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTokenBalances: {
          requestMethod: "GET",
          description: "Token balances grouped",
          route: "/addresses/:address_hash/tokens",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Grouped token balances", chainName: "LUKSO_TESTNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getFlatTokenBalances: {
          requestMethod: "GET",
          description: "All token balances (flat)",
          route: "/addresses/:address_hash/token-balances",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Flat token balances", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getCoinBalanceHistory: {
          requestMethod: "GET",
          description: "Native coin balance history",
          route: "/addresses/:address_hash/coin-balance-history",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get coin balance history", chainName: "LUKSO_TESTNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getCoinBalanceByDay: {
          requestMethod: "GET",
          description: "Daily coin balance history",
          route: "/addresses/:address_hash/coin-balance-history-by-day",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Daily balance history", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        }
        /* stream timeout
              getWithdrawals: {
                requestMethod: "GET",
                description: "Get withdrawals for address",
                route: "/addresses/:address_hash/withdrawals",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } },
                  { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
                ],
                tests: [
                  { _description: "Get withdrawals", chainName: "LUKSO_MAINNET", address_hash: "0xf2f5fD1b32E4ffceA38e5fcC49D50ae91364A4BB" }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              }
        */
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          payload.url = payload.url.replace("--chain--", alias[userParams.chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/blocks.mjs
var blocks_exports = {};
__export(blocks_exports, {
  schema: () => schema58
});
var schema58;
var init_blocks = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/blocks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema58 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout Blocks",
      description: "Retrieve blocks and related data from LUKSO BlockScout",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        getBlocks: {
          requestMethod: "GET",
          description: "List recent blocks (optional filtering)",
          route: "/blocks",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "List all blocks on mainnet", chainName: "LUKSO_MAINNET" },
            { _description: "List uncle blocks on testnet", chainName: "LUKSO_TESTNET", type: "uncle" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getBlockById: {
          requestMethod: "GET",
          description: "Get detailed info for a block",
          route: "/blocks/:block_id",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "block_id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get block by hash", chainName: "LUKSO_MAINNET", block_id: "345678" },
            { _description: "Get block by number", chainName: "LUKSO_TESTNET", block_id: "1234567" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getBlockTransactions: {
          requestMethod: "GET",
          description: "Get transactions within a block",
          route: "/blocks/:block_id/transactions",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "block_id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get block txs by number", chainName: "LUKSO_MAINNET", block_id: "1234567" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getBlockWithdrawals: {
          requestMethod: "GET",
          description: "Get withdrawals from a block",
          route: "/blocks/:block_id/withdrawals",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "block_id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get withdrawals from block", chainName: "LUKSO_TESTNET", block_id: "1234567" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        }
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          payload.url = payload.url.replace("--chain--", alias[userParams.chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/graphql.mjs
var graphql_exports = {};
__export(graphql_exports, {
  schema: () => schema59
});
var schema59;
var init_graphql = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/graphql.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema59 = {
      namespace: "luksoNetwork",
      name: "LuksoMainnetSubgraph",
      description: "Query the Lukso Mainnet GraphQL endpoint.",
      docs: ["https://explorer.execution.testnet.lukso.network/graphiql", "https://explorer.execution.mainnet.lukso.network/graphiql"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.mainnet.lukso.network/api",
      requiredServerParams: [],
      headers: {},
      routes: {
        getLuksoExplorerSchema: {
          requestMethod: "POST",
          description: "Execute a GraphQL query against the LUKSO mainnet subgraph.",
          route: "/v1/graphql",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Simple entity fetch", query: "query { _meta { block { number } } }" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertQuery" },
            { phase: "post", handlerName: "getLuksoExplorerSchema" }
          ]
        },
        fectchLuksoExplorer: {
          requestMethod: "POST",
          description: "Run a raw GraphQL query on a lukso explorer.",
          route: "/v1/graphql",
          parameters: [
            {
              position: { key: "query", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "string()", options: [] }
            }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ],
          tests: [
            {
              _description: "Sample query for entity data",
              "query": 'query { transaction(hash: "0x4bfc02eff230de3ae789102369bc302569ed23822f9cb253af9020851e7766ac") { hash fromAddressHash toAddressHash value gasUsed status blockNumber } }'
            }
          ]
        }
      },
      handlers: {
        insertQuery: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const query = `
              query IntrospectionQuery {
                __schema {
                  types {
                    name
                    kind
                    fields {
                      name
                    }
                  }
                }
              }
            `;
          payload["body"] = { query };
          return { struct, payload };
        }, "insertQuery"),
        getLuksoExplorerSchema: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const data = struct?.data?.data || {};
          if (!data.__schema) {
            struct.status = false;
            struct.messages = ["No schema returned."];
          } else {
            struct.status = true;
            struct.data = data.__schema;
          }
          return { struct, payload };
        }, "getLuksoExplorerSchema"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"]?.errors) {
            struct.status = false;
            struct.messages = struct["data"]?.errors.map((e) => e.message);
          }
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/internal.mjs
var internal_exports = {};
__export(internal_exports, {
  schema: () => schema60
});
var schema60;
var init_internal = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/internal.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema60 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout Meta",
      description: "Main page, config, health and Celestia-specific endpoints",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        getMainPageTransactions: {
          requestMethod: "GET",
          description: "Latest transactions for main page",
          route: "/main-page/transactions",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } }
          ],
          tests: [
            { _description: "Main page txs", chainName: "LUKSO_MAINNET" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getMainPageBlocks: {
          requestMethod: "GET",
          description: "Latest blocks for main page",
          route: "/main-page/blocks",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } }
          ],
          tests: [
            { _description: "Main page blocks", chainName: "LUKSO_TESTNET" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        }
        /* wrong swagger file
              getIndexingStatus: {
                requestMethod: "GET",
                description: "Indexing status for main page",
                route: "/main-page/indexing-status",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } }
                ],
                tests: [
                  { _description: "Indexing status", chainName: "LUKSO_MAINNET" }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              },
              getRpcUrl: {
                requestMethod: "GET",
                description: "Current RPC config endpoint",
                route: "/config/json-rpc-url",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } }
                ],
                tests: [
                  { _description: "Fetch RPC URL", chainName: "LUKSO_TESTNET" }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              },
              getHealth: {
                requestMethod: "GET",
                description: "API health status",
                route: "/health",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } }
                ],
                tests: [
                  { _description: "Health check", chainName: "LUKSO_MAINNET" }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              },
              getAccountAbstractionStatus: {
                requestMethod: "GET",
                description: "Account abstraction status proxy",
                route: "/proxy/account-abstraction/status",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } }
                ],
                tests: [
                  { _description: "AA status", chainName: "LUKSO_MAINNET" }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              },
              getCelestiaBlob: {
                requestMethod: "GET",
                description: "Get Celestia blob data",
                route: "/api/v1/celestia/blob",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } }
                ],
                tests: [
                  { _description: "Celestia blob", chainName: "LUKSO_TESTNET" }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              },
              getL2BatchMetadata: {
                requestMethod: "GET",
                description: "Celestia L2 batch metadata",
                route: "/api/v1/celestia/l2BatchMetadata",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } }
                ],
                tests: [
                  { _description: "L2 batch metadata", chainName: "LUKSO_MAINNET" }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              }
        */
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          payload.url = payload.url.replace("--chain--", alias[userParams.chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["status"] === false) {
            console.log(struct["messages"]);
          }
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/nfts.mjs
var nfts_exports = {};
__export(nfts_exports, {
  schema: () => schema61
});
var schema61;
var init_nfts = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/nfts.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema61 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout NFTs",
      description: "Query NFTs owned by address or smart contract",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        getNFTsByAddress: {
          requestMethod: "GET",
          description: "NFTs owned by address",
          route: "/addresses/:address_hash/nft",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get NFTs for address", chainName: "LUKSO_MAINNET", address_hash: "0xC15509fDB3616FdE248d56122138f2F7C122a123" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getNFTCollectionsByAddress: {
          requestMethod: "GET",
          description: "NFTs grouped by collection",
          route: "/addresses/:address_hash/nft/collections",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get NFT collections", chainName: "LUKSO_MAINNET", address_hash: "0xC15509fDB3616FdE248d56122138f2F7C122a123" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getNFTInstancesByContract: {
          requestMethod: "GET",
          description: "List all NFT instances in contract",
          route: "/tokens/:address_hash/instances",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get NFT instances", chainName: "LUKSO_MAINNET", address_hash: "0x4c1dFFd1F59A01Ff7FBe5dabFA4484F3CD50E9CD" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getNFTInstanceById: {
          requestMethod: "GET",
          description: "Get one NFT by ID",
          route: "/tokens/:address_hash/instances/:id",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "number()", options: [] } }
          ],
          tests: [
            { _description: "Get NFT instance by ID", chainName: "LUKSO_MAINNET", address_hash: "0x4c1dFFd1F59A01Ff7FBe5dabFA4484F3CD50E9CD", id: 32 }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getNFTInstanceTransfers: {
          requestMethod: "GET",
          description: "Transfers of a specific NFT",
          route: "/tokens/:address_hash/instances/:id/transfers",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "number()", options: [] } }
          ],
          tests: [
            { _description: "Get NFT transfers", chainName: "LUKSO_MAINNET", address_hash: "0x4c1dFFd1F59A01Ff7FBe5dabFA4484F3CD50E9CD", id: 32 }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getNFTInstanceHolders: {
          requestMethod: "GET",
          description: "Get holders of an NFT instance",
          route: "/tokens/:address_hash/instances/:id/holders",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "number()", options: [] } }
          ],
          tests: [
            { _description: "Get NFT holders", chainName: "LUKSO_MAINNET", address_hash: "0x4c1dFFd1F59A01Ff7FBe5dabFA4484F3CD50E9CD", id: 32 }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getNFTInstanceTransfersCount: {
          requestMethod: "GET",
          description: "Count transfers of an NFT instance",
          route: "/tokens/:address_hash/instances/:id/transfers-count",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "number()", options: [] } }
          ],
          tests: [
            { _description: "Get NFT transfer count", chainName: "LUKSO_TESTNET", address_hash: "0x4c1dFFd1F59A01Ff7FBe5dabFA4484F3CD50E9CD", id: 32 }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        }
        /*
              refetchNFTMetadata: {
                requestMethod: "PATCH",
                description: "Force metadata re-fetch",
                route: "/tokens/:address_hash/instances/:id/refetch-metadata",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } },
                  { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
                  { position: { key: "id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "number()", options: [] } }
                ],
                tests: [
                  { _description: "Trigger NFT metadata update", chainName: "LUKSO_TESTNET", address_hash: "0x80D898C5A3A0B118a0c8C8aDcdBB260FC687F1ce", id: 1 }
                ],
                modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
              }
        */
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          payload.url = payload.url.replace("--chain--", alias[userParams.chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/search.mjs
var search_exports = {};
__export(search_exports, {
  schema: () => schema62
});
var schema62;
var init_search = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/search.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema62 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout Search",
      description: "Search and redirect endpoints from LUKSO BlockScout API",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        search: {
          requestMethod: "GET",
          description: "Search across tokens, addresses, blocks and transactions",
          route: "/search",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "search_query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Search for USDT on mainnet", chainName: "LUKSO_MAINNET", search_query: "USDT" },
            { _description: "Search for LYX on testnet", chainName: "LUKSO_TESTNET", search_query: "LYX" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        searchRedirect: {
          requestMethod: "GET",
          description: "Check if search redirects to a specific resource",
          route: "/search/check-redirect",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "search_query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Redirect check for USDT", chainName: "LUKSO_MAINNET", search_query: "USDT" },
            { _description: "Redirect check for LYX", chainName: "LUKSO_TESTNET", search_query: "LYX" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = {
            "LUKSO_MAINNET": "mainnet",
            "LUKSO_TESTNET": "testnet"
          };
          const { chainName } = userParams;
          const chain = alias[chainName];
          payload["url"] = payload["url"].replace("search_query=", "q=").replace("--chain--", chain);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/sourceCode.mjs
var sourceCode_exports = {};
__export(sourceCode_exports, {
  schema: () => schema63
});
var schema63;
var init_sourceCode = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/sourceCode.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema63 = {
      namespace: "luksoNetwork",
      name: "Contract",
      description: "API for interacting with smart contract metadata and state on LUKSO chains.",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api",
      requiredServerParams: [],
      headers: {},
      routes: {
        listcontracts: {
          requestMethod: "GET",
          description: "List sorted contracts, optionally filtered.",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "listcontracts", location: "query" } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "offset", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "filter", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(verified,unverified,empty,1,2,3)", options: ["optional()"] } },
            { position: { key: "verified_at_start_timestamp", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "verified_at_end_timestamp", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "List verified contracts", chainName: "LUKSO_MAINNET", page: 1, offset: 10, filter: "verified" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "defaultHandler" }
          ]
        },
        getabi: {
          requestMethod: "GET",
          description: "Get ABI for a verified contract.",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getabi", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get ABI for known address", chainName: "LUKSO_MAINNET", address: "0xd9db270c1b5e3bd161e8c8503c55ceabee709552" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "defaultHandler" }
          ]
        },
        getsourcecode: {
          requestMethod: "GET",
          description: "Get contract source code.",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getsourcecode", location: "query" } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Fetch source code for contract", chainName: "LUKSO_MAINNET", address: "0xd9db270c1b5e3bd161e8c8503c55ceabee709552" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "defaultHandler" }
          ]
        },
        getcontractcreation: {
          requestMethod: "GET",
          description: "Get contract creator and creation tx hash.",
          route: "/",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "module", value: "contract", location: "query" } },
            { position: { key: "action", value: "getcontractcreation", location: "query" } },
            { position: { key: "contractaddresses", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get creation data for contracts", chainName: "LUKSO_MAINNET", contractaddresses: "0xd9db270c1b5e3bd161e8c8503c55ceabee709552" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "defaultHandler" }
          ]
        }
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          payload["url"] = payload["url"].replace("--chain--", alias[userParams.chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        defaultHandler: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"]?.message !== "OK") {
            struct["messages"].push(struct["data"]?.message);
            struct["status"] = false;
          } else if (typeof struct["data"]?.message) {
            struct["data"] = struct["data"]?.result;
          }
          return { struct, payload };
        }, "defaultHandler")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/stats.mjs
var stats_exports = {};
__export(stats_exports, {
  schema: () => schema64
});
var schema64;
var init_stats = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/stats.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema64 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout Statistics",
      description: "Charts and blockchain stats from LUKSO BlockScout",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        getStats: {
          requestMethod: "GET",
          description: "General blockchain stats",
          route: "/stats",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } }
          ],
          tests: [
            { _description: "Fetch general stats", chainName: "LUKSO_MAINNET" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTransactionChart: {
          requestMethod: "GET",
          description: "Transaction activity chart",
          route: "/stats/charts/transactions",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } }
          ],
          tests: [
            { _description: "Get tx chart", chainName: "LUKSO_TESTNET" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getMarketChart: {
          requestMethod: "GET",
          description: "Token market stats (price, cap, etc.)",
          route: "/stats/charts/market",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } }
          ],
          tests: [
            { _description: "Get market chart", chainName: "LUKSO_MAINNET" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        }
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          payload.url = payload.url.replace("--chain--", alias[userParams.chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/tokens.mjs
var tokens_exports = {};
__export(tokens_exports, {
  schema: () => schema65
});
var schema65;
var init_tokens = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/tokens.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema65 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout Tokens",
      description: "Token-related endpoints for transfers, holders, and stats",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        listTokens: {
          requestMethod: "GET",
          description: "List all tokens",
          route: "/tokens",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } }
          ],
          tests: [
            { _description: "List tokens on mainnet", chainName: "LUKSO_MAINNET" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTokenByAddress: {
          requestMethod: "GET",
          description: "Get token metadata",
          route: "/tokens/:address_hash",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Token metadata (LYX)", chainName: "LUKSO_MAINNET", address_hash: "0x6E55472109E6aBE4054a8E8b8d9EdFfCb31032C5" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTokenTransfersByAddress: {
          requestMethod: "GET",
          description: "Token transfer history",
          route: "/tokens/:address_hash/transfers",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Token transfers (LYX)", chainName: "LUKSO_MAINNET", address_hash: "0x6E55472109E6aBE4054a8E8b8d9EdFfCb31032C5" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTokenHolders: {
          requestMethod: "GET",
          description: "List token holders",
          route: "/tokens/:address_hash/holders",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Token holders (LYX)", chainName: "LUKSO_MAINNET", address_hash: "0x6E55472109E6aBE4054a8E8b8d9EdFfCb31032C5" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTokenCounters: {
          requestMethod: "GET",
          description: "Token analytics counters",
          route: "/tokens/:address_hash/counters",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "address_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Token counters (LYX)", chainName: "LUKSO_MAINNET", address_hash: "0x6E55472109E6aBE4054a8E8b8d9EdFfCb31032C5" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        }
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          payload.url = payload.url.replace("--chain--", alias[userParams.chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/lukso-network/transactions.mjs
var transactions_exports = {};
__export(transactions_exports, {
  schema: () => schema66
});
var schema66;
var init_transactions = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/lukso-network/transactions.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema66 = {
      namespace: "luksoNetwork",
      name: "LUKSO BlockScout Transactions",
      description: "Fetch transactions and their associated data from LUKSO BlockScout",
      docs: ["https://explorer.execution.mainnet.lukso.network/api-docs", "https://explorer.execution.testnet.lukso.network/api-docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://explorer.execution.--chain--.lukso.network/api/v2",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTransactions: {
          requestMethod: "GET",
          description: "List transactions (filterable)",
          route: "/transactions",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get all transactions from mainnet", chainName: "LUKSO_MAINNET" },
            { _description: "Get token_transfer transactions from testnet", chainName: "LUKSO_TESTNET", type: "token_transfer" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTransactionByHash: {
          requestMethod: "GET",
          description: "Details of a transaction",
          route: "/transactions/:transaction_hash",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{64}$)"] } }
          ],
          tests: [
            { _description: "Get transaction on mainnet", chainName: "LUKSO_MAINNET", transaction_hash: "0x4937ac5bc88a00d9037dcfeca0baf3de468d3983ff5755925956f004fca670f9" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getTokenTransfersByTransactionHash: {
          requestMethod: "GET",
          description: "Token transfers in transaction",
          route: "/transactions/:transaction_hash/token-transfers",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{64}$)"] } }
          ],
          tests: [
            { _description: "Token transfers for transaction", chainName: "LUKSO_MAINNET", transaction_hash: "0x4937ac5bc88a00d9037dcfeca0baf3de468d3983ff5755925956f004fca670f9" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getInternalTransactions: {
          requestMethod: "GET",
          description: "Internal txs in transaction",
          route: "/transactions/:transaction_hash/internal-transactions",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{64}$)"] } }
          ],
          tests: [
            { _description: "Internal txs for transaction", chainName: "LUKSO_MAINNET", transaction_hash: "0x4937ac5bc88a00d9037dcfeca0baf3de468d3983ff5755925956f004fca670f9" }
          ],
          modifiers: [{ phase: "pre", handlerName: "modifyQuery" }, { phase: "post", handlerName: "modifyResult" }]
        },
        getLogs: {
          requestMethod: "GET",
          description: "Logs from transaction",
          route: "/transactions/:transaction_hash/logs",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{64}$)"] } }
          ],
          tests: [
            { _description: "Get logs for transaction", chainName: "LUKSO_MAINNET", transaction_hash: "0x19a669843e97836b68b75327041e12d5ee91788430337ad0e8158e56fa824b61" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getRawTrace: {
          requestMethod: "GET",
          description: "Raw trace of transaction",
          route: "/transactions/:transaction_hash/raw-trace",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{64}$)"] } }
          ],
          tests: [
            { _description: "Get raw trace", chainName: "LUKSO_MAINNET", transaction_hash: "0x4937ac5bc88a00d9037dcfeca0baf3de468d3983ff5755925956f004fca670f9" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getStateChanges: {
          requestMethod: "GET",
          description: "State changes in transaction",
          route: "/transactions/:transaction_hash/state-changes",
          parameters: [
            { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(LUKSO_MAINNET,LUKSO_TESTNET)", options: [] } },
            { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{64}$)"] } }
          ],
          tests: [
            { _description: "Get state changes", chainName: "LUKSO_MAINNET", transaction_hash: "0x4937ac5bc88a00d9037dcfeca0baf3de468d3983ff5755925956f004fca670f9" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyQuery" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
        /* Service unavailable
              getTransactionSummary: {
                requestMethod: "GET",
                description: "Human-readable summary",
                route: "/transactions/:transaction_hash/summary",
                parameters: [
                  { position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["enum(LUKSO_MAINNET,LUKSO_TESTNET)"] } },
                  { position: { key: "transaction_hash", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{64}$)"] } }
                ],
                tests: [
                  { _description: "Get tx summary", chainName: "LUKSO_MAINNET", transaction_hash: "0x4937ac5bc88a00d9037dcfeca0baf3de468d3983ff5755925956f004fca670f9" }
                ],
                modifiers: [
                    { phase: "pre", handlerName: "modifyQuery" }, 
                    { phase: "post", handlerName: "modifyResult" }
                ]
              }
        */
      },
      handlers: {
        modifyQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const alias = { LUKSO_MAINNET: "mainnet", LUKSO_TESTNET: "testnet" };
          const { chainName } = userParams;
          payload["url"] = payload["url"].replace("--chain--", alias[chainName]);
          return { struct, payload };
        }, "modifyQuery"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/medium-com/rss-feeds.mjs
var rss_feeds_exports = {};
__export(rss_feeds_exports, {
  schema: () => schema67
});
var schema67;
var init_rss_feeds = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/medium-com/rss-feeds.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema67 = {
      namespace: "medium",
      name: "Medium RSS Feeds",
      description: "Access Medium articles and posts via RSS feeds by tag, user, or publication",
      docs: ["https://help.medium.com/hc/en-us/articles/214874118-RSS-feeds"],
      tags: ["content", "social", "feeds"],
      flowMCP: "1.2.0",
      root: "https://medium.com/feed",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTagFeed: {
          requestMethod: "GET",
          description: "Get RSS feed for articles with a specific tag",
          route: "/tag/:tag",
          parameters: [
            { position: { key: "tag", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get articles tagged with bitcoin", tag: "bitcoin" },
            { _description: "Get articles tagged with artificial-intelligence", tag: "artificial-intelligence" },
            { _description: "Get articles tagged with programming", tag: "programming" }
          ],
          modifiers: [{ phase: "execute", handlerName: "parseRSSFeed" }]
        },
        getUserFeed: {
          requestMethod: "GET",
          description: "Get RSS feed for a specific Medium user's articles",
          route: "/@:username",
          parameters: [
            { position: { key: "username", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get articles from a specific user", username: "medium" },
            { _description: "Get articles from another user", username: "towardsdatascience" }
          ],
          modifiers: [{ phase: "execute", handlerName: "parseRSSFeed" }]
        },
        getPublicationFeed: {
          requestMethod: "GET",
          description: "Get RSS feed for a specific Medium publication",
          route: "/:publication",
          parameters: [
            { position: { key: "publication", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "Get articles from Towards Data Science", publication: "towards-data-science" },
            { _description: "Get articles from The Startup", publication: "swlh" },
            { _description: "Get articles from Better Programming", publication: "better-programming" }
          ],
          modifiers: [{ phase: "execute", handlerName: "parseRSSFeed" }]
        },
        getTopicFeed: {
          requestMethod: "GET",
          description: "Get RSS feed for a specific Medium topic",
          route: "/topic/:topic",
          parameters: [
            { position: { key: "topic", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "enum(technology,programming,data-science,artificial-intelligence,machine-learning,blockchain,cryptocurrency,startup,business,design,ux,ui,marketing,science,health,politics,culture,sports,entertainment,travel,food,lifestyle)", options: [] } }
          ],
          tests: [
            { _description: "Get technology topic feed", topic: "technology" },
            { _description: "Get programming topic feed", topic: "programming" },
            { _description: "Get blockchain topic feed", topic: "blockchain" }
          ],
          modifiers: [{ phase: "execute", handlerName: "parseRSSFeed" }]
        }
      },
      handlers: {
        parseRSSFeed: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          try {
            const response = await fetch(payload.url);
            if (!response.ok) {
              struct.status = false;
              struct.messages.push(`HTTP ${response.status}: ${response.statusText}`);
              return { struct, payload };
            }
            const xmlText = await response.text();
            const itemRegex = /<item>(.*?)<\/item>/gs;
            const titleRegex = /<title><!\[CDATA\[(.*?)\]\]><\/title>/s;
            const linkRegex = /<link>(.*?)<\/link>/s;
            const pubDateRegex = /<pubDate>(.*?)<\/pubDate>/s;
            const descriptionRegex = /<description><!\[CDATA\[(.*?)\]\]><\/description>/s;
            const creatorRegex = /<dc:creator><!\[CDATA\[(.*?)\]\]><\/dc:creator>/s;
            const categoryRegex = /<category><!\[CDATA\[(.*?)\]\]><\/category>/gs;
            const items = [];
            let match;
            while ((match = itemRegex.exec(xmlText)) !== null) {
              const itemXml = match[1];
              const titleMatch = titleRegex.exec(itemXml);
              const linkMatch = linkRegex.exec(itemXml);
              const pubDateMatch = pubDateRegex.exec(itemXml);
              const descriptionMatch = descriptionRegex.exec(itemXml);
              const creatorMatch = creatorRegex.exec(itemXml);
              const categories = [];
              let categoryMatch;
              while ((categoryMatch = categoryRegex.exec(itemXml)) !== null) {
                categories.push(categoryMatch[1]);
              }
              const item = {
                title: titleMatch ? titleMatch[1] : null,
                link: linkMatch ? linkMatch[1] : null,
                pubDate: pubDateMatch ? pubDateMatch[1] : null,
                description: descriptionMatch ? descriptionMatch[1].replace(/<[^>]*>/g, "").substring(0, 200) + "..." : null,
                author: creatorMatch ? creatorMatch[1] : null,
                categories
              };
              items.push(item);
            }
            struct.data = {
              source: "Medium",
              feedUrl: payload.url,
              itemCount: items.length,
              items
            };
          } catch (error42) {
            struct.status = false;
            struct.messages.push(`Error parsing RSS feed: ${error42.message}`);
          }
          return { struct, payload };
        }, "parseRSSFeed")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/memory-lol/twitterNameChanges.mjs
var twitterNameChanges_exports = {};
__export(twitterNameChanges_exports, {
  schema: () => schema68
});
var schema68;
var init_twitterNameChanges = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/memory-lol/twitterNameChanges.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema68 = {
      namespace: "memoryLol",
      name: "TwitterUsernameChanges",
      description: "Get Twitter username change history via memory.lol API.",
      docs: ["https://github.com/travisbrown/memory.lol"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.memory.lol",
      requiredServerParams: [],
      headers: {},
      routes: {
        queryUsernameChanges: {
          requestMethod: "GET",
          description: "Fetch username change history for a Twitter user.",
          route: "/v1/tw/:screen_name",
          parameters: [
            {
              position: { key: "screen_name", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^[A-Za-z0-9_]{1,15}$)"] }
            }
          ],
          tests: [
            { _description: "Valid handle", screen_name: "OSINT_Ukraine" },
            { _description: "Non-existent handle", screen_name: "no_user_123456" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatHistory" }
          ]
        }
      },
      handlers: {
        formatHistory: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const { data } = struct;
          if (!data.accounts?.length) {
            struct.data = "No username change history found.";
            return { struct, payload };
          }
          struct.data = data.accounts.map(
            (acc) => `User ID ${acc.id_str}:
` + Object.entries(acc.screen_names).map(([name17, dates]) => `- ${name17} (${Array.isArray(dates) ? dates.join(" to ") : dates})`).join("\n")
          ).join("\n\n");
          return { struct, payload };
        }, "formatHistory")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/minascan-io/mina-devnet.mjs
var mina_devnet_exports = {};
__export(mina_devnet_exports, {
  schema: () => schema69
});
var schema69;
var init_mina_devnet = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/minascan-io/mina-devnet.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema69 = {
      namespace: "minascanDevnet",
      name: "MinaScan Devnet GraphQL API",
      description: "Access Mina Protocol devnet blockchain data through MinaScan's GraphQL endpoint.",
      docs: ["https://api.minascan.io", "https://minaprotocol.com"],
      tags: ["production", "blockchain", "explorer", "mina"],
      flowMCP: "1.2.0",
      root: "https://api.minascan.io/node/devnet/v1/graphql",
      requiredServerParams: [],
      headers: { "Content-Type": "application/json" },
      routes: {
        getMinaDevnetSchema: {
          requestMethod: "POST",
          description: "Get the complete GraphQL schema structure from MinaScan devnet endpoint.",
          route: "/",
          parameters: [],
          tests: [
            { _description: "Fetch MinaScan devnet GraphQL schema introspection" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetSchemaQuery" }
          ]
        },
        getMinaDevnetQuery: {
          requestMethod: "POST",
          description: "Execute a custom GraphQL query against the MinaScan devnet endpoint.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get network sync status", query: "{ syncStatus daemonStatus { chainId blockchainLength uptimeSecs stateHash } }" },
            { _description: "Get best chain blocks", query: "{ bestChain(maxLength: 3) { stateHash protocolState { consensusState { blockHeight } } } }" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildCustomQuery" }
          ]
        }
      },
      handlers: {
        buildGetSchemaQuery: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          payload.body = {
            query: `query IntrospectionQuery {
  __schema {
    queryType {
      name
      fields {
        name
        description
        type {
          name
          kind
          ofType {
            name
            kind
          }
        }
        args {
          name
          description
          type {
            name
            kind
            ofType {
              name
              kind
            }
          }
          defaultValue
        }
      }
    }
    types {
      kind
      name
      description
      fields {
        name
        description
        type {
          name
          kind
          ofType {
            name
            kind
          }
        }
      }
    }
  }
}`
          };
          return { struct, payload };
        }, "buildGetSchemaQuery"),
        buildCustomQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { query } = userParams;
          payload.body = {
            query
          };
          return { struct, payload };
        }, "buildCustomQuery")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/minascan-io/mina-mainnet.mjs
var mina_mainnet_exports2 = {};
__export(mina_mainnet_exports2, {
  schema: () => schema70
});
var schema70;
var init_mina_mainnet2 = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/minascan-io/mina-mainnet.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema70 = {
      namespace: "minascanMainnet",
      name: "MinaScan Mainnet GraphQL API",
      description: "Access Mina Protocol mainnet blockchain data through MinaScan's GraphQL endpoint.",
      docs: ["https://api.minascan.io", "https://minaprotocol.com"],
      tags: ["production", "blockchain", "explorer", "mina"],
      flowMCP: "1.2.0",
      root: "https://api.minascan.io/node/mainnet/v1/graphql",
      requiredServerParams: [],
      headers: { "Content-Type": "application/json" },
      routes: {
        getMinaMainnetSchema: {
          requestMethod: "POST",
          description: "Get the complete GraphQL schema structure from MinaScan mainnet endpoint.",
          route: "/",
          parameters: [],
          tests: [
            { _description: "Fetch MinaScan mainnet GraphQL schema introspection" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildGetSchemaQuery" }
          ]
        },
        getMinaMainnetQuery: {
          requestMethod: "POST",
          description: "Execute a custom GraphQL query against the MinaScan mainnet endpoint.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get mainnet sync status", query: "{ syncStatus daemonStatus { chainId blockchainLength uptimeSecs stateHash } }" },
            { _description: "Get mainnet best chain blocks", query: "{ bestChain(maxLength: 3) { stateHash protocolState { consensusState { blockHeight } } } }" },
            { _description: "Get mainnet genesis constants", query: "{ genesisConstants { accountCreationFee coinbase } }" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildCustomQuery" }
          ]
        }
      },
      handlers: {
        buildGetSchemaQuery: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          payload.body = {
            query: `query IntrospectionQuery {
  __schema {
    queryType {
      name
      fields {
        name
        description
        type {
          name
          kind
          ofType {
            name
            kind
          }
        }
        args {
          name
          description
          type {
            name
            kind
            ofType {
              name
              kind
            }
          }
          defaultValue
        }
      }
    }
    types {
      kind
      name
      description
      fields {
        name
        description
        type {
          name
          kind
          ofType {
            name
            kind
          }
        }
      }
    }
  }
}`
          };
          return { struct, payload };
        }, "buildGetSchemaQuery"),
        buildCustomQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { query } = userParams;
          payload.body = {
            query
          };
          return { struct, payload };
        }, "buildCustomQuery")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/blockchainApi.mjs
var blockchainApi_exports = {};
__export(blockchainApi_exports, {
  schema: () => schema71
});
var schema71;
var init_blockchainApi = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/blockchainApi.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema71 = {
      "namespace": "moralis",
      "name": "Moralis blockchainApi API",
      "description": "Moralis blockchainApi API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        "/block/:block_number_or_hash": {
          "requestMethod": "GET",
          "description": "Get the contents of a block given the block hash.",
          "route": "/block/:block_number_or_hash",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "include", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(internal_transactions)", "options": ["optional()"] } },
            { "position": { "key": "block_number_or_hash", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            {
              "_description": "Get the contents of a block given the block hash.",
              "chain": "eth",
              "block_number_or_hash": "18541416"
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        },
        "/dateToBlock": {
          "requestMethod": "GET",
          "description": "Get the closest block given the date.",
          "route": "/dateToBlock",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            {
              "_description": "Get the closest block given the date.",
              "chain": "eth",
              "date": "1745607154"
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        },
        "/transaction/:transaction_hash/verbose": {
          "requestMethod": "GET",
          "description": "Get the contents of a transaction by the given transaction hash.",
          "route": "/transaction/:transaction_hash/verbose",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "include", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(internal_transactions)", "options": ["optional()"] } },
            { "position": { "key": "transaction_hash", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            {
              "_description": "Get the contents of a transaction by the given transaction hash.",
              "chain": "eth",
              "transaction_hash": "0xfeda0e8f0d6e54112c28d319c0d303c065d1125c9197bd653682f5fcb0a6c81e"
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        },
        "/:address/verbose": {
          "requestMethod": "GET",
          "description": "Get native transactions and logs ordered by block number in descending order.",
          "route": "/:address/verbose",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "include", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(internal_transactions)", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            {
              "_description": "Get native transactions and logs ordered by block number in descending order.",
              "chain": "eth",
              "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326"
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        },
        "/latestBlockNumber/:chain": {
          "requestMethod": "GET",
          "description": "Returns the latest block number for the given chain.",
          "route": "/latestBlockNumber/:chain",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } }
          ],
          "tests": [
            { "_description": "Returns the latest block number for the given chain.", "chain": "eth" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/transaction/:transaction_hash": {
          "requestMethod": "GET",
          "description": "Get the contents of a transaction by the given transaction hash.",
          "route": "/transaction/:transaction_hash",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "include", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(internal_transactions)", "options": ["optional()"] } },
            { "position": { "key": "transaction_hash", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            {
              "_description": "Get the contents of a transaction by the given transaction hash.",
              "chain": "eth",
              "transaction_hash": "0xfeda0e8f0d6e54112c28d319c0d303c065d1125c9197bd653682f5fcb0a6c81e"
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        },
        "/:address": {
          "requestMethod": "GET",
          "description": "Get native transactions ordered by block number in descending order.",
          "route": "/:address",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "include", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(internal_transactions)", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get native transactions ordered by block number in descending order.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/defiApi.mjs
var defiApi_exports = {};
__export(defiApi_exports, {
  schema: () => schema72
});
var schema72;
var init_defiApi = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/defiApi.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema72 = {
      "namespace": "moralis",
      "name": "Moralis defiApi API",
      "description": "Moralis defiApi API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        "/wallets/:address/defi/:protocol/positions": {
          "requestMethod": "GET",
          "description": "Get the detailed defi positions by protocol for a wallet address.",
          "route": "/wallets/:address/defi/:protocol/positions",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,polygon,0x89,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,chiliz,0x15b38,chiliz testnet,0x15b32,gnosis,0x64,gnosis testnet,0x27d8,base,0x2105,base sepolia,0x14a34,optimism,0xa,holesky,0x4268,polygon amoy,0x13882,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,linea sepolia,0xe705)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "protocol", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "enum(uniswap-v2,uniswap-v3,pancakeswap-v2,pancakeswap-v3,quickswap-v2,sushiswap-v2,aave-v2,aave-v3,fraxswap-v1,fraxswap-v2,lido,makerdao,eigenlayer)", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the detailed defi positions by protocol for a wallet address.", "chain": "eth", "address": "0xd100d8b69c5ae23d6aa30c6c3874bf47539b95fd", "protocol": "aave-v3" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/defi/positions": {
          "requestMethod": "GET",
          "description": "Get the positions summary of a wallet address.",
          "route": "/wallets/:address/defi/positions",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,polygon,0x89,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,chiliz,0x15b38,chiliz testnet,0x15b32,gnosis,0x64,gnosis testnet,0x27d8,base,0x2105,base sepolia,0x14a34,optimism,0xa,holesky,0x4268,polygon amoy,0x13882,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,linea sepolia,0xe705)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the positions summary of a wallet address.", "chain": "eth", "address": "0xd100d8b69c5ae23d6aa30c6c3874bf47539b95fd" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/defi/summary": {
          "requestMethod": "GET",
          "description": "Get the defi summary of a wallet address.",
          "route": "/wallets/:address/defi/summary",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,polygon,0x89,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,chiliz,0x15b38,chiliz testnet,0x15b32,gnosis,0x64,gnosis testnet,0x27d8,base,0x2105,base sepolia,0x14a34,optimism,0xa,holesky,0x4268,polygon amoy,0x13882,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,linea sepolia,0xe705)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the defi summary of a wallet address.", "chain": "eth", "address": "0xd100d8b69c5ae23d6aa30c6c3874bf47539b95fd" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/entity.mjs
var entity_exports = {};
__export(entity_exports, {
  schema: () => schema73
});
var schema73;
var init_entity = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/entity.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema73 = {
      "namespace": "moralis",
      "name": "Moralis entity API",
      "description": "Moralis entity API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        "/entities/categories": {
          "requestMethod": "GET",
          "description": "Get Entity Categories",
          "route": "/entities/categories",
          "parameters": [
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } }
          ],
          "tests": [
            {
              "_description": "Get Entity Categories"
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/nftApi.mjs
var nftApi_exports = {};
__export(nftApi_exports, {
  schema: () => schema74
});
var schema74;
var init_nftApi = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/nftApi.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema74 = {
      "namespace": "moralis",
      "name": "Moralis nftApi API",
      "description": "Moralis nftApi API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        "/market-data/nfts/top-collections": {
          "requestMethod": "GET",
          "description": "Get the top NFT collections by market cap",
          "route": "/market-data/nfts/top-collections",
          "parameters": [],
          "tests": [
            { "_description": "Get the top NFT collections by market cap" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/market-data/nfts/hottest-collections": {
          "requestMethod": "GET",
          "description": "Get the top NFT collections by trading volume",
          "route": "/market-data/nfts/hottest-collections",
          "parameters": [],
          "tests": [
            { "_description": "Get the top NFT collections by trading volume" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address": {
          "requestMethod": "GET",
          "description": "Get NFTs for a given contract address, including metadata for all NFTs (where available).",
          "route": "/nft/:address",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "totalRanges", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "range", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "normalizeMetadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "media_items", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get NFTs for a given contract address, including metadata for all NFTs (where available).", "chain": "eth", "address": "0x306b1ea3ecdf94aB739F1910bbda052Ed4A9f949", "format": "decimal" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/stats": {
          "requestMethod": "GET",
          "description": "Get the stats for a nft collection address.",
          "route": "/nft/:address/stats",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the stats for a nft collection address.", "chain": "eth", "address": "0x306b1ea3ecdf94ab739f1910bbda052ed4a9f949" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/metadata": {
          "requestMethod": "GET",
          "description": "Get the collection / contract level metadata for a given contract (name, symbol, base token URI).",
          "route": "/nft/:address/metadata",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the collection / contract level metadata for a given contract.", "chain": "eth", "address": "0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        /*
        		"/nft/:address/price": 		{
        		    "requestMethod": "GET",
        		    "description": "Get the sold price for an NFT contract for the last x days (only trades paid in ETH).",
        		    "route": "/nft/:address/price",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,arbitrum,0xa4b1,base,0x2105,optimism,0xa)","options":[]}},
        				{"position":{"key":"days","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get the sold price for an NFT contract for the last x days.", "chain": "eth", "address": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        "/nft/:address/transfers": {
          "requestMethod": "GET",
          "description": "Get transfers of NFTs for a given contract and other parameters.",
          "route": "/nft/:address/transfers",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get transfers of NFTs for a given contract and other parameters.", "chain": "eth", "address": "0x306b1ea3ecdf94aB739F1910bbda052Ed4A9f949" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        /*
        		"/nft/:address/floor-price": 		{
        		    "requestMethod": "GET",
        		    "description": "Get floor price for a given contract.",
        		    "route": "/nft/:address/floor-price",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,base,0x2105)","options":[]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get floor price for a given contract.", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/nft/:address/:token_id/floor-price": 		{
        		    "requestMethod": "GET",
        		    "description": "Get floor price for a given token.",
        		    "route": "/nft/:address/:token_id/floor-price",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,base,0x2105)","options":[]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}},
        				{"position":{"key":"token_id","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get floor price.", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048", "token_id": "2441" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/nft/:address/floor-price/historical": 		{
        		    "requestMethod": "GET",
        		    "description": "Get historical floor price for a given contract.",
        		    "route": "/nft/:address/floor-price/historical",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,base,0x2105)","options":[]}},
        				{"position":{"key":"interval","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(1d,7d,30d,60d,90d,1y,all)","options":[]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get historical floor price.", "chain": "eth", "interval": "1d", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        "/nft/:address/:token_id": {
          "requestMethod": "GET",
          "description": "Get NFT data, including metadata (where available), for the given NFT token ID and contract address.",
          "route": "/nft/:address/:token_id",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(decimal,hex)", "options": ["optional()"] } },
            { "position": { "key": "normalizeMetadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "media_items", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "token_id", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get NFT data, including metadata (where available), for the given NFT token ID and contract address.", "chain": "eth", "address": "0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB", "token_id": "1" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/owners": {
          "requestMethod": "GET",
          "description": "Get owners of NFTs for a given contract.",
          "route": "/nft/:address/owners",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "normalizeMetadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "media_items", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get owners of NFTs for a given contract.", "chain": "eth", "address": "0x306b1ea3ecdf94aB739F1910bbda052Ed4A9f949" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        /*
        		"/nft/:address/:token_id/price": 		{
        		    "requestMethod": "GET",
        		    "description": "Get the sold price for an NFT token for the last x days (only trades paid in ETH).",
        		    "route": "/nft/:address/:token_id/price",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,arbitrum,0xa4b1,base,0x2105,optimism,0xa)","options":[]}},
        				{"position":{"key":"days","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}},
        				{"position":{"key":"token_id","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get the sold price for an NFT token for the last x days.", "chain": "eth", "address": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D", "token_id": "1" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        "/nft/:address/:token_id/owners": {
          "requestMethod": "GET",
          "description": "Get owners of a specific NFT given the contract address and token ID.",
          "route": "/nft/:address/:token_id/owners",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "normalizeMetadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "media_items", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "token_id", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get owners of a specific NFT given the contract address and token ID.", "chain": "eth", "address": "0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB", "token_id": "1" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/:token_id/trades": {
          "requestMethod": "GET",
          "description": "Get trades of NFTs for a given contract and token ID.",
          "route": "/nft/:address/:token_id/trades",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,arbitrum,0xa4b1,base,0x2105,optimism,0xa)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "nft_metadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "token_id", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get trades of NFTs for a given contract and token ID.", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048", "token_id": "123" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/nfts/trades": {
          "requestMethod": "GET",
          "description": "Get trades of NFTs for a given wallet.",
          "route": "/wallets/:address/nfts/trades",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,arbitrum,0xa4b1,base,0x2105,optimism,0xa)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "nft_metadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get trades of NFTs for a given wallet.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/trades": {
          "requestMethod": "GET",
          "description": "Get trades of NFTs for a given contract and marketplace.",
          "route": "/nft/:address/trades",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "marketplace", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "nft_metadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get trades of NFTs for a given contract and marketplace.", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/traits/paginate": {
          "requestMethod": "GET",
          "description": "Get NFT traits for a given collection",
          "route": "/nft/:address/traits/paginate",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get NFT traits for a given collection", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/traits": {
          "requestMethod": "GET",
          "description": "Get NFT traits for a given collection",
          "route": "/nft/:address/traits",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get NFT traits for a given collection", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/:token_id/transfers": {
          "requestMethod": "GET",
          "description": "Get transfers of an NFT given a contract address and token ID.",
          "route": "/nft/:address/:token_id/transfers",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "token_id", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get transfers of an NFT given a contract address and token ID.", "chain": "eth", "address": "0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB", "token_id": "1" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/:address/nft/collections": {
          "requestMethod": "GET",
          "description": "Get NFT collections owned by a given wallet address.",
          "route": "/:address/nft/collections",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "token_counts", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "exclude_spam", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get NFT ciollections owned by a given wallet address.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/:address/nft/transfers": {
          "requestMethod": "GET",
          "description": "Get transfers of NFTs given the wallet and other parameters.",
          "route": "/:address/nft/transfers",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "contract_addresses", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get transfers of NFTs given the wallet and other parameters.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/:address/nft": {
          "requestMethod": "GET",
          "description": "Get NFTs owned by a given address.",
          "route": "/:address/nft",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "format", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(decimal,hex)", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "exclude_spam", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "token_addresses", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "normalizeMetadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "media_items", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "include_prices", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get NFTs owned by a given address.", "chain": "eth", "address": "0xff3879b8a363aed92a6eaba8f61f1a96a9ec3c1e" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/:token_id/metadata/resync": {
          "requestMethod": "GET",
          "description": "Resync the metadata for an NFT",
          "route": "/nft/:address/:token_id/metadata/resync",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "flag", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(uri,metadata)", "options": ["optional()"] } },
            { "position": { "key": "mode", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(sync,async)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "token_id", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Resync the metadata for an NFT", "chain": "eth", "address": "0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB", "token_id": "1" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/traits/resync": {
          "requestMethod": "GET",
          "description": "Resync the NFT Trait for a given contract",
          "route": "/nft/:address/traits/resync",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Resync the NFT Trait for a given contract", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/priceApi.mjs
var priceApi_exports = {};
__export(priceApi_exports, {
  schema: () => schema75
});
var schema75;
var init_priceApi = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/priceApi.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema75 = {
      "namespace": "moralis",
      "name": "Moralis priceApi API",
      "description": "Moralis priceApi API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        "/nft/:address/price": {
          "requestMethod": "GET",
          "description": "Get the sold price for an NFT contract for the last x days (only trades paid in ETH).",
          "route": "/nft/:address/price",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,arbitrum,0xa4b1,base,0x2105,optimism,0xa)", "options": [] } },
            { "position": { "key": "days", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the sold price for an NFT contract for the last x days.", "chain": "eth", "address": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/floor-price": {
          "requestMethod": "GET",
          "description": "Get floor price for a given contract.",
          "route": "/nft/:address/floor-price",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,base,0x2105)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get floor price for a given contract.", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/:token_id/floor-price": {
          "requestMethod": "GET",
          "description": "Get floor price for a given token.",
          "route": "/nft/:address/:token_id/floor-price",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,base,0x2105)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "token_id", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get floor price.", "chain": "eth", "address": "0x524cab2ec69124574082676e6f654a18df49a048", "token_id": "2441" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/floor-price/historical": {
          "requestMethod": "GET",
          "description": "Get historical floor price for a given contract.",
          "route": "/nft/:address/floor-price/historical",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,base,0x2105)", "options": [] } },
            { "position": { "key": "interval", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(1d,7d,30d,60d,90d,1y,all)", "options": [] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get historical floor price.", "chain": "eth", "interval": "1d", "address": "0x524cab2ec69124574082676e6f654a18df49a048" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/nft/:address/:token_id/price": {
          "requestMethod": "GET",
          "description": "Get the sold price for an NFT token for the last x days (only trades paid in ETH).",
          "route": "/nft/:address/:token_id/price",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,arbitrum,0xa4b1,base,0x2105,optimism,0xa)", "options": [] } },
            { "position": { "key": "days", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "token_id", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the sold price for an NFT token for the last x days.", "chain": "eth", "address": "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D", "token_id": "1" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/pairs/:address/ohlcv": {
          "requestMethod": "GET",
          "description": "Get the OHLCV candle stick by using pair address",
          "route": "/pairs/:address/ohlcv",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "timeframe", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(1s,10s,30s,1min,5min,10min,30min,1h,4h,12h,1d,1w,1M)", "options": [] } },
            { "position": { "key": "currency", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(usd,native)", "options": [] } },
            { "position": { "key": "fromDate", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "toDate", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": [] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the OHLCV candle stick by using pair address", "chain": "eth", "timeframe": "1h", "currency": "usd", "fromDate": "2025-01-01T10:00:00.000", "toDate": "2025-01-02T10:00:00.000", "address": "0xa43fe16908251ee70ef74718545e4fe6c5ccec9f" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/erc20/:address/price": {
          "requestMethod": "GET",
          "description": "Get the token price denominated in the blockchain's native token and USD. View supported exchanges here",
          "route": "/erc20/:address/price",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,chiliz,0x15b38,base,0x2105,optimism,0xa,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,ronin,0x7e4,lisk,0x46f,pulse,0x171)", "options": [] } },
            { "position": { "key": "include", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(percent_change)", "options": ["optional()"] } },
            { "position": { "key": "exchange", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(uniswapv2,uniswapv3,sushiswapv2,pancakeswapv1,pancakeswapv2,pancakeswapv3,quickswap,quickswapv2,traderjoe,pangolin,spookyswap,vvs,mm finance,crodex,camelotv2)", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "max_token_inactivity", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "min_pair_side_liquidity_usd", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the token price denominated in the blockchain's native token and USD.", "chain": "eth", "address": "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/tokenApi.mjs
var tokenApi_exports = {};
__export(tokenApi_exports, {
  schema: () => schema76
});
var schema76;
var init_tokenApi = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/tokenApi.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema76 = {
      "namespace": "moralis",
      "name": "Moralis tokenApi API",
      "description": "Moralis tokenApi API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        /*
        		"/pairs/:address/ohlcv": 		{
        		    "requestMethod": "GET",
        		    "description": "Get the OHLCV candle stick by using pair address",
        		    "route": "/pairs/:address/ohlcv",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"timeframe","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(1s,10s,30s,1min,5min,10min,30min,1h,4h,12h,1d,1w,1M)","options":[]}},
        				{"position":{"key":"currency","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(usd,native)","options":[]}},
        				{"position":{"key":"fromDate","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":[]}},
        				{"position":{"key":"toDate","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":[]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get the OHLCV candle stick by using pair address", "chain": "eth", "timeframe": "1h", "currency": "usd", "fromDate": "2025-01-01T10:00:00.000", "toDate": "2025-01-02T10:00:00.000", "address": "0xa43fe16908251ee70ef74718545e4fe6c5ccec9f"}
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/erc20/:address/price": 		{
        		    "requestMethod": "GET",
        		    "description": "Get the token price denominated in the blockchain's native token and USD. View supported exchanges here",
        		    "route": "/erc20/:address/price",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,chiliz,0x15b38,base,0x2105,optimism,0xa,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,ronin,0x7e4,lisk,0x46f,pulse,0x171)","options":[]}},
        				{"position":{"key":"include","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(percent_change)","options":["optional()"]}},
        				{"position":{"key":"exchange","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(uniswapv2,uniswapv3,sushiswapv2,pancakeswapv1,pancakeswapv2,pancakeswapv3,quickswap,quickswapv2,traderjoe,pangolin,spookyswap,vvs,mm finance,crodex,camelotv2)","options":["optional()"]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"max_token_inactivity","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"min_pair_side_liquidity_usd","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get the token price denominated in the blockchain's native token and USD.", "chain": "eth", "address": "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        "/:pair_address/reserves": {
          "requestMethod": "GET",
          "description": "Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment.",
          "route": "/:pair_address/reserves",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,chiliz,0x15b38,base,0x2105,optimism,0xa,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507)", "options": [] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "pair_address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the liquidity reserves for a given pair address.", "chain": "eth", "pair_address": "0xa2107fa5b38d9bbd2c461d6edf11b11a50f6b974" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/pairs/:address/snipers": {
          "requestMethod": "GET",
          "description": "Get all snipers (wallets that quickly buy and sell tokens) for a specific token pair address.",
          "route": "/pairs/:address/snipers",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,fantom,0xfa,arbitrum,0xa4b1,gnosis,0x64,base,0x2105,optimism,0xa,linea,0xe708,ronin,0x7e4,pulse,0x171)", "options": [] } },
            { "position": { "key": "blocksAfterCreation", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get all snipers (wallets that quickly buy and sell tokens) for a specific token pair address.", "chain": "eth", "address": "0xa3c2076eb97d573cc8842f1db1ecdf7b6f77ba27" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/pairs/:address/swaps": {
          "requestMethod": "GET",
          "description": "Get all swap related transactions (buy, sell, add liquidity & remove liquidity)",
          "route": "/pairs/:address/swaps",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "fromBlock", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "toBlock", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "fromDate", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "toDate", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "transactionTypes", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get all swap related transactions (buy, sell, add liquidity & remove liquidity)", "chain": "eth", "address": "0xa43fe16908251ee70ef74718545e4fe6c5ccec9f" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/swaps": {
          "requestMethod": "GET",
          "description": "Get all swap related transactions (buy, sell)",
          "route": "/wallets/:address/swaps",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "fromBlock", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "toBlock", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "fromDate", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "toDate", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "transactionTypes", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get all swap related transactions (buy, sell)", "chain": "eth", "address": "0x6982508145454ce325ddbe47a25d4ec3d2311933" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/tokens/:address/analytics": {
          "requestMethod": "GET",
          "description": "Get analytics for a token by token address",
          "route": "/tokens/:address/analytics",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,fantom,0xfa,arbitrum,0xa4b1,gnosis,0x64,base,0x2105,optimism,0xa,linea,0xe708,moonbeam,0x504,ronin,0x7e4,pulse,0x171)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get analytics for a token by token address", "chain": "eth", "address": "0x6982508145454Ce325dDbE47a25d4ec3d2311933" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/erc20/:token_address/owners": {
          "requestMethod": "GET",
          "description": "Identify the major holders of an ERC20 token and understand their ownership percentages",
          "route": "/erc20/:token_address/owners",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "token_address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the major holders of an ERC20 token and understand their ownership percentages", "chain": "eth", "token_address": "0x6982508145454ce325ddbe47a25d4ec3d2311933" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/erc20/metadata/symbols": {
          "requestMethod": "GET",
          "description": "Get the metadata for a list of token symbols (name, symbol, decimals, logo).",
          "route": "/erc20/metadata/symbols",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "symbols", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the metadata for a list of token symbols.", "chain": "eth", "symbols": ["LINK"] }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/erc20/metadata": {
          "requestMethod": "GET",
          "description": "Get the metadata for a given token contract address (name, symbol, decimals, logo).",
          "route": "/erc20/metadata",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "addresses", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the metadata for a given token contract address.", "chain": "eth", "addresses": ["0x6982508145454ce325ddbe47a25d4ec3d2311933"] }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/erc20/:address/stats": {
          "requestMethod": "GET",
          "description": "Get the stats for a erc20 token",
          "route": "/erc20/:address/stats",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the stats for a erc20 token", "chain": "eth", "address": "0xdac17f958d2ee523a2206206994597c13d831ec7" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/erc20/:address/transfers": {
          "requestMethod": "GET",
          "description": "Get ERC20 token transactions from a contract ordered by block number in descending order.",
          "route": "/erc20/:address/transfers",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get ERC20 token transactions from a contract ordered by block number in descending order.", "chain": "eth", "address": "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/market-data/erc20s/top-tokens": {
          "requestMethod": "GET",
          "description": "Get the top ERC20 tokens by market cap",
          "route": "/market-data/erc20s/top-tokens",
          "parameters": [],
          "tests": [
            { "_description": "Get the top ERC20 tokens by market cap" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/erc20/:address/top-gainers": {
          "requestMethod": "GET",
          "description": "Retrieves a list of the top profitable wallets for a specific ERC20 token.",
          "route": "/erc20/:address/top-gainers",
          "parameters": [
            { "position": { "key": "days", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,mainnet,0x1,matic,0x89,polygon,bsc,binance,0x38,fantom,ftm,0xfa,arbitrum,0xa4b1,optimism,0xa,pulsechain,0x171,base,0x2105,linea,0xe708)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the top profitable wallets for a specific ERC20 token.", "chain": "eth", "address": "0x6982508145454ce325ddbe47a25d4ec3d2311933" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/approvals": {
          "requestMethod": "GET",
          "description": "Retrieve active ERC20 token approvals for the specified wallet address",
          "route": "/wallets/:address/approvals",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get active ERC20 token approvals for the specified wallet address", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/tokens": {
          "requestMethod": "GET",
          "description": "Get token balances for a specific wallet address and their token prices in USD.",
          "route": "/wallets/:address/tokens",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "token_addresses", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "exclude_spam", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "exclude_unverified_contracts", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "exclude_native", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "max_token_inactivity", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "min_pair_side_liquidity_usd", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get token balances for a specific wallet address and their token prices in USD.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/:address/erc20": {
          "requestMethod": "GET",
          "description": "Get token balances for a specific wallet address.",
          "route": "/:address/erc20",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "token_addresses", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "exclude_spam", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get token balances for a specific wallet address.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/:address/erc20/transfers": {
          "requestMethod": "GET",
          "description": "Get ERC20 token transactions ordered by block number in descending order.",
          "route": "/:address/erc20/transfers",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "contract_addresses", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get ERC20 token transactions ordered by block number in descending order.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/utils.mjs
var utils_exports = {};
__export(utils_exports, {
  schema: () => schema77
});
var schema77;
var init_utils2 = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema77 = {
      "namespace": "moralis",
      "name": "Moralis utils API",
      "description": "Moralis utils API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        "/info/endpointWeights": {
          "requestMethod": "GET",
          "description": "Get the cost and rate limit for each API endpoint.",
          "route": "/info/endpointWeights",
          "parameters": [],
          "tests": [
            {
              "_description": "Get the cost and rate limit for each API endpoint."
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        },
        "/web3/version": {
          "requestMethod": "GET",
          "description": "Get the current version of the Moralis Web3 API.",
          "route": "/web3/version",
          "parameters": [],
          "tests": [
            {
              "_description": "Get the current version of the Moralis Web3 API."
            }
          ],
          "modifiers": [
            {
              "phase": "post",
              "handlerName": "modifyResult"
            }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/walletApi.mjs
var walletApi_exports = {};
__export(walletApi_exports, {
  schema: () => schema78
});
var schema78;
var init_walletApi = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/moralis-com/eth/walletApi.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema78 = {
      "namespace": "moralis",
      "name": "Moralis walletApi API",
      "description": "Moralis walletApi API",
      "docs": ["https://docs.moralis.com"],
      tags: [],
      "flowMCP": "1.2.0",
      "root": "https://deep-index.moralis.io/api/v2.2",
      "requiredServerParams": [
        "MORALIS_API_KEY"
      ],
      "headers": {
        "X-API-Key": "{{MORALIS_API_KEY}}"
      },
      "routes": {
        /*
        		"/:address/verbose": 		{
        		    "requestMethod": "GET",
        		    "description": "Get native transactions and logs ordered by block number in descending order.",
        		    "route": "/:address/verbose",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"from_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"from_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"to_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"include","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(internal_transactions)","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"order","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(ASC,DESC)","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get native transactions and logs ordered by block number in descending order.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/:address": 		{
        		    "requestMethod": "GET",
        		    "description": "Get native transactions ordered by block number in descending order.",
        		    "route": "/:address",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"from_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"from_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"to_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"include","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(internal_transactions)","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"order","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(ASC,DESC)","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get native transactions ordered by block number in descending order.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/wallets/:address/defi/:protocol/positions": 		{
        		    "requestMethod": "GET",
        		    "description": "Get the detailed defi positions by protocol for a wallet address.",
        		    "route": "/wallets/:address/defi/:protocol/positions",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,polygon,0x89,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,chiliz,0x15b38,chiliz testnet,0x15b32,gnosis,0x64,gnosis testnet,0x27d8,base,0x2105,base sepolia,0x14a34,optimism,0xa,holesky,0x4268,polygon amoy,0x13882,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,linea sepolia,0xe705)","options":[]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}},
        				{"position":{"key":"protocol","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"enum(uniswap-v2,uniswap-v3,pancakeswap-v2,pancakeswap-v3,quickswap-v2,sushiswap-v2,aave-v2,aave-v3,fraxswap-v1,fraxswap-v2,lido,makerdao,eigenlayer)","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get the detailed defi positions by protocol for a wallet address.", "chain": "eth", "address": "0xd100d8b69c5ae23d6aa30c6c3874bf47539b95fd", "protocol": "aave-v3" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/wallets/:address/defi/positions": 		{
        		    "requestMethod": "GET",
        		    "description": "Get the positions summary of a wallet address.",
        		    "route": "/wallets/:address/defi/positions",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,polygon,0x89,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,chiliz,0x15b38,chiliz testnet,0x15b32,gnosis,0x64,gnosis testnet,0x27d8,base,0x2105,base sepolia,0x14a34,optimism,0xa,holesky,0x4268,polygon amoy,0x13882,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,linea sepolia,0xe705)","options":[]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get the positions summary of a wallet address.", "chain": "eth", "address": "0xd100d8b69c5ae23d6aa30c6c3874bf47539b95fd" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/wallets/:address/defi/summary": 		{
        		    "requestMethod": "GET",
        		    "description": "Get the defi summary of a wallet address.",
        		    "route": "/wallets/:address/defi/summary",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,polygon,0x89,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,chiliz,0x15b38,chiliz testnet,0x15b32,gnosis,0x64,gnosis testnet,0x27d8,base,0x2105,base sepolia,0x14a34,optimism,0xa,holesky,0x4268,polygon amoy,0x13882,linea,0xe708,moonbeam,0x504,moonriver,0x505,moonbase,0x507,linea sepolia,0xe705)","options":[]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get the defi summary of a wallet address.", "chain": "eth", "address": "0xd100d8b69c5ae23d6aa30c6c3874bf47539b95fd" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/wallets/:address/nfts/trades": 		{
        		    "requestMethod": "GET",
        		    "description": "Get trades of NFTs for a given wallet.",
        		    "route": "/wallets/:address/nfts/trades",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,arbitrum,0xa4b1,base,0x2105,optimism,0xa)","options":[]}},
        				{"position":{"key":"from_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"from_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"to_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"nft_metadata","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get trades of NFTs for a given wallet.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905"
        		        }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/:address/nft/collections": 		{
        		    "requestMethod": "GET",
        		    "description": "Get NFT collections owned by a given wallet address.",
        		    "route": "/:address/nft/collections",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)","options":[]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"token_counts","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"exclude_spam","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"include_prices","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get NFT ciollections owned by a given wallet address.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/:address/nft/transfers": 		{
        		    "requestMethod": "GET",
        		    "description": "Get transfers of NFTs given the wallet and other parameters.",
        		    "route": "/:address/nft/transfers",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)","options":[]}},
        				{"position":{"key":"contract_addresses","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"array()","options":["optional()"]}},
        				{"position":{"key":"format","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"from_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"from_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"to_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"order","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(ASC,DESC)","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"include_prices","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get transfers of NFTs given the wallet and other parameters.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/:address/nft": 		{
        		    "requestMethod": "GET",
        		    "description": "Get NFTs owned by a given address.",
        		    "route": "/:address/nft",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a)","options":[]}},
        				{"position":{"key":"format","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(decimal,hex)","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"exclude_spam","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"token_addresses","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"array()","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"normalizeMetadata","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"media_items","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"include_prices","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get NFTs owned by a given address.", "chain": "eth", "address": "0xff3879b8a363aed92a6eaba8f61f1a96a9ec3c1e" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/wallets/:address/swaps": 		{
        		    "requestMethod": "GET",
        		    "description": "Get all swap related transactions (buy, sell)",
        		    "route": "/wallets/:address/swaps",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"fromBlock","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"toBlock","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"fromDate","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"toDate","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"order","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(ASC,DESC)","options":["optional()"]}},
        				{"position":{"key":"transactionTypes","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get all swap related transactions (buy, sell)", "chain": "eth", "address": "0x6982508145454ce325ddbe47a25d4ec3d2311933" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/wallets/:address/approvals": 		{
        		    "requestMethod": "GET",
        		    "description": "Retrieve active ERC20 token approvals for the specified wallet address",
        		    "route": "/wallets/:address/approvals",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get active ERC20 token approvals for the specified wallet address", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/wallets/:address/tokens": 		{
        		    "requestMethod": "GET",
        		    "description": "Get token balances for a specific wallet address and their token prices in USD.",
        		    "route": "/wallets/:address/tokens",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"token_addresses","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"array()","options":["optional()"]}},
        				{"position":{"key":"exclude_spam","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"exclude_unverified_contracts","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"exclude_native","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"max_token_inactivity","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"min_pair_side_liquidity_usd","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get token balances for a specific wallet address and their token prices in USD.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/:address/erc20": 		{
        		    "requestMethod": "GET",
        		    "description": "Get token balances for a specific wallet address.",
        		    "route": "/:address/erc20",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"token_addresses","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"array()","options":["optional()"]}},
        				{"position":{"key":"exclude_spam","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(false,true)","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get token balances for a specific wallet address.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        /*
        		"/:address/erc20/transfers": 		{
        		    "requestMethod": "GET",
        		    "description": "Get ERC20 token transactions ordered by block number in descending order.",
        		    "route": "/:address/erc20/transfers",
        		    "parameters": [
        				{"position":{"key":"chain","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)","options":[]}},
        				{"position":{"key":"contract_addresses","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"array()","options":["optional()"]}},
        				{"position":{"key":"from_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"to_block","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"from_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"to_date","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"limit","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"number()","options":["optional()"]}},
        				{"position":{"key":"order","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"enum(ASC,DESC)","options":["optional()"]}},
        				{"position":{"key":"cursor","value":"{{USER_PARAM}}","location":"query"},"z":{"primitive":"string()","options":["optional()"]}},
        				{"position":{"key":"address","value":"{{USER_PARAM}}","location":"insert"},"z":{"primitive":"string()","options":[]}}
        			],
        		    "tests": [
        		        { "_description": "Get ERC20 token transactions ordered by block number in descending order.", "chain": "eth", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
        		    ],
        		    "modifiers": [
        		        { "phase": "post", "handlerName": "modifyResult" }
        		    ]
        		},
        */
        "/wallets/:address/chains": {
          "requestMethod": "GET",
          "description": "Get the active chains for a wallet address.",
          "route": "/wallets/:address/chains",
          "parameters": [
            { "position": { "key": "chains", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the active chains for a wallet address.", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/:address/balance": {
          "requestMethod": "GET",
          "description": "Get the native balance for a specific wallet address.",
          "route": "/:address/balance",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the native balance for a specific wallet address.", "chain": "eth", "address": "0xDC24316b9AE028F1497c275EB9192a3Ea0f67022" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/history": {
          "requestMethod": "GET",
          "description": "Retrieve the full transaction history of a specified wallet address, including sends, receives, token and NFT transfers, and contract interactions.",
          "route": "/wallets/:address/history",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,polygon,0x89,bsc,0x38,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,chiliz,0x15b38,gnosis,0x64,base,0x2105,optimism,0xa,linea,0xe708,moonbeam,0x504,moonriver,0x505,flow,0x2eb,ronin,0x7e4,lisk,0x46f,pulse,0x171)", "options": [] } },
            { "position": { "key": "from_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "to_block", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "from_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "to_date", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "include_internal_transactions", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "nft_metadata", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "cursor", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "order", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(ASC,DESC)", "options": ["optional()"] } },
            { "position": { "key": "limit", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Retrieve the full transaction history of a specified wallet address.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/net-worth": {
          "requestMethod": "GET",
          "description": "Get the net worth of a wallet in USD. We recommend to filter out spam tokens and unverified contracts to get a more accurate result.",
          "route": "/wallets/:address/net-worth",
          "parameters": [
            { "position": { "key": "chains", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "exclude_spam", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "exclude_unverified_contracts", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(false,true)", "options": ["optional()"] } },
            { "position": { "key": "max_token_inactivity", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "min_pair_side_liquidity_usd", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "number()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the net worth of a wallet in USD.", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/profitability/summary": {
          "requestMethod": "GET",
          "description": "Retrieves a summary of wallet profitability based on specified parameters including optional token addresses.",
          "route": "/wallets/:address/profitability/summary",
          "parameters": [
            { "position": { "key": "days", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,mainnet,0x1,matic,0x89,polygon,bsc,binance,0x38,fantom,ftm,0xfa,arbitrum,0xa4b1,optimism,0xa,pulsechain,0x171,base,0x2105,linea,0xe708)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get a summary of wallet profitability based on specified parameters including optional token addresses.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/profitability": {
          "requestMethod": "GET",
          "description": "Retrieves profitability information for a specific wallet address. Can be filtered by one or more tokens.",
          "route": "/wallets/:address/profitability",
          "parameters": [
            { "position": { "key": "days", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,mainnet,0x1,matic,0x89,polygon,bsc,binance,0x38,fantom,ftm,0xfa,arbitrum,0xa4b1,optimism,0xa,pulsechain,0x171,base,0x2105,linea,0xe708)", "options": [] } },
            { "position": { "key": "token_addresses", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "array()", "options": ["optional()"] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get profitability information for a specific wallet address.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/wallets/:address/stats": {
          "requestMethod": "GET",
          "description": "Get the stats for a wallet address.",
          "route": "/wallets/:address/stats",
          "parameters": [
            { "position": { "key": "chain", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "enum(eth,0x1,sepolia,0xaa36a7,holesky,0x4268,polygon,0x89,polygon amoy,0x13882,bsc,0x38,bsc testnet,0x61,avalanche,0xa86a,fantom,0xfa,palm,0x2a15c308d,cronos,0x19,arbitrum,0xa4b1,gnosis,0x64,gnosis testnet,0x27d8,chiliz,0x15b38,chiliz testnet,0x15b32,base,0x2105,base sepolia,0x14a34,optimism,0xa,linea,0xe708,linea sepolia,0xe705,moonbeam,0x504,moonriver,0x505,moonbase,0x507,flow,0x2eb,flow-testnet,0x221,ronin,0x7e4,ronin-testnet,0x7e5,lisk,0x46f,lisk-sepolia,0x106a,pulse,0x171)", "options": [] } },
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the stats for a wallet address.", "chain": "eth", "address": "0xcB1C1FdE09f811B294172696404e88E658659905" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/resolve/:address/domain": {
          "requestMethod": "GET",
          "description": "Resolve a specific address to its Unstoppable domain",
          "route": "/resolve/:address/domain",
          "parameters": [
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Get the Unstoppable domain for a specific address", "address": "0x94ef5300cbc0aa600a821ccbc561b057e456ab23" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/resolve/:address/reverse": {
          "requestMethod": "GET",
          "description": "Reverse resolve a given ETH address to its ENS domain.",
          "route": "/resolve/:address/reverse",
          "parameters": [
            { "position": { "key": "address", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Reverse resolve a given ETH address to its ENS domain.", "address": "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/resolve/:domain": {
          "requestMethod": "GET",
          "description": "Resolve a specific Unstoppable domain to its address.",
          "route": "/resolve/:domain",
          "parameters": [
            { "position": { "key": "currency", "value": "{{USER_PARAM}}", "location": "query" }, "z": { "primitive": "string()", "options": ["optional()"] } },
            { "position": { "key": "domain", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Resolve a specific Unstoppable domain to its address.", "domain": "brad.crypto" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        },
        "/resolve/ens/:domain": {
          "requestMethod": "GET",
          "description": "Resolve a specific ENS domain to its address.",
          "route": "/resolve/ens/:domain",
          "parameters": [
            { "position": { "key": "domain", "value": "{{USER_PARAM}}", "location": "insert" }, "z": { "primitive": "string()", "options": [] } }
          ],
          "tests": [
            { "_description": "Resolve a specific ENS domain to its address.", "domain": "vitalik.eth" }
          ],
          "modifiers": [
            { "phase": "post", "handlerName": "modifyResult" }
          ]
        }
      },
      "handlers": {
        "modifyResult": /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/newsapi-org/news.mjs
var news_exports = {};
__export(news_exports, {
  schema: () => schema79
});
var schema79;
var init_news = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/newsapi-org/news.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema79 = {
      namespace: "newsapi",
      name: "NewsAPI.org",
      description: "Access breaking news headlines and search through articles from news sources and blogs across the web",
      docs: ["https://newsapi.org/docs"],
      tags: ["news", "media", "content"],
      flowMCP: "1.2.0",
      root: "https://newsapi.org/v2",
      requiredServerParams: ["NEWSAPI_API_KEY"],
      headers: { "X-API-Key": "{{NEWSAPI_API_KEY}}" },
      routes: {
        getTopHeadlines: {
          requestMethod: "GET",
          description: "Get breaking news headlines for a country or category",
          route: "/top-headlines",
          parameters: [
            { position: { key: "country", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ae,ar,at,au,be,bg,br,ca,ch,cn,co,cu,cz,de,eg,fr,gb,gr,hk,hu,id,ie,il,in,it,jp,kr,lt,lv,ma,mx,my,ng,nl,no,nz,ph,pl,pt,ro,rs,ru,sa,se,sg,si,sk,th,tr,tw,ua,us,ve,za)", options: ["optional()"] } },
            { position: { key: "category", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(business,entertainment,general,health,science,sports,technology)", options: ["optional()"] } },
            { position: { key: "sources", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "q", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "pageSize", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "optional()"] } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } }
          ],
          tests: [
            { _description: "Get US top headlines", country: "us" },
            { _description: "Get technology headlines", category: "technology" },
            { _description: "Search for Bitcoin news", q: "bitcoin", pageSize: 10 }
          ],
          modifiers: []
        },
        getEverything: {
          requestMethod: "GET",
          description: "Search through millions of articles from over 80,000 large and small news sources and blogs",
          route: "/everything",
          parameters: [
            { position: { key: "q", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "qInTitle", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sources", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "domains", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "excludeDomains", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "language", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ar,de,en,es,fr,he,it,nl,no,pt,ru,sv,ud,zh)", options: ["optional()"] } },
            { position: { key: "sortBy", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(relevancy,popularity,publishedAt)", options: ["optional()"] } },
            { position: { key: "pageSize", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "optional()"] } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "optional()"] } }
          ],
          tests: [
            { _description: "Search for cryptocurrency articles", q: "cryptocurrency", sortBy: "publishedAt", pageSize: 20 },
            { _description: "Search for AI in titles", qInTitle: "artificial intelligence", language: "en" },
            { _description: "Get articles from specific domains", domains: "techcrunch.com,wired.com", language: "en" }
          ],
          modifiers: []
        },
        getSources: {
          requestMethod: "GET",
          description: "Get the subset of news publishers that top headlines and everything endpoints are available for",
          route: "/top-headlines/sources",
          parameters: [
            { position: { key: "category", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(business,entertainment,general,health,science,sports,technology)", options: ["optional()"] } },
            { position: { key: "language", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ar,de,en,es,fr,he,it,nl,no,pt,ru,sv,ud,zh)", options: ["optional()"] } },
            { position: { key: "country", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(ae,ar,at,au,be,bg,br,ca,ch,cn,co,cu,cz,de,eg,fr,gb,gr,hk,hu,id,ie,il,in,it,jp,kr,lt,lv,ma,mx,my,ng,nl,no,nz,ph,pl,pt,ro,rs,ru,sa,se,sg,si,sk,th,tr,tw,ua,us,ve,za)", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Get all sources" },
            { _description: "Get technology sources", category: "technology" },
            { _description: "Get US English sources", country: "us", language: "en" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/newsdata-io/getNews.mjs
var getNews_exports2 = {};
__export(getNews_exports2, {
  schema: () => schema80
});
var schema80;
var init_getNews2 = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/newsdata-io/getNews.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema80 = {
      namespace: "newsdata",
      name: "CryptoNews",
      description: "Fetches general or topic-specific cryptocurrency news articles from NewsData.io.",
      docs: ["https://newsdata.io/documentation/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://newsdata.io/api/1/crypto",
      requiredServerParams: ["NEWSDATA_API_KEY"],
      headers: {
        apikey: "{{NEWSDATA_API_KEY}}"
      },
      routes: {
        getLatestNewsdata: {
          requestMethod: "GET",
          description: "Fetch the latest general crypto news from NewsData.io.",
          route: "/",
          parameters: [],
          tests: [
            { _description: "Get latest general crypto news" }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatNewsList" }
          ]
        },
        getCryptoNewsdata: {
          requestMethod: "GET",
          description: "Fetch topic-specific crypto news for a given query and max number of pages.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "max_pages", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(5)", "default(1)"] } }
          ],
          tests: [
            { _description: "Fetch Bitcoin news from 2 pages", query: "bitcoin", max_pages: 2 }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatNewsList" }
          ]
        }
      },
      handlers: {
        formatNewsList: /* @__PURE__ */ __name(async ({ struct, payload, userParams, routeName, phaseType }) => {
          struct.news = payload?.content?.[0]?.text || "No data.";
          return { struct, payload };
        }, "formatNewsList")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/pinata/read.mjs
var read_exports = {};
__export(read_exports, {
  schema: () => schema81
});
var schema81;
var init_read = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/pinata/read.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema81 = {
      namespace: "pinata",
      name: "Pinata IPFS Read MCP Interface",
      description: "A FlowMCP interface for reading content from the Pinata IPFS gateway",
      docs: ["https://gateway.pinata.cloud/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://gateway.pinata.cloud/ipfs",
      requiredServerParams: [],
      //[ 'PINATA_GATEWAY' ],
      headers: {},
      routes: {
        free_read_example: {
          requestMethod: "GET",
          description: "Returns a static IPFS-hosted example image",
          route: "/{{cid}}",
          parameters: [
            { position: { key: "cid", value: "QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/1", location: "insert" } }
          ],
          tests: [{ _description: "Load sample image from IPFS" }],
          modifiers: [{ phase: "post", handlerName: "free_read_example" }]
        },
        free_read_cid: {
          requestMethod: "GET",
          description: "Reads content from any IPFS CID",
          route: "/{{cid}}",
          parameters: [
            { position: { key: "cid", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Read arbitrary CID", cid: "QmYwAPJzv5CZsnAzt8auV2Annh6wKghpMdJtKhHgGMRFjx" }],
          modifiers: [
            { phase: "pre", handlerName: "pre" },
            { phase: "post", handlerName: "free_read_cid" }
          ]
        }
      },
      handlers: {
        free_read_example: /* @__PURE__ */ __name(async (a2) => {
          const { struct } = a2;
          return { struct };
        }, "free_read_example"),
        pre: /* @__PURE__ */ __name(async (a2) => {
          const { struct, userParams } = a2;
          struct.data = {
            cid: userParams.cid || "QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/1",
            message: "This is a static example image hosted on IPFS"
          };
          return { struct };
        }, "pre"),
        free_read_cid: /* @__PURE__ */ __name(async (a2) => {
          const { struct } = a2;
          return { struct };
        }, "free_read_cid")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/poap/graphql.mjs
var graphql_exports2 = {};
__export(graphql_exports2, {
  schema: () => schema82
});
var poapQueries, schema82;
var init_graphql2 = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/poap/graphql.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    poapQueries = {
      poapsFromBerlin: {
        description: "Returns the top 5 POAP drops from Berlin with the most tokens minted, including event details.",
        query: `{ drops(where: {_or: [{name: {_ilike: "%Berlin%"}}, {description: {_ilike: "%Berlin%"}}]}, limit: 20) { id name description city country start_date end_date image_url fancy_id } }`
      },
      highestAttendanceLastYear: {
        description: "Returns the top 5 POAP drops from 2024 with the most tokens minted, including event details and attendance count.",
        query: `{ drops( where: {start_date: {_gt: "2024-01-01"}}, limit: 5, order_by: {poaps_aggregate: {count: desc}} ) { id name fancy_id start_date end_date city country poaps_aggregate { aggregate { count } } } }`
      },
      collectorPoaps: {
        description: "Retrieves the total POAP count for a specific wallet address and shows a sample of their collected events.",
        query: `{ collectors( where: {address: {_eq: "0xd8da6bf26964af9d7eed9e03e53415d37aa96045"} } ) { address poaps_aggregate { aggregate { count } } poaps(limit: 5) { drop { name start_date } } } }`
      },
      mostTransferredPoaps: {
        description: "Identifies the POAPs with the highest transfer counts, which may indicate high value or popularity in secondary markets.",
        query: `{ poaps( limit: 5, order_by: {transfer_count: desc} ) { id transfer_count drop { name fancy_id start_date } } }`
      },
      dropsBasicInfo: {
        description: "Retrieves basic information about POAP drops including location data, useful for geographic distribution analysis.",
        query: `{ drops(limit: 5) { id name city country } }`
      },
      poapsByChain: {
        description: "Examines the blockchain network distribution of POAPs, showing which chains are most commonly used for minting.",
        query: `{ poaps(limit: 10) { chain id minted_on } }`
      },
      artistsList: {
        description: "Lists artists who have contributed to POAP designs, providing insight into the creative contributors to the ecosystem.",
        query: `{ collections_artists { name } }`
      },
      recentMoments: {
        description: "Explores user-created moments associated with POAPs, showing how people memorialize their experiences with digital collectibles.",
        query: `{ moments( limit: 5, order_by: {created_on: desc} ) { id created_on author drops { drop { name } } } }`
      },
      topCollectors: {
        description: "Identifies the most prolific POAP collectors, whose collections could be further analyzed for thematic preferences.",
        query: `{ collectors( limit: 3, order_by: {poaps_owned: desc} ) { address poaps_owned } }`
      },
      mostExclusiveDrops: {
        description: "Examines the rarity spectrum of POAP drops by finding those with the fewest minted tokens, indicating exclusivity.",
        query: `{ drops( limit: 10, order_by: {poaps_aggregate: {count: asc}} ) { id name fancy_id poaps_aggregate { aggregate { count } } } }`
      },
      mostPopularDrops: {
        description: "Identifies the most popular POAP events of all time based on total participation, showing which events resonated most with the community.",
        query: `{ drops( limit: 10, order_by: {poaps_aggregate: {count: desc}} ) { id name fancy_id poaps_aggregate { aggregate { count } } } }`
      }
    };
    schema82 = {
      namespace: "poap",
      name: "POAP GraphQL",
      description: "GraphQL endpoint for accessing POAP event data and metadata",
      docs: ["https://public.compass.poap.tech/v1/graphql"],
      tags: ["production", "graphql", "poap"],
      flowMCP: "1.2.0",
      root: "https://public.compass.poap.tech/v1/graphql",
      requiredServerParams: [],
      headers: {
        "content-type": "application/json"
      },
      routes: {
        getTypename: {
          requestMethod: "POST",
          description: "Simple GraphQL query to retrieve the __typename root for basic connectivity test.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "query { __typename }", location: "body" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Simple __typename query test" }
          ],
          modifiers: []
        },
        getSchemaDefinition: {
          requestMethod: "POST",
          description: "Returns the full GraphQL schema via introspection",
          route: "/",
          parameters: [
            {
              position: {
                key: "query",
                value: "query IntrospectionQuery { __schema { types { name kind fields { name type { name kind ofType { name kind } } } } } }",
                location: "body"
              },
              z: { primitive: "string()", options: [] }
            }
          ],
          tests: [
            { _description: "Returns full GraphQL schema" }
          ],
          modifiers: []
        },
        getPredefinedQueryList: {
          requestMethod: "GET",
          description: "Run a predefined GraphQL query.",
          route: "/",
          parameters: [],
          tests: [
            { _description: "Sample query for entity data" }
          ],
          modifiers: [
            { phase: "execute", handlerName: "listQuestions" }
          ]
        },
        executePrefinedQuery: {
          requestMethod: "POST",
          description: "Run a predefined GraphQL query.",
          route: "/",
          parameters: [
            { position: { key: "queryId", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: `enum(${Object.keys(poapQueries)})`, options: [] } },
            { position: { key: "query", value: "placeholder", location: "body" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            ...Object.entries(poapQueries).map(([queryId, { description }]) => {
              return { _description: description, queryId };
            })
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertPredefinedQuery" }
          ]
        },
        querySubgraph: {
          requestMethod: "POST",
          description: "Run a raw GraphQL query.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: [] } }
          ],
          modifiers: [],
          tests: [
            { _description: "Sample query for entity data", query: "query { collections_artists { name } }" }
          ]
        }
      },
      handlers: {
        insertPredefinedQuery: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { queryId } = userParams;
          const { query } = poapQueries[queryId];
          payload["body"]["query"] = query;
          return { struct, payload };
        }, "insertPredefinedQuery"),
        listQuestions: /* @__PURE__ */ __name(({ struct, payload }) => {
          struct["status"] = true;
          struct["data"] = Object.entries(poapQueries).map(([queryId, { description }]) => {
            return { description, queryId };
          });
          return { struct, payload };
        }, "listQuestions")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/polymarket/marketInfo.mjs
var marketInfo_exports = {};
__export(marketInfo_exports, {
  schema: () => schema83
});
var schema83;
var init_marketInfo = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/polymarket/marketInfo.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema83 = {
      namespace: "polymarket",
      name: "Polymarket Predictions",
      description: "Access prediction market data from Polymarket via CLOB API",
      docs: [],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://clob.polymarket.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        getMarkets: {
          requestMethod: "GET",
          description: "List prediction markets with optional filters",
          route: "/markets",
          parameters: [
            { position: { key: "status", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(active,resolved)", options: [] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] } },
            { position: { key: "offset", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "default(0)"] } }
          ],
          tests: [
            { _description: "List 5 active markets", status: "active", limit: 10, offset: 0 }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getMarketInfo: {
          requestMethod: "GET",
          description: "Get detailed information about a specific prediction market",
          route: "/markets/:condition_id",
          parameters: [
            { position: { key: "condition_id", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get info for market ID xyz", condition_id: "0x9412b855478d1dc1ba433a18de8bd082dc22b0c3a30c01f307016c2a07c11572" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        changeParams: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { condition_id } = userParams;
          payload["url"] = payload["url"].replace("placeholder", `${condition_id}`);
          return { struct, payload };
        }, "changeParams"),
        modifyResult: /* @__PURE__ */ __name(({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/polymarket/searchBySlug.mjs
var searchBySlug_exports = {};
__export(searchBySlug_exports, {
  schema: () => schema84
});
var selection, schema84;
var init_searchBySlug = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/polymarket/searchBySlug.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    selection = {
      fedRateCuts2025: "how-many-fed-rate-cuts-in-2025"
    };
    schema84 = {
      namespace: "polymarket",
      name: "Fed Rate Cuts 2025",
      description: "Zeigt Marktprognosen f\xFCr Fed-Zinssenkungen im Jahr 2025.",
      docs: ["https://polymarket.com"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://gamma-api.polymarket.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        searchBySlug: {
          requestMethod: "GET",
          description: "Get market data for Fed rate cuts in 2025 by slug",
          route: "/events/slug/:slug",
          parameters: [
            { position: { key: "slug", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: `enum(${Object.keys(selection)})`, options: [] } }
          ],
          modifiers: [
            { phase: "pre", handlerName: "mapSelectionToSlug" },
            { phase: "post", handlerName: "extractOutcomePercents" }
          ],
          tests: [
            { _description: "Test Fed Cut Market 2025", slug: "fedRateCuts2025" }
          ]
        }
      },
      handlers: {
        mapSelectionToSlug: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const key = userParams.slug;
          if (selection[key]) {
            payload["url"] = payload.url.replace(key, selection[key]);
          } else {
            struct.status = false;
            struct.messages.push(`Selection not found.`);
          }
          return { struct, payload };
        }, "mapSelectionToSlug"),
        extractOutcomePercents: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct.data || !struct.data.markets) {
            struct.status = false;
            struct.messages.push(`Error`);
            return { struct, payload };
          }
          struct["data"] = struct["data"]?.markets.map((market) => {
            const prices = JSON.parse(market.outcomePrices || "[]");
            return {
              question: market.question,
              outcomes: JSON.parse(market.outcomes || "[]"),
              prices: prices.map((p) => Math.round(parseFloat(p) * 100)),
              lastTrade: Math.round(parseFloat(market.lastTradePrice || "0") * 100)
            };
          });
          return { struct, payload };
        }, "extractOutcomePercents")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/reddit/getTokenMentions.mjs
var getTokenMentions_exports = {};
__export(getTokenMentions_exports, {
  schema: () => schema85
});
var schema85;
var init_getTokenMentions = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/reddit/getTokenMentions.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema85 = {
      namespace: "redditScanner",
      name: "Reddit Token Mention Search",
      description: "Searches Reddit for mentions of a token symbol or name related to crypto topics.",
      docs: ["https://www.reddit.com/dev/api/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://www.reddit.com",
      requiredServerParams: [],
      headers: {},
      routes: {
        getTokenMentions: {
          requestMethod: "GET",
          description: "Search for mentions of a token symbol or name on Reddit with optional sentiment analysis.",
          route: "/search.json",
          parameters: [
            { position: { key: "q", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "optional()"] } }
          ],
          tests: [
            { _description: "Reddit search for ETH with default limit", q: "ETH OR Ethereum crypto" },
            { _description: "Reddit search for SOL with custom limit", q: "SOL OR Solana crypto", limit: 25 }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        },
        getHotMemes: {
          requestMethod: "GET",
          description: "Retrieve hot posts from r/memes subreddit.",
          route: "/r/memes/hot/.json",
          parameters: [],
          tests: [
            { _description: "Fetch hot memes from r/memes" }
          ],
          modifiers: [
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyResult: /* @__PURE__ */ __name(({ struct, payload }) => {
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/santiment-net/schema.mjs
var schema_exports = {};
__export(schema_exports, {
  schema: () => schema86
});
var schema86;
var init_schema = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/santiment-net/schema.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema86 = {
      namespace: "santiment",
      name: "SantimentAnalytics",
      description: "Provides sentiment and social metrics for crypto assets using the Santiment API.",
      docs: ["https://academy.santiment.net/for-developers/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.santiment.net",
      requiredServerParams: ["SANTIMENT_API_KEY"],
      headers: {
        Authorization: "Apikey {{SANTIMENT_API_KEY}}"
      },
      routes: {
        get_sentiment_balance: {
          requestMethod: "POST",
          description: "Get average sentiment balance for a crypto asset over a specified number of days.",
          route: "/graphql",
          parameters: [
            {
              position: { key: "asset", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "days", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "number()", options: ["min(1)", "max(90)", "default(7)"] }
            }
          ],
          tests: [{ _description: "Sentiment for Bitcoin 7 days", asset: "bitcoin", days: 7 }],
          modifiers: [
            { phase: "pre", handlerName: "buildSantimentQuery" }
          ]
        },
        get_social_volume: {
          requestMethod: "POST",
          description: "Get total social media volume for a crypto asset.",
          route: "/graphql",
          parameters: [
            {
              position: { key: "asset", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "days", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "number()", options: ["min(1)", "max(90)", "default(7)"] }
            }
          ],
          tests: [{ _description: "Bitcoin 30-day social volume", asset: "bitcoin", days: 30 }],
          modifiers: [{ phase: "pre", handlerName: "buildSantimentQuery" }]
        },
        alert_social_shift: {
          requestMethod: "POST",
          description: "Detect significant changes in social media volume for a crypto asset.",
          route: "/graphql",
          parameters: [
            {
              position: { key: "asset", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "threshold", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "number()", options: ["default(50)"] }
            },
            {
              position: { key: "days", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "number()", options: ["min(2)", "max(30)", "default(7)"] }
            }
          ],
          tests: [{ _description: "Alert for Bitcoin, 50% threshold, 7 days", asset: "bitcoin", threshold: 50, days: 7 }],
          modifiers: [{ phase: "pre", handlerName: "buildSantimentQuery" }]
        },
        get_trending_words: {
          requestMethod: "POST",
          description: "Retrieve top trending words in crypto discussions.",
          route: "/graphql",
          parameters: [
            {
              position: { key: "days", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "number()", options: ["min(1)", "max(30)", "default(7)"] }
            },
            {
              position: { key: "top_n", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "number()", options: ["min(1)", "max(20)", "default(5)"] }
            }
          ],
          tests: [{ _description: "Top 5 trending words over 7 days", days: 7, top_n: 5 }],
          modifiers: [{ phase: "pre", handlerName: "buildSantimentQuery" }]
        },
        get_social_dominance: {
          requestMethod: "POST",
          description: "Get average social dominance for a crypto asset.",
          route: "/graphql",
          parameters: [
            {
              position: { key: "asset", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "days", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "number()", options: ["min(1)", "max(30)", "default(7)"] }
            }
          ],
          tests: [{ _description: "Social dominance for Bitcoin", asset: "bitcoin", days: 7 }],
          modifiers: [{ phase: "pre", handlerName: "buildSantimentQuery" }]
        }
      },
      handlers: {
        buildSantimentQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams, routeName }) => {
          const to = /* @__PURE__ */ new Date();
          const from = new Date(to.getTime() - (userParams.days || 7) * 864e5);
          let query = "";
          const asset = userParams.asset;
          const metrics = {
            get_sentiment_balance: "sentiment_balance_total",
            get_social_volume: "social_volume_total",
            alert_social_shift: "social_volume_total",
            get_social_dominance: "social_dominance_total"
          };
          if (routeName === "get_trending_words") {
            query = `
          {
            getTrendingWords(size: 10, from: "${from.toISOString()}", to: "${to.toISOString()}", interval: "1d") {
              datetime
              topWords {
                word
                score
              }
            }
          }
        `;
          } else if (metrics[routeName]) {
            query = `
          {
            getMetric(metric: "${metrics[routeName]}") {
              timeseriesData(
                slug: "${asset}",
                from: "${from.toISOString()}",
                to: "${to.toISOString()}",
                interval: "1d"
              ) {
                datetime
                value
              }
            }
          }
        `;
          }
          payload["body"] = { query };
          return { struct, payload };
        }, "buildSantimentQuery")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/simdune/balancesEVM.mjs
var balancesEVM_exports = {};
__export(balancesEVM_exports, {
  schema: () => schema87
});
var SUPPORTED_CHAINS, chainAliasEnum, schema87;
var init_balancesEVM = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/simdune/balancesEVM.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED_CHAINS = [
      { alias: "ETHEREUM_MAINNET", id: 1, name: "ethereum" },
      { alias: "BNB_CHAIN", id: 56, name: "bnb" },
      { alias: "POLYGON_MAINNET", id: 137, name: "polygon" },
      { alias: "ARBITRUM_ONE", id: 42161, name: "arbitrum" },
      { alias: "OPTIMISM_MAINNET", id: 10, name: "optimism" },
      { alias: "BASE_MAINNET", id: 8453, name: "base" },
      { alias: "AVALANCHE_CCHAIN", id: 43114, name: "avalanche_c" },
      { alias: "GNOSIS_CHAIN", id: 100, name: "gnosis" },
      { alias: "CELO_MAINNET", id: 42220, name: "celo" },
      { alias: "ZKSYNC_ERA", id: 324, name: "zksync" },
      { alias: "ZORA_NETWORK", id: 7777777, name: "zora" },
      { alias: "LINEA_MAINNET", id: 59144, name: "linea" },
      { alias: "SCROLL", id: 534352, name: "scroll" },
      { alias: "MODE", id: 34443, name: "mode" },
      { alias: "BLAST_MAINNET", id: 81457, name: "blast" },
      { alias: "ARBITRUM_NOVA", id: 42170, name: "arbitrum_nova" },
      { alias: "MANTLE", id: 5e3, name: "mantle" },
      { alias: "METIS", id: 1088, name: "metis" },
      { alias: "FANTOM", id: 250, name: "fantom" },
      { alias: "BOBA_NETWORK", id: 288, name: "boba" },
      { alias: "MINT_MAINNET", id: 185, name: "mint" },
      { alias: "DEGEN_CHAIN", id: 666666666, name: "degen" },
      { alias: "ANCIENT8", id: 888888888, name: "ancient8" },
      { alias: "KAIA", id: 8217, name: "kaia" },
      { alias: "LISK", id: 1135, name: "lisk" },
      { alias: "OPBNB", id: 204, name: "opbnb" },
      { alias: "PROOF_OF_PLAY", id: 70700, name: "proof_of_play" },
      { alias: "CYBER", id: 7560, name: "cyber" },
      { alias: "BOB", id: 60808, name: "bob" },
      { alias: "FLARE", id: 14, name: "flare" },
      { alias: "BERACHAIN", id: 80094, name: "berachain" },
      { alias: "HYPER_EVM", id: 999, name: "hyper_evm" },
      { alias: "BASE_SEPOLIA", id: 84532, name: "base_sepolia" },
      { alias: "AVALANCHE_FUJI", id: 43113, name: "avalanche_fuji" }
    ];
    chainAliasEnum = "enum(";
    chainAliasEnum += SUPPORTED_CHAINS.map(({ alias }) => alias).join(",");
    chainAliasEnum += ")";
    schema87 = {
      namespace: "simdune",
      name: "Sim by Dune - Token Balances",
      description: "Access realtime token balances for native and ERC20 tokens with USD valuations across EVM chains.",
      docs: ["https://docs.sim.dune.com/evm/balances"],
      tags: ["production", "balances", "analytics", "portfolio"],
      flowMCP: "1.2.0",
      root: "https://api.sim.dune.com/v1",
      requiredServerParams: ["DUNE_SIM_API_KEY"],
      headers: { "X-Sim-Api-Key": "{{DUNE_SIM_API_KEY}}" },
      routes: {
        getBalancesEVM: {
          requestMethod: "GET",
          description: "Get realtime token balances with USD valuations for native and ERC20 tokens across supported chains.",
          route: "/evm/balances/{{walletAddress}}",
          parameters: [
            {
              position: { key: "walletAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$)"] }
            },
            /*
                            {
                                position: { key: "chain_ids", value: "{{USER_PARAM}}", location: "query" },
                                z: { primitive: "string()", options: [] }
                            },
            */
            {
              position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: chainAliasEnum, options: [] }
            },
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(1000)"] }
            }
          ],
          tests: [
            {
              _description: "Get Vitalik's token balances on Ethereum",
              walletAddress: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
              chainName: "ETHEREUM_MAINNET",
              limit: "10"
            },
            {
              _description: "Get token balances on Base",
              walletAddress: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
              chainName: "BASE_MAINNET",
              limit: "5"
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" }
          ]
        }
      },
      handlers: {
        insertChainId: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const chainId = SUPPORTED_CHAINS.find(({ alias }) => alias === chainName)?.id;
          payload["url"] += `&chain_ids=${chainId}`;
          return { struct, payload };
        }, "insertChainId")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/simdune/balancesSVM.mjs
var balancesSVM_exports = {};
__export(balancesSVM_exports, {
  schema: () => schema88
});
var SUPPORTED_CHAINS2, chainAliasEnum2, schema88;
var init_balancesSVM = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/simdune/balancesSVM.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED_CHAINS2 = [
      { alias: "SOLANA", id: "solana", name: "solana" },
      { alias: "ECLIPSE", id: "eclipse", name: "eclipse" }
    ];
    chainAliasEnum2 = "enum(";
    chainAliasEnum2 += SUPPORTED_CHAINS2.map(({ alias }) => alias).join(",");
    chainAliasEnum2 += ")";
    schema88 = {
      namespace: "simdune",
      name: "Sim by Dune - SVM Token Balances",
      description: "Access realtime token balances for native, SPL, and SPL-2022 tokens with USD valuations across SVM chains.",
      docs: ["https://docs.sim.dune.com/svm/balances"],
      tags: ["production", "balances", "analytics", "portfolio", "svm", "solana"],
      flowMCP: "1.2.0",
      root: "https://api.sim.dune.com/beta",
      requiredServerParams: ["DUNE_SIM_API_KEY"],
      headers: { "X-Sim-Api-Key": "{{DUNE_SIM_API_KEY}}" },
      routes: {
        getBalancesSVM: {
          requestMethod: "GET",
          description: "Get realtime token balances with USD valuations for native, SPL, and SPL-2022 tokens across supported SVM chains.",
          route: "/svm/balances/{{walletAddress}}",
          parameters: [
            {
              position: { key: "walletAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^[1-9A-HJ-NP-Za-km-z]{32,44}$)"] }
            },
            {
              position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: chainAliasEnum2, options: [] }
            },
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(1000)"] }
            }
          ],
          tests: [
            {
              _description: "Get token balances on Solana",
              walletAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
              chainName: "SOLANA",
              limit: "10"
            },
            {
              _description: "Get token balances on Eclipse",
              walletAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
              chainName: "ECLIPSE",
              limit: "5"
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainName" }
          ]
        }
      },
      handlers: {
        insertChainName: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const chainValue = SUPPORTED_CHAINS2.find(({ alias }) => alias === chainName)?.id;
          const separator = payload["url"].includes("?") ? "&" : "?";
          payload["url"] += `${separator}chains=${chainValue}`;
          return { struct, payload };
        }, "insertChainName")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/simdune/collectiblesEVM.mjs
var collectiblesEVM_exports = {};
__export(collectiblesEVM_exports, {
  schema: () => schema89
});
var SUPPORTED_CHAINS3, chainAliasEnum3, schema89;
var init_collectiblesEVM = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/simdune/collectiblesEVM.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED_CHAINS3 = [
      { alias: "ABSTRACT", id: 2741, name: "abstract" },
      { alias: "ANCIENT8", id: 888888888, name: "ancient8" },
      { alias: "APE_CHAIN", id: 33139, name: "ape_chain" },
      { alias: "ARBITRUM_ONE", id: 42161, name: "arbitrum" },
      { alias: "ARBITRUM_NOVA", id: 42170, name: "arbitrum_nova" },
      { alias: "AVALANCHE_CCHAIN", id: 43114, name: "avalanche_c" },
      { alias: "AVALANCHE_FUJI", id: 43113, name: "avalanche_fuji" },
      { alias: "B3", id: 8333, name: "b3" },
      { alias: "BASE_MAINNET", id: 8453, name: "base" },
      { alias: "BASE_SEPOLIA", id: 84532, name: "base_sepolia" },
      { alias: "BERACHAIN", id: 80094, name: "berachain" },
      { alias: "BLAST_MAINNET", id: 81457, name: "blast" },
      { alias: "BNB_CHAIN", id: 56, name: "bnb" },
      { alias: "BOB", id: 60808, name: "bob" },
      { alias: "BOBA_NETWORK", id: 288, name: "boba" },
      { alias: "CELO_MAINNET", id: 42220, name: "celo" },
      { alias: "CORN", id: 21e6, name: "corn" },
      { alias: "CYBER", id: 7560, name: "cyber" },
      { alias: "DEGEN_CHAIN", id: 666666666, name: "degen" },
      { alias: "ETHEREUM_MAINNET", id: 1, name: "ethereum" },
      { alias: "FANTOM", id: 250, name: "fantom" },
      { alias: "FLARE", id: 14, name: "flare" },
      { alias: "FORMA", id: 984122, name: "forma" },
      { alias: "FRAXTAL", id: 252, name: "fraxtal" },
      { alias: "FUNKICHAIN", id: 33979, name: "funkichain" },
      { alias: "GNOSIS_CHAIN", id: 100, name: "gnosis" },
      { alias: "HAM_CHAIN", id: 5112, name: "ham" },
      { alias: "HYCHAIN", id: 2911, name: "hychain" },
      { alias: "HYPER_EVM", id: 999, name: "hyper_evm" },
      { alias: "INK", id: 57073, name: "ink" },
      { alias: "KAIA", id: 8217, name: "kaia" },
      { alias: "LINEA_MAINNET", id: 59144, name: "linea" },
      { alias: "LISK", id: 1135, name: "lisk" },
      { alias: "MANTLE", id: 5e3, name: "mantle" },
      { alias: "METIS", id: 1088, name: "metis" },
      { alias: "MINT_MAINNET", id: 185, name: "mint" },
      { alias: "MODE", id: 34443, name: "mode" },
      { alias: "MONAD_TESTNET", id: 10143, name: "monad_testnet" },
      { alias: "OMNI", id: 166, name: "omni" },
      { alias: "OPBNB", id: 204, name: "opbnb" },
      { alias: "OPTIMISM_MAINNET", id: 10, name: "optimism" },
      { alias: "POLYGON_MAINNET", id: 137, name: "polygon" },
      { alias: "PROOF_OF_PLAY", id: 70700, name: "proof_of_play" },
      { alias: "PROOF_OF_PLAY_BOSS", id: 70701, name: "proof_of_play_boss" },
      { alias: "RARI", id: 1380012617, name: "rari" },
      { alias: "REDSTONE", id: 690, name: "redstone" },
      { alias: "RONIN", id: 2020, name: "ronin" },
      { alias: "SCROLL", id: 534352, name: "scroll" },
      { alias: "SEI", id: 1329, name: "sei" },
      { alias: "ETHEREUM_SEPOLIA", id: 11155111, name: "sepolia" },
      { alias: "SHAPE", id: 360, name: "shape" },
      { alias: "SONEIUM", id: 1868, name: "soneium" },
      { alias: "SONIC", id: 146, name: "sonic" },
      { alias: "SUPERPOSITION", id: 55244, name: "superposition" },
      { alias: "SUPERSEED", id: 5330, name: "superseed" },
      { alias: "SWELLCHAIN", id: 1923, name: "swellchain" },
      { alias: "TRON", id: 728126428, name: "tron" },
      { alias: "UNICHAIN", id: 130, name: "unichain" },
      { alias: "WEMIX", id: 1111, name: "wemix" },
      { alias: "WORLD", id: 480, name: "world" },
      { alias: "XAI", id: 660279, name: "xai" },
      { alias: "ZERO_NETWORK", id: 543210, name: "zero_network" },
      { alias: "ZKEVM", id: 1101, name: "zkevm" },
      { alias: "ZKSYNC_ERA", id: 324, name: "zksync" },
      { alias: "ZORA_NETWORK", id: 7777777, name: "zora" }
    ];
    chainAliasEnum3 = "enum(";
    chainAliasEnum3 += SUPPORTED_CHAINS3.map(({ alias }) => alias).join(",");
    chainAliasEnum3 += ")";
    schema89 = {
      namespace: "simdune",
      name: "Sim by Dune - NFT Collectibles",
      description: "Access NFT collections including ERC721 and ERC1155 tokens with metadata, images, and collection details across EVM chains.",
      docs: ["https://docs.sim.dune.com/evm/collectibles"],
      tags: ["production", "nft", "collectibles", "metadata"],
      flowMCP: "1.2.0",
      root: "https://api.sim.dune.com/v1",
      requiredServerParams: ["DUNE_SIM_API_KEY"],
      headers: { "X-Sim-Api-Key": "{{DUNE_SIM_API_KEY}}" },
      routes: {
        getCollectiblesEVM: {
          requestMethod: "GET",
          description: "Get NFT collectibles (ERC721/ERC1155) with metadata, images, and collection details for a wallet address.",
          route: "/evm/collectibles/{{walletAddress}}",
          parameters: [
            {
              position: { key: "walletAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$)"] }
            },
            {
              position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: chainAliasEnum3, options: [] }
            },
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(2500)"] }
            }
          ],
          tests: [
            {
              _description: "Get Vitalik's NFT collectibles on Ethereum",
              walletAddress: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
              limit: "10",
              chainName: "ETHEREUM_MAINNET"
            },
            {
              _description: "Get NFT collectibles on Base",
              walletAddress: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
              limit: "5",
              chainName: "BASE_MAINNET"
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" }
          ]
        }
      },
      handlers: {
        insertChainId: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const chainId = SUPPORTED_CHAINS3.find(({ alias }) => alias === chainName)?.id;
          const separator = payload["url"].includes("?") ? "&" : "?";
          payload["url"] += `${separator}chain_ids=${chainId}`;
          return { struct, payload };
        }, "insertChainId")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/simdune/tokenHoldersEVM.mjs
var tokenHoldersEVM_exports = {};
__export(tokenHoldersEVM_exports, {
  schema: () => schema90
});
var SUPPORTED_CHAINS4, schema90;
var init_tokenHoldersEVM = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/simdune/tokenHoldersEVM.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED_CHAINS4 = [
      { alias: "ABSTRACT", id: 2741, name: "abstract" },
      { alias: "ANCIENT8", id: 888888888, name: "ancient8" },
      { alias: "APE_CHAIN", id: 33139, name: "ape_chain" },
      { alias: "ARBITRUM_ONE", id: 42161, name: "arbitrum" },
      { alias: "ARBITRUM_NOVA", id: 42170, name: "arbitrum_nova" },
      { alias: "AVALANCHE_CCHAIN", id: 43114, name: "avalanche_c" },
      { alias: "AVALANCHE_FUJI", id: 43113, name: "avalanche_fuji" },
      { alias: "BASE_MAINNET", id: 8453, name: "base" },
      { alias: "BASE_SEPOLIA", id: 84532, name: "base_sepolia" },
      { alias: "BERACHAIN", id: 80094, name: "berachain" },
      { alias: "BLAST_MAINNET", id: 81457, name: "blast" },
      { alias: "BNB_CHAIN", id: 56, name: "bnb" },
      { alias: "BOB", id: 60808, name: "bob" },
      { alias: "BOBA_NETWORK", id: 288, name: "boba" },
      { alias: "CELO_MAINNET", id: 42220, name: "celo" },
      { alias: "CORN", id: 21e6, name: "corn" },
      { alias: "CYBER", id: 7560, name: "cyber" },
      { alias: "DEGEN_CHAIN", id: 666666666, name: "degen" },
      { alias: "ETHEREUM_MAINNET", id: 1, name: "ethereum" },
      { alias: "FANTOM", id: 250, name: "fantom" },
      { alias: "FLARE", id: 14, name: "flare" },
      { alias: "GNOSIS_CHAIN", id: 100, name: "gnosis" },
      { alias: "HAM_CHAIN", id: 5112, name: "ham" },
      { alias: "HYCHAIN", id: 2911, name: "hychain" },
      { alias: "HYPER_EVM", id: 999, name: "hyper_evm" },
      { alias: "INK", id: 57073, name: "ink" },
      { alias: "KAIA", id: 8217, name: "kaia" },
      { alias: "LINEA_MAINNET", id: 59144, name: "linea" },
      { alias: "LISK", id: 1135, name: "lisk" },
      { alias: "MANTLE", id: 5e3, name: "mantle" },
      { alias: "METIS", id: 1088, name: "metis" },
      { alias: "MINT_MAINNET", id: 185, name: "mint" },
      { alias: "MODE", id: 34443, name: "mode" },
      { alias: "OMNI", id: 166, name: "omni" },
      { alias: "OPBNB", id: 204, name: "opbnb" },
      { alias: "OPTIMISM_MAINNET", id: 10, name: "optimism" },
      { alias: "POLYGON_MAINNET", id: 137, name: "polygon" },
      { alias: "PROOF_OF_PLAY", id: 70700, name: "proof_of_play" }
    ];
    schema90 = {
      namespace: "simdune",
      name: "Sim by Dune - Token Holders",
      description: "Discover token distribution across ERC20 or ERC721 holders, ranked by wallet value.",
      docs: ["https://docs.sim.dune.com/evm/token-holders"],
      tags: ["production", "token", "analytics", "holders"],
      flowMCP: "1.2.0",
      root: "https://api.sim.dune.com/v1",
      requiredServerParams: ["DUNE_SIM_API_KEY"],
      headers: { "X-Sim-Api-Key": "{{DUNE_SIM_API_KEY}}" },
      routes: {
        getTokenHoldersEVM: {
          requestMethod: "GET",
          description: "Get token holders for ERC20 or ERC721 tokens, ranked by wallet value with balance details.",
          route: "/evm/token-holders/{{chain_id}}/{{token_address}}",
          parameters: [
            {
              position: { key: "chain_id", value: "{{USER_PARAM}}", location: "insert" },
              z: {
                primitive: "enum(" + SUPPORTED_CHAINS4.map((c) => c.id).join(",") + ")",
                options: []
              }
            },
            {
              position: { key: "token_address", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$)"] }
            },
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(500)"] }
            }
          ],
          tests: [
            {
              _description: "Get USDC holders on Base",
              chain_id: "8453",
              token_address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
              limit: "10"
            },
            {
              _description: "Get ETH holders on Ethereum mainnet",
              chain_id: "1",
              token_address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
              limit: "5"
            }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/simdune/tokenInfoEVM.mjs
var tokenInfoEVM_exports = {};
__export(tokenInfoEVM_exports, {
  schema: () => schema91
});
var SUPPORTED_CHAINS5, chainAliasEnum4, schema91;
var init_tokenInfoEVM = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/simdune/tokenInfoEVM.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED_CHAINS5 = [
      { alias: "ABSTRACT", id: 2741, name: "abstract" },
      { alias: "ANCIENT8", id: 888888888, name: "ancient8" },
      { alias: "APE_CHAIN", id: 33139, name: "ape_chain" },
      { alias: "ARBITRUM_ONE", id: 42161, name: "arbitrum" },
      { alias: "ARBITRUM_NOVA", id: 42170, name: "arbitrum_nova" },
      { alias: "AVALANCHE_CCHAIN", id: 43114, name: "avalanche_c" },
      { alias: "AVALANCHE_FUJI", id: 43113, name: "avalanche_fuji" },
      { alias: "B3", id: 8333, name: "b3" },
      { alias: "BASE_MAINNET", id: 8453, name: "base" },
      { alias: "BASE_SEPOLIA", id: 84532, name: "base_sepolia" },
      { alias: "BERACHAIN", id: 80094, name: "berachain" },
      { alias: "BLAST_MAINNET", id: 81457, name: "blast" },
      { alias: "BNB_CHAIN", id: 56, name: "bnb" },
      { alias: "BOB", id: 60808, name: "bob" },
      { alias: "BOBA_NETWORK", id: 288, name: "boba" },
      { alias: "CELO_MAINNET", id: 42220, name: "celo" },
      { alias: "CORN", id: 21e6, name: "corn" },
      { alias: "CYBER", id: 7560, name: "cyber" },
      { alias: "DEGEN_CHAIN", id: 666666666, name: "degen" },
      { alias: "ETHEREUM_MAINNET", id: 1, name: "ethereum" },
      { alias: "FANTOM", id: 250, name: "fantom" },
      { alias: "FLARE", id: 14, name: "flare" },
      { alias: "FLOW", id: 747, name: "flow" },
      { alias: "FORMA", id: 984122, name: "forma" },
      { alias: "FRAXTAL", id: 252, name: "fraxtal" },
      { alias: "FUNKICHAIN", id: 33979, name: "funkichain" },
      { alias: "GNOSIS_CHAIN", id: 100, name: "gnosis" },
      { alias: "HAM_CHAIN", id: 5112, name: "ham" },
      { alias: "HEMI", id: 43111, name: "hemi" },
      { alias: "HYCHAIN", id: 2911, name: "hychain" },
      { alias: "HYPER_EVM", id: 999, name: "hyper_evm" },
      { alias: "INK", id: 57073, name: "ink" },
      { alias: "KAIA", id: 8217, name: "kaia" },
      { alias: "KATANA", id: 747474, name: "katana" },
      { alias: "LENS", id: 232, name: "lens" },
      { alias: "LINEA_MAINNET", id: 59144, name: "linea" },
      { alias: "LISK", id: 1135, name: "lisk" },
      { alias: "MANTLE", id: 5e3, name: "mantle" },
      { alias: "METIS", id: 1088, name: "metis" },
      { alias: "MINT_MAINNET", id: 185, name: "mint" },
      { alias: "MODE", id: 34443, name: "mode" },
      { alias: "MONAD_TESTNET", id: 10143, name: "monad_testnet" },
      { alias: "OMNI", id: 166, name: "omni" },
      { alias: "OPBNB", id: 204, name: "opbnb" },
      { alias: "OPTIMISM_MAINNET", id: 10, name: "optimism" },
      { alias: "PLUME", id: 98866, name: "plume" },
      { alias: "POLYGON_MAINNET", id: 137, name: "polygon" },
      { alias: "PROOF_OF_PLAY", id: 70700, name: "proof_of_play" },
      { alias: "PROOF_OF_PLAY_BOSS", id: 70701, name: "proof_of_play_boss" },
      { alias: "RARI", id: 1380012617, name: "rari" },
      { alias: "REDSTONE", id: 690, name: "redstone" },
      { alias: "RONIN", id: 2020, name: "ronin" },
      { alias: "SCROLL", id: 534352, name: "scroll" },
      { alias: "SEI", id: 1329, name: "sei" },
      { alias: "ETHEREUM_SEPOLIA", id: 11155111, name: "sepolia" },
      { alias: "SHAPE", id: 360, name: "shape" },
      { alias: "SOMNIA", id: 5031, name: "somnia" },
      { alias: "SONEIUM", id: 1868, name: "soneium" },
      { alias: "SONIC", id: 146, name: "sonic" },
      { alias: "SOPHON", id: 50104, name: "sophon" },
      { alias: "SUPERPOSITION", id: 55244, name: "superposition" },
      { alias: "SUPERSEED", id: 5330, name: "superseed" },
      { alias: "SWELLCHAIN", id: 1923, name: "swellchain" },
      { alias: "TAC", id: 239, name: "tac" },
      { alias: "TAIKO", id: 167e3, name: "taiko" },
      { alias: "UNICHAIN", id: 130, name: "unichain" },
      { alias: "WEMIX", id: 1111, name: "wemix" },
      { alias: "WORLD", id: 480, name: "world" },
      { alias: "XAI", id: 660279, name: "xai" },
      { alias: "ZERO_NETWORK", id: 543210, name: "zero_network" },
      { alias: "ZKEVM", id: 1101, name: "zkevm" },
      { alias: "ZKSYNC_ERA", id: 324, name: "zksync" },
      { alias: "ZORA_NETWORK", id: 7777777, name: "zora" }
    ];
    chainAliasEnum4 = "enum(";
    chainAliasEnum4 += SUPPORTED_CHAINS5.map(({ alias }) => alias).join(",");
    chainAliasEnum4 += ")";
    schema91 = {
      namespace: "simdune",
      name: "Sim by Dune - Token Info",
      description: "Access token metadata including symbol, name, decimals, USD price, and logo URLs for native and ERC20 tokens across EVM chains.",
      docs: ["https://docs.sim.dune.com/evm/token-info"],
      tags: ["production", "token", "analytics", "metadata"],
      flowMCP: "1.2.0",
      root: "https://api.sim.dune.com/v1",
      requiredServerParams: ["DUNE_SIM_API_KEY"],
      headers: { "X-Sim-Api-Key": "{{DUNE_SIM_API_KEY}}" },
      routes: {
        getTokenInfoEVM: {
          requestMethod: "GET",
          description: "Get token metadata including symbol, name, decimals, USD price, and logo URLs for native and ERC20 tokens.",
          route: "/evm/token-info/{{tokenAddress}}",
          parameters: [
            {
              position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$|^native$)"] }
            },
            {
              position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: chainAliasEnum4, options: [] }
            }
          ],
          tests: [
            {
              _description: "Get USDC token info on Ethereum",
              tokenAddress: "0xA0b86a33E6441e73C117D820D0a2e7Bc91C0a644",
              chainName: "ETHEREUM_MAINNET"
            },
            {
              _description: "Get native ETH info",
              tokenAddress: "native",
              chainName: "ETHEREUM_MAINNET"
            },
            {
              _description: "Get USDC token info on Base",
              tokenAddress: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
              chainName: "BASE_MAINNET"
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" }
          ]
        }
      },
      handlers: {
        insertChainId: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const chainId = SUPPORTED_CHAINS5.find(({ alias }) => alias === chainName)?.id;
          const separator = payload["url"].includes("?") ? "&" : "?";
          payload["url"] += `${separator}chain_ids=${chainId}`;
          return { struct, payload };
        }, "insertChainId")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/simdune/transactionsEVM.mjs
var transactionsEVM_exports = {};
__export(transactionsEVM_exports, {
  schema: () => schema92
});
var SUPPORTED_CHAINS6, chainAliasEnum5, schema92;
var init_transactionsEVM = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/simdune/transactionsEVM.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED_CHAINS6 = [
      { alias: "ETHEREUM_MAINNET", id: 1, name: "ethereum" },
      { alias: "ARBITRUM_ONE", id: 42161, name: "arbitrum" },
      { alias: "ARBITRUM_NOVA", id: 42170, name: "arbitrum_nova" },
      { alias: "AVALANCHE_CCHAIN", id: 43114, name: "avalanche_c" },
      { alias: "AVALANCHE_FUJI", id: 43113, name: "avalanche_fuji" },
      { alias: "BASE_MAINNET", id: 8453, name: "base" },
      { alias: "BASE_SEPOLIA", id: 84532, name: "base_sepolia" },
      { alias: "BNB_CHAIN", id: 56, name: "bnb" },
      { alias: "CELO_MAINNET", id: 42220, name: "celo" },
      { alias: "GNOSIS_CHAIN", id: 100, name: "gnosis" },
      { alias: "OPTIMISM_MAINNET", id: 10, name: "optimism" },
      { alias: "POLYGON_MAINNET", id: 137, name: "polygon" },
      { alias: "ZKSYNC_ERA", id: 324, name: "zksync" },
      { alias: "ZORA_NETWORK", id: 7777777, name: "zora" },
      { alias: "LINEA_MAINNET", id: 59144, name: "linea" },
      { alias: "SCROLL", id: 534352, name: "scroll" },
      { alias: "MODE", id: 34443, name: "mode" },
      { alias: "BLAST_MAINNET", id: 81457, name: "blast" },
      { alias: "ANCIENT8", id: 888888888, name: "ancient8" },
      { alias: "DEGEN_CHAIN", id: 666666666, name: "degen" },
      { alias: "MANTLE", id: 5e3, name: "mantle" },
      { alias: "METIS", id: 1088, name: "metis" },
      { alias: "FANTOM", id: 250, name: "fantom" },
      { alias: "BOBA_NETWORK", id: 288, name: "boba" },
      { alias: "MINT_MAINNET", id: 185, name: "mint" },
      { alias: "HYPER_EVM", id: 999, name: "hyper_evm" },
      { alias: "KAIA", id: 8217, name: "kaia" },
      { alias: "LISK", id: 1135, name: "lisk" },
      { alias: "OPBNB", id: 204, name: "opbnb" },
      { alias: "PROOF_OF_PLAY", id: 70700, name: "proof_of_play" },
      { alias: "CYBER", id: 7560, name: "cyber" },
      { alias: "BOB", id: 60808, name: "bob" },
      { alias: "FLARE", id: 14, name: "flare" },
      { alias: "BERACHAIN", id: 80094, name: "berachain" }
    ];
    chainAliasEnum5 = "enum(";
    chainAliasEnum5 += SUPPORTED_CHAINS6.map(({ alias }) => alias).join(",");
    chainAliasEnum5 += ")";
    schema92 = {
      namespace: "simdune",
      name: "Sim by Dune - Transactions",
      description: "Retrieve granular transaction details including block information, gas data, and raw values, ordered by descending block time.",
      docs: ["https://docs.sim.dune.com/evm/transactions"],
      tags: ["production", "transactions", "analytics", "history"],
      flowMCP: "1.2.0",
      root: "https://api.sim.dune.com/v1",
      requiredServerParams: ["DUNE_SIM_API_KEY"],
      headers: { "X-Sim-Api-Key": "{{DUNE_SIM_API_KEY}}" },
      routes: {
        getTransactionsEVM: {
          requestMethod: "GET",
          description: "Get detailed transaction history for an EVM address across supported chains, with block data and gas information.",
          route: "/evm/transactions/{{walletAddress}}",
          parameters: [
            {
              position: { key: "walletAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^0x[a-fA-F0-9]{40}$)"] }
            },
            {
              position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: chainAliasEnum5, options: [] }
            },
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(100)"] }
            }
          ],
          tests: [
            {
              _description: "Get Vitalik's transactions on Ethereum mainnet",
              walletAddress: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
              limit: "5",
              chainName: "ETHEREUM_MAINNET"
            },
            {
              _description: "Get transactions on Base mainnet",
              walletAddress: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
              limit: "3",
              chainName: "BASE_MAINNET"
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainId" }
          ]
        }
      },
      handlers: {
        insertChainId: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const chainId = SUPPORTED_CHAINS6.find(({ alias }) => alias === chainName)?.id;
          const separator = payload["url"].includes("?") ? "&" : "?";
          payload["url"] += `${separator}chain_ids=${chainId}`;
          return { struct, payload };
        }, "insertChainId")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/simdune/transactionsSVM.mjs
var transactionsSVM_exports = {};
__export(transactionsSVM_exports, {
  schema: () => schema93
});
var SUPPORTED_CHAINS7, chainAliasEnum6, schema93;
var init_transactionsSVM = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/simdune/transactionsSVM.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED_CHAINS7 = [
      { alias: "SOLANA", id: "solana", name: "solana" }
    ];
    chainAliasEnum6 = "enum(";
    chainAliasEnum6 += SUPPORTED_CHAINS7.map(({ alias }) => alias).join(",");
    chainAliasEnum6 += ")";
    schema93 = {
      namespace: "simdune",
      name: "Sim by Dune - SVM Transactions",
      description: "Retrieve detailed transaction history for SVM addresses including block information, ordered by descending block time.",
      docs: ["https://docs.sim.dune.com/svm/transactions"],
      tags: ["production", "transactions", "analytics", "history", "svm", "solana"],
      flowMCP: "1.2.0",
      root: "https://api.sim.dune.com/beta",
      requiredServerParams: ["DUNE_SIM_API_KEY"],
      headers: { "X-Sim-Api-Key": "{{DUNE_SIM_API_KEY}}" },
      routes: {
        getTransactionsSVM: {
          requestMethod: "GET",
          description: "Get detailed transaction history for an SVM address, ordered by descending block time with pagination support.",
          route: "/svm/transactions/{{walletAddress}}",
          parameters: [
            {
              position: { key: "walletAddress", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["regex(^[1-9A-HJ-NP-Za-km-z]{32,44}$)"] }
            },
            {
              position: { key: "chainName", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: chainAliasEnum6, options: [] }
            },
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(1000)"] }
            }
          ],
          tests: [
            {
              _description: "Get transactions on Solana with default limit",
              walletAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
              chainName: "SOLANA",
              limit: "10"
            },
            {
              _description: "Get recent transactions on Solana with small limit",
              walletAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
              chainName: "SOLANA",
              limit: "5"
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "insertChainName" }
          ]
        }
      },
      handlers: {
        insertChainName: /* @__PURE__ */ __name(({ struct, payload, userParams }) => {
          const { chainName } = userParams;
          const chainValue = SUPPORTED_CHAINS7.find(({ alias }) => alias === chainName)?.id;
          return { struct, payload };
        }, "insertChainName")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/snapshot/snapshot.mjs
var snapshot_exports = {};
__export(snapshot_exports, {
  schema: () => schema94
});
var schema94;
var init_snapshot = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/snapshot/snapshot.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema94 = {
      namespace: "snapshot",
      name: "Snapshot DAO Proposals",
      description: "Query Snapshot GraphQL API to retrieve DAO spaces and proposals",
      docs: ["https://docs.snapshot.org/"],
      tags: ["dao", "governance", "voting"],
      flowMCP: "1.2.0",
      root: "https://hub.snapshot.org/graphql",
      requiredServerParams: [],
      headers: { "content-type": "application/json" },
      routes: {
        listSpaces: {
          requestMethod: "POST",
          description: "Fetch a list of available Snapshot spaces",
          route: "/",
          parameters: [
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] } }
          ],
          tests: [{ _description: "Test list of Snapshot spaces", first: 10 }],
          modifiers: [{ phase: "pre", handlerName: "buildListSpaces" }]
        },
        listProposals: {
          requestMethod: "POST",
          description: "Fetch recent proposals for a given Snapshot space",
          route: "/",
          parameters: [
            { position: { key: "space", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "first", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "number()", options: ["min(1)", "max(100)", "default(10)"] } }
          ],
          tests: [{ _description: "Fetch proposals for ENS space", space: "ens.eth", first: 10 }],
          modifiers: [{ phase: "pre", handlerName: "buildListProposals" }]
        },
        getProposalDetails: {
          requestMethod: "POST",
          description: "Fetch detailed information for a specific proposal",
          route: "/",
          parameters: [
            { position: { key: "proposalId", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [{ _description: "Fetch proposal details for a known proposal ID", proposalId: "0x123abc456def" }],
          modifiers: [{ phase: "pre", handlerName: "buildGetProposalDetails" }]
        }
      },
      handlers: {
        buildListSpaces: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { first } = userParams;
          payload.body = {
            query: `query Spaces($first: Int!) {
  spaces(first: $first, orderBy: "created", orderDirection: desc) {
    id
    name
    about
    network
    admins
    members
    proposalsCount
    followersCount
  }
}`,
            variables: { first }
          };
          return { struct, payload };
        }, "buildListSpaces"),
        buildListProposals: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { space, first } = userParams;
          payload.body = {
            query: `query Proposals($space: String!, $first: Int!) {
  proposals(first: $first, orderBy: "created", orderDirection: desc, where: { space: $space }) {
    id
    title
    body
    state
    created
    end
    choices
    scores
    votes
    author
    space {
      id
      name
    }
  }
}`,
            variables: { space, first }
          };
          return { struct, payload };
        }, "buildListProposals"),
        buildGetProposalDetails: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { proposalId } = userParams;
          payload.body = {
            query: `query Proposal($id: String!) {
  proposal(id: $id) {
    id
    title
    body
    state
    created
    end
    choices
    scores
    votes
    author
    space {
      id
      name
    }
    strategies {
      name
      params
    }
  }
}`,
            variables: { id: proposalId }
          };
          return { struct, payload };
        }, "buildGetProposalDetails")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--additionalRoutes.mjs
var additionalRoutes_exports = {};
__export(additionalRoutes_exports, {
  schema: () => schema95
});
var schema95;
var init_additionalRoutes = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--additionalRoutes.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema95 = {
      namespace: "solanatracker",
      name: "TokenStatsAPI",
      description: "Provides detailed statistics for tokens and token-pool pairs over multiple time intervals.",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      routes: {
        tokenStats: {
          requestMethod: "GET",
          description: "Get detailed stats for a token over various time intervals.",
          route: "/stats/:token",
          parameters: [
            { position: { key: "token", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test tokenStats", token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }
          ],
          modifiers: [
            { phase: "post", handlerName: "parseExecute" }
          ]
        },
        tokenStatsByPool: {
          requestMethod: "GET",
          description: "Get detailed stats for a token-pool pair over various time intervals.",
          route: "/stats/:token/:pool",
          parameters: [
            { position: { key: "token", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "pool", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test tokenStatsByPool", token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump", pool: "9Tb2ohu5P16BpBarqd3N27WnkF51Ukfs8Z1GzzLDxVZW" }
          ],
          modifiers: [
            { phase: "post", handlerName: "parseExecute" }
          ]
        }
      },
      handlers: {
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "parseExecute")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--chartRoutes.mjs
var chartRoutes_exports = {};
__export(chartRoutes_exports, {
  schema: () => schema96
});
var schema96;
var init_chartRoutes = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--chartRoutes.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema96 = {
      namespace: "solanatracker",
      name: "TokenChartAPI",
      description: "Schema for accessing OHLCV and holder chart data for specific tokens and pools.",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      routes: {
        chartData: {
          requestMethod: "GET",
          description: "Get OHLCV (Open, High, Low, Close, Volume) chart data for a token.",
          route: "/chart/:token",
          parameters: [
            { position: { key: "token", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "time_from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "time_to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "marketCap", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } },
            { position: { key: "removeOutliers", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()", "default(true)"] } }
          ],
          tests: [
            { _description: "Test chartData", token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        chartDataByPool: {
          requestMethod: "GET",
          description: "Get OHLCV chart data for a specific token in a specific pool.",
          route: "/chart/:token/:pool",
          parameters: [
            { position: { key: "token", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "pool", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "type", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "time_from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "time_to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "marketCap", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } },
            { position: { key: "removeOutliers", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()", "default(true)"] } }
          ],
          tests: [
            { _description: "Test chartDataByPool", token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump", pool: "9Tb2ohu5P16BpBarqd3N27WnkF51Ukfs8Z1GzzLDxVZW" }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        }
      },
      handlers: {
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].error) {
            struct["status"] = false;
            struct["messages"].push(struct["data"].error);
            return { struct, payload };
          }
          return { struct, payload };
        }, "parseExecute")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--pnlRoutes.mjs
var pnlRoutes_exports = {};
__export(pnlRoutes_exports, {
  schema: () => schema97
});
var schema97;
var init_pnlRoutes = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--pnlRoutes.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema97 = {
      namespace: "solanatracker",
      name: "PnL Analytics API",
      description: "API to retrieve profit and loss data for wallets and tokens on-chain.",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      routes: {
        profitAndLossData: {
          requestMethod: "GET",
          description: "Get Profit and Loss data for all positions of a wallet.",
          route: "/pnl/:wallet",
          parameters: [
            {
              position: { key: "wallet", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "showHistoricPnL", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "boolean()", options: ["optional()"] }
            },
            {
              position: { key: "holdingCheck", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "boolean()", options: ["optional()"] }
            },
            {
              position: { key: "hideDetails", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "boolean()", options: ["optional()"] }
            }
          ],
          tests: [
            {
              _description: "Test profitAndLossData",
              wallet: "suqh5sHtr8HyJ7q8scBimULPkPpA557prMG47xCHQfK"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        pnlForSpecificToken: {
          requestMethod: "GET",
          description: "Get Profit and Loss data for a specific token in a wallet.",
          route: "/pnl/:wallet/:token",
          parameters: [
            {
              position: { key: "wallet", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "token", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Test pnlForSpecificToken",
              wallet: "suqh5sHtr8HyJ7q8scBimULPkPpA557prMG47xCHQfK",
              token: "3PNjMce2VoGkMTFyipGuAApfHGjEkPRQr1Xqgf5Xpump"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        firstBuyers: {
          requestMethod: "GET",
          description: "Get the first 100 buyers of a token, with full PnL breakdown per wallet.",
          route: "/first-buyers/:token",
          parameters: [
            {
              position: { key: "token", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Test firstBuyers",
              token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        }
      },
      handlers: {
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].error) {
            struct["status"] = false;
            struct["messages"].push(struct["data"].error);
            return { struct, payload };
          }
          return { struct, payload };
        }, "parseExecute")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--priceEndpoints.mjs
var priceEndpoints_exports = {};
__export(priceEndpoints_exports, {
  schema: () => schema98
});
var schema98;
var init_priceEndpoints = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--priceEndpoints.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema98 = {
      namespace: "solanatracker",
      name: "TokenPriceAPI",
      description: "Provides real-time and historical token price information",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      routes: {
        priceInformation: {
          requestMethod: "GET",
          description: "Get price information for a single token.",
          route: "/price",
          parameters: [
            {
              position: { key: "token", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "priceChanges", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "boolean()", options: ["optional()"] }
            }
          ],
          tests: [
            {
              _description: "Test priceInformation",
              token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        postPrice: {
          requestMethod: "POST",
          description: "Similar to GET /price, but accepts token address in the request body.",
          route: "/price",
          parameters: [
            {
              position: { key: "token", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "string()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Test postPrice",
              token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        multiPriceInformation: {
          requestMethod: "GET",
          description: "Get price information for multiple tokens (up to 100).",
          route: "/price/multi",
          parameters: [
            {
              position: { key: "tokens", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "object()", options: [] }
            },
            {
              position: { key: "priceChanges", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "boolean()", options: ["optional()"] }
            }
          ],
          tests: [
            {
              _description: "Test multiPriceInformation",
              tokens: ["CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump"]
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        getHistoricPrice: {
          requestMethod: "GET",
          description: "Get historic price points for a token (3d, 5d, 7d, 14d, 30d).",
          route: "/price/history",
          parameters: [
            {
              position: { key: "token", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Test getHistoricPrice",
              token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        getPriceAtTimestamp: {
          requestMethod: "GET",
          description: "Get price at a specific timestamp for a token.",
          route: "/price/history/timestamp",
          parameters: [
            {
              position: { key: "token", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "timestamp", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Test getPriceAtTimestamp",
              token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump",
              timestamp: 1713907200
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        getPriceRange: {
          requestMethod: "GET",
          description: "Get lowest and highest prices for a token within a time range.",
          route: "/price/history/range",
          parameters: [
            {
              position: { key: "token", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "time_from", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: [] }
            },
            {
              position: { key: "time_to", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Test getPriceRange",
              token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump",
              time_from: 1738368e3,
              time_to: 1738540800
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        postMultiPrice: {
          requestMethod: "POST",
          description: "Get price info for multiple tokens (POST version).",
          route: "/price/multi",
          parameters: [
            {
              position: { key: "tokens", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "object()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Test postMultiPrice",
              tokens: ["CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump", "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump"]
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "beforeExecute" },
            { phase: "post", handlerName: "parseExecute" }
          ]
        }
      },
      handlers: {
        beforeExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "beforeExecute"),
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].error) {
            struct["status"] = false;
            struct["messages"].push(struct["data"].error);
            return { struct, payload };
          }
          return { struct, payload };
        }, "parseExecute")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--tokenEndpoints.mjs
var tokenEndpoints_exports = {};
__export(tokenEndpoints_exports, {
  schema: () => schema99
});
var schema99;
var init_tokenEndpoints = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--tokenEndpoints.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema99 = {
      namespace: "solanatracker",
      name: "TokenAPI",
      description: "Provides endpoints for retrieving information about tokens, their holders, search capabilities, and statistical metrics like volume and trending status.",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      handlers: {
        beforeExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          return { struct, payload };
        }, "beforeExecute"),
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].error) {
            struct["status"] = false;
            struct["messages"].push(struct["data"].error);
            return { struct, payload };
          }
          return { struct, payload };
        }, "parseExecute")
      },
      routes: {
        tokenInformation: {
          requestMethod: "GET",
          description: "Retrieve all information for a specific token.",
          route: "/tokens/:tokenAddress",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test tokenInformation", tokenAddress: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }],
          modifiers: [{ phase: "pre", handlerName: "beforeExecute" }]
        },
        tokenHolders: {
          requestMethod: "GET",
          description: "Get the top 100 holders for a specific token.",
          route: "/tokens/:tokenAddress/holders",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test tokenHolders", tokenAddress: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        topTokenHolders: {
          requestMethod: "GET",
          description: "Get top 20 token holders",
          route: "/tokens/:tokenAddress/holders/top",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test topTokenHolders", tokenAddress: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        allTimeHighPrice: {
          requestMethod: "GET",
          description: "Get all-time high price of a token",
          route: "/tokens/:tokenAddress/ath",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test allTimeHighPrice", tokenAddress: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        tokensByDeployer: {
          requestMethod: "GET",
          description: "Get all tokens deployed by a specific wallet",
          route: "/deployer/:wallet",
          parameters: [
            { position: { key: "wallet", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test tokensByDeployer", wallet: "wallet123" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        search: {
          requestMethod: "GET",
          description: "Advanced token search with filtering and pagination.",
          route: "/search",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "minLiquidity", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "maxLiquidity", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()"] } },
            { position: { key: "market", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [{ _description: "Test search", query: "soybean", market: "pumpfun" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        latestTokens: {
          requestMethod: "GET",
          description: "Retrieve the latest 100 tokens.",
          route: "/tokens/latest",
          parameters: [],
          tests: [{ _description: "Test latestTokens" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        multipleTokens: {
          requestMethod: "POST",
          description: "Get multiple tokens by array of addresses (max 20)",
          route: "/tokens/multi",
          parameters: [],
          tests: [{ _description: "Test multipleTokens" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        trendingTokens: {
          requestMethod: "GET",
          description: "Get the top 100 trending tokens based on transaction volume in the past hour.",
          route: "/tokens/trending",
          parameters: [],
          tests: [{ _description: "Test trendingTokens" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        tokensByVolume: {
          requestMethod: "GET",
          description: "Get top 100 tokens by volume (default timeframe)",
          route: "/tokens/volume",
          parameters: [],
          tests: [{ _description: "Test tokensByVolume" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        tokenOverview: {
          requestMethod: "GET",
          description: "Overview of latest, graduating, and graduated tokens",
          route: "/tokens/multi/all",
          parameters: [],
          tests: [{ _description: "Test tokenOverview" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        graduatedTokens: {
          requestMethod: "GET",
          description: "Overview of all graduated tokens (Pumpvision/Moonshot)",
          route: "/tokens/multi/graduated",
          parameters: [],
          tests: [{ _description: "Test graduatedTokens" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        tokenByPool: {
          requestMethod: "GET",
          description: "Get token by pool address.",
          route: "/tokens/by-pool/:poolAddress",
          parameters: [
            { position: { key: "poolAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test tokenByPool", poolAddress: "pool123" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        trendingTokensByTimeframe: {
          requestMethod: "GET",
          description: "Get trending tokens by specific timeframe (e.g., 5m, 24h).",
          route: "/tokens/trending/:timeframe",
          parameters: [
            { position: { key: "timeframe", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test trendingTokensByTimeframe", timeframe: "24h" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        tokensByVolumeTimeframe: {
          requestMethod: "GET",
          description: "Get top 100 tokens by volume for a specific timeframe.",
          route: "/tokens/volume/:timeframe",
          parameters: [
            { position: { key: "timeframe", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [{ _description: "Test tokensByVolumeTimeframe", timeframe: "7d" }],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        }
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--topTraderRoutes.mjs
var topTraderRoutes_exports = {};
__export(topTraderRoutes_exports, {
  schema: () => schema100
});
var schema100;
var init_topTraderRoutes = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--topTraderRoutes.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema100 = {
      namespace: "solanatracker",
      name: "TopTradersAPI",
      description: "Provides access to the most profitable traders across all tokens, with support for pagination and token-specific queries.",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      handlers: {
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].error) {
            struct["status"] = false;
            struct["messages"].push(struct["data"].error);
            return { struct, payload };
          }
          return { struct, payload };
        }, "parseExecute")
      },
      routes: {
        topTradersAll: {
          requestMethod: "GET",
          description: "Get the most profitable traders across all tokens.",
          route: "/top-traders/all",
          parameters: [
            {
              position: {
                key: "expandPnl",
                value: "{{USER_PARAM}}",
                location: "query"
              },
              z: {
                primitive: "boolean()",
                options: ["optional()"]
              }
            },
            {
              position: {
                key: "sortBy",
                value: "{{USER_PARAM}}",
                location: "query"
              },
              z: {
                primitive: "enum(total,winPercentage)",
                options: ["optional()"]
              }
            }
          ],
          tests: [
            { _description: "Test topTradersAll" }
          ],
          modifiers: [
            { phase: "post", handlerName: "parseExecute" }
          ]
        },
        topTradersAllPaged: {
          requestMethod: "GET",
          description: "Get the most profitable traders across all tokens, paginated by page number.",
          route: "/top-traders/all/:page",
          parameters: [
            {
              position: {
                key: "page",
                value: "{{USER_PARAM}}",
                location: "insert"
              },
              z: {
                primitive: "number()",
                options: ["min(1)"]
              }
            }
          ],
          tests: [
            { _description: "Test topTradersAllPaged", page: 1 }
          ],
          modifiers: [
            { phase: "post", handlerName: "parseExecute" }
          ]
        },
        topTradersByToken: {
          requestMethod: "GET",
          description: "Get the top 100 most profitable traders for a specific token.",
          route: "/top-traders/:token",
          parameters: [
            {
              position: {
                key: "token",
                value: "{{USER_PARAM}}",
                location: "insert"
              },
              z: {
                primitive: "string()",
                options: ["min(2)", "max(20)"]
              }
            }
          ],
          tests: [
            { _description: "Test topTradersByToken", token: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }
          ],
          modifiers: [
            { phase: "post", handlerName: "parseExecute" }
          ]
        }
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--tradeEndpoints.mjs
var tradeEndpoints_exports = {};
__export(tradeEndpoints_exports, {
  schema: () => schema101
});
var schema101;
var init_tradeEndpoints = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--tradeEndpoints.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema101 = {
      namespace: "solanatracker",
      name: "TokenTradeTracker",
      description: "API zur Ermittlung von Handelsdaten f\xFCr Token, Pools und Wallets.",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      routes: {
        tokenTrades: {
          requestMethod: "GET",
          description: "Get the latest trades for a token across all pools.",
          route: "/trades/:tokenAddress",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test tokenTrades", tokenAddress: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump" }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        tradesByWallet: {
          requestMethod: "GET",
          description: "Get the latest trades for a specific token and wallet address.",
          route: "/trades/:tokenAddress/by-wallet/:owner",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "owner", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "showMeta", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } },
            { position: { key: "parseJupiter", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } },
            { position: { key: "hideArb", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } }
          ],
          tests: [
            {
              _description: "Test tradesByWallet",
              tokenAddress: "CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump",
              owner: "suqh5sHtr8HyJ7q8scBimULPkPpA557prMG47xCHQfK"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        tokenPoolTrades: {
          requestMethod: "GET",
          description: "Get the latest trades for a specific token and pool.",
          route: "/trades/:tokenAddress/:poolAddress",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "poolAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            {
              _description: "Test tokenPoolTrades",
              tokenAddress: "Token123",
              poolAddress: "Pool456"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        userPoolTrades: {
          requestMethod: "GET",
          description: "Get the latest trades for a specific token, pool, and user.",
          route: "/trades/:tokenAddress/:poolAddress/:owner",
          parameters: [
            { position: { key: "tokenAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "poolAddress", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "owner", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            {
              _description: "Test userPoolTrades",
              tokenAddress: "Token123",
              poolAddress: "Pool456",
              owner: "Wallet789"
            }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        }
      },
      handlers: {
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].error) {
            struct["status"] = false;
            struct["messages"].push(struct["data"].error);
            return { struct, payload };
          }
          return { struct, payload };
        }, "parseExecute")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--walletEndpoints.mjs
var walletEndpoints_exports = {};
__export(walletEndpoints_exports, {
  schema: () => schema102
});
var schema102;
var init_walletEndpoints = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solanatracker-io/--walletEndpoints.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema102 = {
      namespace: "solanatracker",
      name: "WalletExplorer",
      description: "API zur Abfrage von Token-Balances und Handelsdaten f\xFCr Wallets.",
      docs: ["https://docs.solanatracker.io"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://data.solanatracker.io",
      requiredServerParams: ["SOLANA_TRACKER_API_KEY"],
      headers: {
        "x-api-key": "{{SOLANA_TRACKER_API_KEY}}",
        "Content-Type": "application/json"
      },
      routes: {
        walletInformation: {
          requestMethod: "GET",
          description: "Get all tokens in a wallet with current value in USD.",
          route: "/wallet/:owner",
          parameters: [
            { position: { key: "owner", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test walletInformation", owner: "suqh5sHtr8HyJ7q8scBimULPkPpA557prMG47xCHQfK" }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        walletTokensBasic: {
          requestMethod: "GET",
          description: "Lightweight version: token balances and values without full metadata.",
          route: "/wallet/:owner/basic",
          parameters: [
            { position: { key: "owner", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Test walletTokensBasic", owner: "TestWalletAddress" }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        walletTokensPaged: {
          requestMethod: "GET",
          description: "Paginated version: fetch wallet tokens page by page (250 per page).",
          route: "/wallet/:owner/page/:page",
          parameters: [
            { position: { key: "owner", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "number()", options: [] } }
          ],
          tests: [
            { _description: "Test walletTokensPaged", owner: "TestWalletAddress", page: 1 }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        },
        walletTrades: {
          requestMethod: "GET",
          description: "Get the latest trades of a wallet.",
          route: "/wallet/:owner/trades",
          parameters: [
            { position: { key: "owner", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: [] } },
            { position: { key: "cursor", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Test walletTrades", owner: "suqh5sHtr8HyJ7q8scBimULPkPpA557prMG47xCHQfK" }
          ],
          modifiers: [{ phase: "post", handlerName: "parseExecute" }]
        }
      },
      handlers: {
        parseExecute: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct["data"].error) {
            struct["status"] = false;
            struct["messages"].push(struct["data"].error);
            return { struct, payload };
          }
          return { struct, payload };
        }, "parseExecute")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solscan-io/getChainInfo.mjs
var getChainInfo_exports = {};
__export(getChainInfo_exports, {
  schema: () => schema103
});
var schema103;
var init_getChainInfo = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solscan-io/getChainInfo.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema103 = {
      namespace: "solscan",
      name: "SolscanChainInfo",
      description: "Fetches general blockchain information from Solana via Solscan public API.",
      docs: ["https://docs.solscan.io/api-access/pro-api-endpoints"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://public-api.solscan.io",
      requiredServerParams: ["SOLSCAN_API_KEY"],
      headers: {
        token: "{{SOLSCAN_API_KEY}}"
      },
      routes: {
        chainInfo: {
          requestMethod: "GET",
          description: "Returns Solana blockchain information such as block height and transaction count.",
          route: "/chaininfo",
          parameters: [],
          tests: [
            {
              _description: "Basic test to fetch chain information"
            }
          ],
          modifiers: [
            {
              phase: "post",
              handlerName: "defaultHandler"
            }
          ]
        }
      },
      handlers: {
        defaultHandler: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (!struct["data"]["success"]) {
            struct["status"] = false;
            return { struct, payload };
          }
          struct["data"] = struct["data"]["data"];
          return { struct, payload };
        }, "defaultHandler")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/solsniffer-com/analysis.mjs
var analysis_exports = {};
__export(analysis_exports, {
  schema: () => schema104
});
var schema104;
var init_analysis = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/solsniffer-com/analysis.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema104 = {
      namespace: "solsniffer",
      name: "SolSniffer",
      description: "Analyzes Solana tokens using the Solsniffer API to assess risks and metadata.",
      docs: ["https://solsniffer.gitbook.io/solsniffer-user-guide"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://solsniffer.com/api/v2/token",
      requiredServerParams: ["SOLSNIFFER_API_KEY"],
      headers: {
        "X-API-KEY": "{{SOLSNIFFER_API_KEY}}",
        accept: "application/json"
      },
      routes: {
        analysisToken: {
          requestMethod: "GET",
          description: "Analyze a Solana token using its address and return risk and token metadata.",
          route: "/:token_address",
          parameters: [
            {
              position: { key: "token_address", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: ["min(32)"] }
            }
          ],
          tests: [
            {
              _description: "Analyze example token address",
              token_address: "So11111111111111111111111111111111111111112"
            }
          ],
          modifiers: [
            { phase: "post", handlerName: "extractTokenAnalysis" }
          ]
        }
      },
      handlers: {
        extractTokenAnalysis: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.analysis = payload?.content?.[0]?.json || {};
          return { struct, payload };
        }, "extractTokenAnalysis")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/spaceid/spaceid.mjs
var spaceid_exports = {};
__export(spaceid_exports, {
  schema: () => schema105
});
var SUPPORTED, schema105;
var init_spaceid = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/spaceid/spaceid.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SUPPORTED = [
      { chain: "Ethereum Mainnet", chainID: 1, domain: ".eth" },
      { chain: "BNB Chain", chainID: 56, domain: ".bnb" },
      { chain: "Solana", chainID: 900, domain: ".sol" },
      { chain: "Arbitrum One", chainID: 42161, domain: ".arb" },
      { chain: "Manta Pacific Mainnet", chainID: 169, domain: ".manta" },
      { chain: "Mode", chainID: 34443, domain: ".mode" },
      { chain: "ZKFair Mainnet", chainID: 42766, domain: ".zfk" },
      { chain: "Lightlink Phoenix Mainnet", chainID: 1890, domain: ".ll" },
      { chain: "ZetaChain Mainnet", chainID: 7e3, domain: ".zeta" },
      { chain: "Merlin Mainnet", chainID: 4200, domain: ".merlin" },
      { chain: "Gnosis", chainID: 100, domain: ".gno" },
      { chain: "Taiko Alethia", chainID: 167e3, domain: ".taiko" },
      { chain: "AlienX Mainnet", chainID: 10241024, domain: ".alien" },
      { chain: "Mint Mainnet", chainID: 185, domain: ".mint" },
      { chain: "AILayer Mainnet", chainID: 2649, domain: ".ail" },
      { chain: "Morph", chainID: 2818, domain: ".mph" },
      { chain: "DuckChain Mainnet", chainID: 5545, domain: ".duck" },
      { chain: "Gravity Alpha Mainnet", chainID: 1625, domain: ".g" },
      { chain: "Story", chainID: 1514, domain: ".ip" },
      { chain: "Injective", chainID: 901, domain: ".inj" },
      { chain: "Sei", chainID: 902, domain: ".sei" },
      { chain: "Lens on Polygon", chainID: 903, domain: ".lens" },
      { chain: "Crypto on Polygon", chainID: 904, domain: ".crypto" }
    ];
    schema105 = {
      namespace: "spaceid",
      name: "SPACE ID Web3 Name API",
      description: "Resolve crypto addresses and domain names via SPACE ID's on-chain resolution API.",
      docs: ["https://nameapi.space.id", "https://space.id", "https://docs.space.id"],
      tags: ["production", "domain", "identity", "blockchain"],
      flowMCP: "1.2.0",
      root: "https://nameapi.space.id",
      requiredServerParams: [],
      headers: {},
      routes: {
        getSupportedChains: {
          requestMethod: "GET",
          description: "List supported chains and their domain suffixes (static, compiled from docs).",
          route: "/",
          parameters: [],
          tests: [
            { _description: "Return supported chains list" }
          ],
          modifiers: [
            { phase: "execute", handlerName: "emitSupportedChains" }
          ]
        },
        getAddress: {
          requestMethod: "GET",
          description: "Resolve domain name to wallet address (e.g. steven.sei \u2192 sei1whl4xw...)",
          route: "/getAddress",
          parameters: [
            {
              position: { key: "domain", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: [] }
            }
          ],
          tests: [
            { _description: "Resolve steven.sei to address", domain: "steven.sei" }
          ],
          modifiers: []
        },
        getName: {
          requestMethod: "GET",
          description: "Resolve wallet address to primary domain name on specified chain",
          route: "/getName",
          parameters: [
            {
              position: { key: "chainid", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: [] }
            },
            {
              position: { key: "address", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "string()", options: [] }
            }
          ],
          tests: [
            {
              _description: "Resolve Sei address to steven.sei",
              chainid: "902",
              address: "sei1whl4xw33yzgadnm23uhk4q9y39lynlptwjctxp"
            }
          ],
          modifiers: []
        }
      },
      handlers: {
        emitSupportedChains: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.status = true;
          struct.data = SUPPORTED.slice();
          return { struct, payload };
        }, "emitSupportedChains")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/stolpersteine-berlin/memorial-stones.mjs
var memorial_stones_exports = {};
__export(memorial_stones_exports, {
  schema: () => schema106
});
var schema106;
var init_memorial_stones = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/stolpersteine-berlin/memorial-stones.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema106 = {
      namespace: "stolpersteineBerl",
      name: "Stolpersteine Berlin API",
      description: "Access information about Stolpersteine (memorial stones) in Berlin commemorating victims of Nazi persecution",
      docs: ["https://www.stolpersteine-berlin.de/", "https://www.stolpersteine-berlin.de/de/api"],
      tags: ["memorial", "history", "berlin"],
      flowMCP: "1.2.0",
      root: "https://www.stolpersteine-berlin.de",
      requiredServerParams: [],
      headers: {},
      routes: {
        getAllStones: {
          requestMethod: "GET",
          description: "Get all Stolpersteine in Berlin",
          route: "/de/api/json/stolpersteine.json",
          parameters: [
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1)", "max(1000)", "default(100)", "optional()"] } },
            { position: { key: "offset", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0)", "default(0)", "optional()"] } }
          ],
          tests: [
            { _description: "First 50 Stolpersteine", limit: 50 }
          ],
          modifiers: [{ phase: "execute", handlerName: "parseStolpersteineJSON" }]
        },
        searchStones: {
          requestMethod: "GET",
          description: "Search Stolpersteine by person name, address, or other criteria",
          route: "/de/api/json/stolpersteine.json",
          parameters: [
            { position: { key: "q", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "name", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(2)", "optional()"] } },
            { position: { key: "address", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(3)", "optional()"] } },
            { position: { key: "birth_year", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1800)", "max(1945)", "optional()"] } },
            { position: { key: "death_year", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(1933)", "max(1945)", "optional()"] } },
            { position: { key: "persecution_reason", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Jude,politisch,Zeuge-Jehovas,Sinti-Roma,Homosexuell,Euthanasie,Widerstand)", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Search by name", name: "Cohen" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "formatSearchParameters" },
            { phase: "execute", handlerName: "parseStolpersteineJSON" }
          ]
        },
        getStonesByDistrict: {
          requestMethod: "GET",
          description: "Get Stolpersteine in specific Berlin districts",
          route: "/de/api/json/stolpersteine.json",
          parameters: [
            { position: { key: "bezirk", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(Mitte,Friedrichshain-Kreuzberg,Pankow,Charlottenburg-Wilmersdorf,Spandau,Steglitz-Zehlendorf,Tempelhof-Schoeneberg,Neukoelln,Treptow-Koepenick,Marzahn-Hellersdorf,Lichtenberg,Reinickendorf)", options: [] } },
            { position: { key: "ortsteil", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sort_by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(name,address,installation_date,birth_year)", options: ["default(name)", "optional()"] } }
          ],
          tests: [
            { _description: "All stones in Mitte", bezirk: "Mitte" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "formatDistrictFilter" },
            { phase: "execute", handlerName: "parseStolpersteineJSON" }
          ]
        },
        getStonesByPerson: {
          requestMethod: "GET",
          description: "Get detailed information about specific victims commemorated by Stolpersteine",
          route: "/de/api/json/stolpersteine.json",
          parameters: [
            { position: { key: "person_id", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(1)", "optional()"] } },
            { position: { key: "age_at_death", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(child,youth,adult,elderly)", options: ["optional()"] } },
            { position: { key: "family_group", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["optional()"] } },
            { position: { key: "include_biography", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "boolean()", options: ["default(true)", "optional()"] } }
          ],
          tests: [
            { _description: "Person by ID", person_id: "12345" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "formatPersonFilter" },
            { phase: "execute", handlerName: "parseStolpersteineJSON" }
          ]
        },
        getStonesByLocation: {
          requestMethod: "GET",
          description: "Get Stolpersteine near a specific location or coordinates",
          route: "/de/api/json/stolpersteine.json",
          parameters: [
            { position: { key: "lat", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(52.3)", "max(52.7)", "optional()"] } },
            { position: { key: "lon", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(13.0)", "max(13.8)", "optional()"] } },
            { position: { key: "radius", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["min(0.1)", "max(5.0)", "default(1.0)", "optional()"] } },
            { position: { key: "street", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["min(3)", "optional()"] } }
          ],
          tests: [
            { _description: "Stones near Alexanderplatz", lat: 52.52, lon: 13.405, radius: 0.5 }
          ],
          modifiers: [
            { phase: "pre", handlerName: "formatLocationFilter" },
            { phase: "execute", handlerName: "parseStolpersteineJSON" }
          ]
        }
      },
      handlers: {
        // Simple in-memory cache for Stolpersteine data
        _cache: {
          data: null,
          timestamp: null,
          ttl: 36e5
          // 1 hour in milliseconds
        },
        parseStolpersteineJSON: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          try {
            const now = Date.now();
            const cache = schema106.handlers._cache;
            if (cache.data && cache.timestamp && now - cache.timestamp < cache.ttl) {
              const data2 = cache.data;
              struct.data = {
                source: "Stolpersteine Berlin (cached)",
                stoneCount: data2.length,
                stolpersteine: data2,
                fromCache: true,
                cachedAt: new Date(cache.timestamp).toISOString()
              };
              struct.status = true;
              return { struct, payload };
            }
            const response = await fetch(payload.url);
            if (!response.ok) {
              struct.status = false;
              struct.messages.push(`HTTP ${response.status}: ${response.statusText}`);
              return { struct, payload };
            }
            const data = await response.json();
            cache.data = data;
            cache.timestamp = now;
            if (Array.isArray(data)) {
              const stolpersteine = data.map((stone) => ({
                id: stone.id || stone.nummer,
                person: {
                  firstName: stone.first_name || stone.vorname,
                  lastName: stone.last_name || stone.nachname,
                  fullName: stone.full_name || stone.vollername,
                  birthDate: stone.birth_date || stone.geburtsdatum,
                  birthPlace: stone.birth_place || stone.geburtsort,
                  deathDate: stone.death_date || stone.todesdatum,
                  deathPlace: stone.death_place || stone.todesort,
                  ageAtDeath: stone.age_at_death || stone.alter_beim_tod
                },
                persecution: {
                  reason: stone.persecution_reason || stone.verfolgungsgrund,
                  deportationDate: stone.deportation_date || stone.deportation,
                  deportationDestination: stone.deportation_destination || stone.deportationsziel,
                  captureDate: stone.capture_date || stone.verhaftung,
                  escapeAttempt: stone.escape_attempt || stone.fluchtversuch
                },
                location: {
                  address: stone.address || stone.adresse,
                  district: stone.district || stone.bezirk,
                  neighborhood: stone.neighborhood || stone.ortsteil,
                  coordinates: {
                    lat: stone.lat || stone.latitude,
                    lon: stone.lon || stone.longitude
                  },
                  lastKnownAddress: stone.last_known_address || stone.letzte_adresse
                },
                memorial: {
                  installationDate: stone.installation_date || stone.verlegung,
                  artist: stone.artist || stone.kuenstler || "Gunter Demnig",
                  condition: stone.condition || stone.zustand,
                  verified: stone.verified || stone.verifiziert,
                  sponsor: stone.sponsor || stone.pate
                },
                biography: {
                  profession: stone.profession || stone.beruf,
                  family: stone.family || stone.familie || [],
                  education: stone.education || stone.bildung,
                  resistance: stone.resistance || stone.widerstand,
                  additionalInfo: stone.additional_info || stone.zusatzinfo
                },
                sources: stone.sources || stone.quellen || [],
                lastUpdated: stone.last_updated || stone.aktualisiert
              }));
              struct.data = {
                source: "Stolpersteine Berlin",
                stoneCount: stolpersteine.length,
                stolpersteine
              };
            } else {
              struct.data = data;
            }
          } catch (error42) {
            struct.status = false;
            struct.messages.push(`Error parsing Stolpersteine JSON: ${error42.message}`);
          }
          return { struct, payload };
        }, "parseStolpersteineJSON"),
        formatSearchParameters: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { q, name: name17, address, birth_year, death_year, persecution_reason } = userParams;
          const searchParams = new URLSearchParams();
          if (q) searchParams.append("search", q);
          if (name17) searchParams.append("name", name17);
          if (address) searchParams.append("address", address);
          if (birth_year) searchParams.append("birth_year", birth_year.toString());
          if (death_year) searchParams.append("death_year", death_year.toString());
          if (persecution_reason) searchParams.append("persecution", persecution_reason);
          if (searchParams.toString()) {
            payload.url += payload.url.includes("?") ? `&${searchParams.toString()}` : `?${searchParams.toString()}`;
          }
          return { struct, payload };
        }, "formatSearchParameters"),
        formatDistrictFilter: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { bezirk, ortsteil, sort_by } = userParams;
          const filterParams = new URLSearchParams();
          if (bezirk) filterParams.append("district", bezirk);
          if (ortsteil) filterParams.append("neighborhood", ortsteil);
          if (sort_by) filterParams.append("sort", sort_by);
          if (filterParams.toString()) {
            payload.url += payload.url.includes("?") ? `&${filterParams.toString()}` : `?${filterParams.toString()}`;
          }
          return { struct, payload };
        }, "formatDistrictFilter"),
        formatPersonFilter: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { person_id, age_at_death, family_group, include_biography } = userParams;
          const personParams = new URLSearchParams();
          if (person_id) personParams.append("person_id", person_id);
          if (age_at_death) personParams.append("age_category", age_at_death);
          if (family_group !== void 0) personParams.append("family_group", family_group.toString());
          if (include_biography !== void 0) personParams.append("biography", include_biography.toString());
          if (personParams.toString()) {
            payload.url += payload.url.includes("?") ? `&${personParams.toString()}` : `?${personParams.toString()}`;
          }
          return { struct, payload };
        }, "formatPersonFilter"),
        formatLocationFilter: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { lat, lon, radius = 1, street } = userParams;
          const locationParams = new URLSearchParams();
          if (lat && lon) {
            locationParams.append("lat", lat.toString());
            locationParams.append("lon", lon.toString());
            locationParams.append("radius", radius.toString());
          }
          if (street) locationParams.append("street", street);
          if (locationParams.toString()) {
            payload.url += payload.url.includes("?") ? `&${locationParams.toString()}` : `?${locationParams.toString()}`;
          }
          return { struct, payload };
        }, "formatLocationFilter")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/swaggerhub-com/api-registry.mjs
var api_registry_exports = {};
__export(api_registry_exports, {
  schema: () => schema107
});
var schema107;
var init_api_registry = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/swaggerhub-com/api-registry.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema107 = {
      namespace: "swaggerhub",
      name: "SwaggerHub API",
      description: "FlowMCP interface for SwaggerHub registry API, supporting search, metadata listing, and Swagger definition retrieval.",
      docs: ["https://swaggerhub.com/api/swagger-hub/registry-api/1.0.0"],
      tags: ["production", "api", "documentation", "registry"],
      flowMCP: "1.2.0",
      root: "https://api.swaggerhub.com/apis",
      requiredServerParams: [],
      headers: {},
      routes: {
        searchApis: {
          requestMethod: "GET",
          description: "Searches SwaggerHub public APIs using query parameters like `query`, `state`, `tag`, etc.",
          route: "/",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "state", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(PUBLISHED,UNPUBLISHED)", options: ["optional()"] } },
            { position: { key: "page", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Search for finance-related APIs", query: "finance", state: "PUBLISHED" }
          ],
          modifiers: []
        },
        listApiVersions: {
          requestMethod: "GET",
          description: "Returns metadata for all versions of a specified API.",
          route: "/:owner/:api",
          parameters: [
            { position: { key: "owner", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } },
            { position: { key: "api", value: "{{USER_PARAM}}", location: "insert" }, z: { primitive: "string()", options: ["min(1)"] } }
          ],
          tests: [
            { _description: "List versions of registry-api", owner: "swagger-hub", api: "registry-api" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/thegraph/getNewUniswapPools.mjs
var getNewUniswapPools_exports = {};
__export(getNewUniswapPools_exports, {
  schema: () => schema108
});
var schema108;
var init_getNewUniswapPools = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/thegraph/getNewUniswapPools.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema108 = {
      namespace: "thegraph",
      name: "UniswapPools",
      description: "Fetches recently created Uniswap V3 trading pools across multiple blockchains.",
      docs: ["https://thegraph.com/docs/en/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://gateway.thegraph.com",
      requiredServerParams: ["THEGRAPH_API_KEY"],
      headers: {
        Authorization: "Bearer {{THEGRAPH_API_KEY}}"
      },
      routes: {
        getNewPools: {
          requestMethod: "POST",
          description: "List new Uniswap V3 pools by chain and order criteria within a time range.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/--subgraph-id--",
          parameters: [
            {
              position: { key: "chain", value: "{{USER_PARAM}}", location: "query" },
              z: {
                primitive: "enum(ethereum,base,optimism,arbitrum,polygon,bsc,avalanche,celo,blast)",
                options: ["default(ethereum)"]
              }
            },
            {
              position: { key: "orderBy", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "enum(timestamp,txcount,volume,tvl)", options: ["default(timestamp)"] }
            },
            {
              position: { key: "time_range_seconds", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(60)", "max(86400)", "default(300)"] }
            },
            {
              position: { key: "limit", value: "{{USER_PARAM}}", location: "query" },
              z: { primitive: "number()", options: ["min(1)", "max(100)", "default(100)"] }
            }
          ],
          tests: [
            {
              _description: "Fetch most recent pools on Optimism ordered by volume",
              chain: "optimism",
              orderBy: "volume",
              time_range_seconds: 70777,
              limit: 567
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "setEnums" },
            { phase: "post", handlerName: "formatResult" }
          ]
        }
      },
      handlers: {
        setEnums: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const SUBGRAPH_URLS = {
            ethereum: `5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV`,
            base: `GqzP4Xaehti8KSfQmv3ZctFSjnSUYZ4En5NRsiTbvZpz`,
            optimism: `Cghf4LfVqPiFw6fp6Y5X5Ubc8UpmUhSfJL82zwiBFLaj`,
            arbitrum: `FbCGRftH4a3yZugY7TnbYgPJVEv2LvMT6oF1fxPe9aJM`,
            polygon: `3hCPRGf4z88VC5rsBKU5AA9FBBq5nF3jbKJG7VZCbhjm`,
            bsc: `A1fvJWQLBeUAggX2WQTMm3FKjXTekNXo77ZySun4YN2m`,
            avalanche: `GVH9h9KZ9CqheUEL93qMbq7QwgoBu32QXQDPR6bev4Eo`,
            celo: `ESdrTJ3twMwWVoQ1hUE2u7PugEHX3QkenudD6aXCkDQ4`,
            blast: `2LHovKznvo8YmKC9ZprPjsYAZDCc4K5q4AYz8s3cnQn1`
          };
          const { chain, orderBy, time_range_seconds, limit } = userParams;
          payload["url"] = payload["url"].replace(
            "--subgraph-id--",
            SUBGRAPH_URLS[chain]
          );
          const ORDER_BY_OPTIONS = {
            "timestamp": "createdAtTimestamp",
            "txcount": "txCount",
            "volume": "volumeUSD",
            "tvl": "totalValueLockedUSD"
          };
          const timestamp = Math.floor(Date.now() / 1e3) - time_range_seconds;
          const orderField = ORDER_BY_OPTIONS[orderBy];
          const query = `
          query RecentPools($timestamp: BigInt!, $limit: Int!) {
            pools(
              where: { createdAtTimestamp_gt: $timestamp }
              orderBy: ${orderField}
              orderDirection: desc
              first: $limit
            ) {
              id
              token0 { symbol }
              token1 { symbol }
              createdAtTimestamp
              createdAtBlockNumber
              txCount
              volumeUSD
              totalValueLockedUSD
            }
          }
        `;
          const variables = {
            "timestamp": String(timestamp),
            limit
          };
          payload["body"] = { query, variables };
          return { struct, payload };
        }, "setEnums"),
        formatResult: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { time_range_seconds, limit } = userParams;
          const mins = Math.floor(time_range_seconds / 60);
          const { data } = struct;
          const pools = data.data?.pools || [];
          if (Array.isArray(data.errors)) {
            struct["status"] = false;
            struct["messages"].push(...data.errors.map((error42) => error42.message));
            return { struct, payload };
          }
          if (!pools.length) {
            struct["status"] = false;
            struct["messages"].push(`No pools created in the last ${mins} minutes.`);
            return { struct, payload };
          }
          let output = `Newly Created Trading Pools (Last ${mins} Minutes, Limit: ${limit}):

`;
          for (const pool of pools) {
            const createdAt = new Date(pool.createdAtTimestamp * 1e3).toISOString().replace("T", " ").split(".")[0];
            const volume = parseFloat(pool.volumeUSD).toFixed(2);
            const tvl = parseFloat(pool.totalValueLockedUSD).toFixed(2);
            output += `Pool Address: ${pool.id}
            Tokens: ${pool.token0.symbol}/${pool.token1.symbol}
            Created At: ${createdAt}
            Block: ${pool.createdAtBlockNumber}
            Tx Count: ${pool.txCount}
            Volume (USD): $${volume}
            TVL (USD): $${tvl}

`;
          }
          struct["data"] = output;
          return { struct, payload };
        }, "formatResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/thegraph/getSchema.mjs
var getSchema_exports = {};
__export(getSchema_exports, {
  schema: () => schema109
});
var schema109;
var init_getSchema = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/thegraph/getSchema.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema109 = {
      namespace: "thegraph",
      name: "TheGraphSubgraphTools",
      description: "Introspect and query The Graph subgraphs.",
      docs: ["https://thegraph.com/docs/en/"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://gateway.thegraph.com",
      requiredServerParams: ["THEGRAPH_API_KEY"],
      headers: {
        Authorization: "Bearer {{THEGRAPH_API_KEY}}"
      },
      routes: {
        getSubgraphSchema: {
          requestMethod: "POST",
          description: "Fetch the schema of a subgraph via introspection query.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/{{subgraphId}}",
          parameters: [
            {
              position: { key: "subgraphId", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: [] }
            }
          ],
          modifiers: [
            { phase: "pre", handlerName: "setIntrospectionQuery" },
            { phase: "post", handlerName: "formatSchemaResult" }
          ],
          tests: [
            {
              _description: "Introspect Uniswap V3 subgraph",
              subgraphId: "5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV"
            }
          ]
        },
        querySubgraph: {
          requestMethod: "POST",
          description: "Run a raw GraphQL query on a subgraph.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/{{subgraphId}}",
          parameters: [
            {
              position: { key: "subgraphId", value: "{{USER_PARAM}}", location: "insert" },
              z: { primitive: "string()", options: [] }
            },
            {
              position: { key: "query", value: "{{USER_PARAM}}", location: "body" },
              z: { primitive: "string()", options: [] }
            }
          ],
          modifiers: [
            { phase: "post", handlerName: "formatQueryResult" }
          ],
          tests: [
            {
              _description: "Sample query for entity data",
              subgraphId: "5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV",
              query: "query { pools(first: 2) { id } }"
            }
          ]
        }
      },
      handlers: {
        setIntrospectionQuery: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const query = `
        query IntrospectionQuery {
          __schema {
            types {
              name
              kind
              fields {
                name
              }
            }
          }
        }
      `;
          payload["body"] = { query };
          return { struct, payload };
        }, "setIntrospectionQuery"),
        formatSchemaResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const data = struct?.data?.data || {};
          if (!data.__schema) {
            struct.status = false;
            struct.messages = ["No schema returned."];
          } else {
            struct.status = true;
            struct.data = data.__schema;
          }
          return { struct, payload };
        }, "formatSchemaResult"),
        formatQueryResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          const data = payload?.data?.data || {};
          if (!data) {
            struct.status = false;
            struct.messages = ["Query returned no data."];
          } else {
            struct.status = true;
            struct.data = JSON.stringify(data, null, 2);
          }
          return { struct, payload };
        }, "formatQueryResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/twitter/search.mjs
var search_exports2 = {};
__export(search_exports2, {
  schema: () => schema110
});
var schema110;
var init_search2 = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/twitter/search.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema110 = {
      namespace: "twitter",
      name: "Twitter Recent Search",
      description: "Search for Tweets from the last 7 days using Twitter's recent search endpoint",
      docs: ["https://developer.twitter.com/en/docs/twitter-api/tweets/search/quick-start/recent-search"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.twitter.com/2",
      requiredServerParams: ["TWITTER_BEARER_TOKEN"],
      headers: { authorization: "Bearer {{TWITTER_BEARER_TOKEN}}" },
      routes: {
        searchRecentTweets: {
          requestMethod: "GET",
          description: "Search for recent tweets matching a given query",
          route: "/tweets/search/recent",
          parameters: [
            { position: { key: "query", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: [] } }
            // { position: { key: "tweet.fields", value: "author_id", location: "query" }, z: { primitive: "string()", options: [] } }
          ],
          tests: [
            { _description: "Get tweets from twitterdev", query: "bitcoin" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "modifyPayload" },
            { phase: "post", handlerName: "modifyResult" }
          ]
        }
      },
      handlers: {
        modifyPayload: /* @__PURE__ */ __name(({ struct, payload }) => {
          return { struct, payload };
        }, "modifyPayload"),
        modifyResult: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          if (struct.data && struct.data.data) {
            struct.data = struct.data.data;
          } else {
            struct.status = false;
            struct.messages.push("No tweets found or invalid response structure.");
          }
          return { struct, payload };
        }, "modifyResult")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/uniswap-pools/uniswap-pool-explorer.mjs
var uniswap_pool_explorer_exports = {};
__export(uniswap_pool_explorer_exports, {
  schema: () => schema111
});
var schema111;
var init_uniswap_pool_explorer = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/uniswap-pools/uniswap-pool-explorer.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema111 = {
      namespace: "uniswap",
      name: "Uniswap Pool Explorer",
      description: "Query Uniswap V2, V3, and V4 pools for a given token address or pool ID using The Graph subgraphs.",
      docs: ["https://thegraph.com/explorer/subgraphs?id=A3Np3RQbaBA6oKJgiwDJeo5T3zrYfGHPWFYayMwtNDum", "https://thegraph.com/explorer"],
      tags: ["production"],
      flowMCP: "1.2.0",
      root: "https://gateway.thegraph.com",
      requiredServerParams: ["THEGRAPH_API_KEY"],
      headers: { Authorization: "Bearer {{THEGRAPH_API_KEY}}" },
      routes: {
        getTokenPools: {
          requestMethod: "POST",
          description: "Returns Uniswap V3 pools for a given token address using TheGraph subgraph.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/--subgraph-id--",
          parameters: [
            { position: { key: "token_address", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["length(42)"] } },
            { position: { key: "chain", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "enum(ethereum,arbitrum,optimism,polygon,base,bsc,celo)", options: ["default(ethereum)"] } }
          ],
          tests: [
            { _description: "Query USDC pools on Ethereum", token_address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", chain: "ethereum" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildTokenPoolsQuery" }
          ]
        },
        getPoolData: {
          requestMethod: "POST",
          description: "Fetch details for a specific Uniswap pool by ID using TheGraph subgraph.",
          route: "/api/{{THEGRAPH_API_KEY}}/subgraphs/id/--subgraph-id--",
          parameters: [
            { position: { key: "pool_id", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "string()", options: ["length(42)"] } },
            { position: { key: "chain", value: "{{USER_PARAM}}", location: "body" }, z: { primitive: "enum(ethereum,arbitrum,optimism,polygon,base,bsc,celo)", options: ["default(ethereum)"] } }
          ],
          tests: [
            { _description: "Get data for USDC/ETH pool", pool_id: "0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8", chain: "ethereum" }
          ],
          modifiers: [
            { phase: "pre", handlerName: "buildPoolDataQuery" }
          ]
        }
      },
      handlers: {
        buildTokenPoolsQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { token_address, chain } = userParams;
          const SUBGRAPH_IDS = {
            ethereum: "5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV",
            arbitrum: "FbCGRftH4a3yZugY7TnbYgPJVEv2LvMT6oF1fxPe9aJM",
            optimism: "Cghf4LfVqPiFw6fp6Y5X5Ubc8UpmUhSfJL82zwiBFLaj",
            polygon: "3hCPRGf4z88VC5rsBKU5AA9FBBq5nF3jbKJG7VZCbhjm",
            base: "GqzP4Xaehti8KSfQmv3ZctFSjnSUYZ4En5NRsiTbvZpz",
            bsc: "A1fvJWQLBeUAggX2WQTMm3FKjXTekNXo77ZySun4YN2m",
            celo: "ESdrTJ3twMwWVoQ1hUE2u7PugEHX3QkenudD6aXCkDQ4"
          };
          payload.url = payload.url.replace("--subgraph-id--", SUBGRAPH_IDS[chain]);
          const query = `
                query GetTokenPools($tokenAddress: String!) {
                    pools(
                        where: {
                            or: [
                                { token0: $tokenAddress },
                                { token1: $tokenAddress }
                            ]
                        }
                        orderBy: volumeUSD
                        orderDirection: desc
                        first: 50
                    ) {
                        id
                        token0 { symbol id }
                        token1 { symbol id }
                        feeTier
                        volumeUSD
                        totalValueLockedUSD
                        txCount
                        createdAtTimestamp
                    }
                }
            `;
          payload.body = {
            query,
            variables: { tokenAddress: token_address.toLowerCase() }
          };
          return { struct, payload };
        }, "buildTokenPoolsQuery"),
        buildPoolDataQuery: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const { pool_id, chain } = userParams;
          const SUBGRAPH_IDS = {
            ethereum: "5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV",
            arbitrum: "FbCGRftH4a3yZugY7TnbYgPJVEv2LvMT6oF1fxPe9aJM",
            optimism: "Cghf4LfVqPiFw6fp6Y5X5Ubc8UpmUhSfJL82zwiBFLaj",
            polygon: "3hCPRGf4z88VC5rsBKU5AA9FBBq5nF3jbKJG7VZCbhjm",
            base: "GqzP4Xaehti8KSfQmv3ZctFSjnSUYZ4En5NRsiTbvZpz",
            bsc: "A1fvJWQLBeUAggX2WQTMm3FKjXTekNXo77ZySun4YN2m",
            celo: "ESdrTJ3twMwWVoQ1hUE2u7PugEHX3QkenudD6aXCkDQ4"
          };
          payload.url = payload.url.replace("--subgraph-id--", SUBGRAPH_IDS[chain]);
          const query = `
                query GetPoolData($poolId: String!) {
                    pool(id: $poolId) {
                        id
                        token0 { 
                            symbol 
                            id 
                            name 
                            decimals 
                        }
                        token1 { 
                            symbol 
                            id 
                            name 
                            decimals 
                        }
                        feeTier
                        volumeUSD
                        totalValueLockedUSD
                        txCount
                        createdAtTimestamp
                        createdAtBlockNumber
                        tick
                        sqrtPrice
                        liquidity
                    }
                }
            `;
          payload.body = {
            query,
            variables: { poolId: pool_id.toLowerCase() }
          };
          return { struct, payload };
        }, "buildPoolDataQuery")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/web3-career/job-listings.mjs
var job_listings_exports = {};
__export(job_listings_exports, {
  schema: () => schema112
});
var schema112;
var init_job_listings = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/web3-career/job-listings.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema112 = {
      namespace: "webcareer",
      name: "Web3 Career Job API",
      description: "Query job listings from the web3.career API with optional filters and markdown output.",
      docs: ["https://web3.career/developer-api"],
      tags: ["production", "jobs", "career", "crypto"],
      flowMCP: "1.2.0",
      root: "https://web3.career/api/v1",
      requiredServerParams: ["WEB3_CAREER_API_TOKEN"],
      headers: {},
      routes: {
        queryJobs: {
          requestMethod: "GET",
          description: "Returns Markdown-formatted job listings filtered by remote, country, tag, and limit.",
          route: "/",
          parameters: [
            { position: { key: "token", value: "{{WEB3_CAREER_API_TOKEN}}", location: "query" }, z: { primitive: "string()", options: [] } },
            { position: { key: "remote", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(true,false)", options: ["optional()"] } },
            { position: { key: "country", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "tag", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "limit", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "number()", options: ["optional()", "min(1)", "max(100)", "default(50)"] } }
          ],
          tests: [
            { _description: "Fetch 5 remote jobs tagged with blockchain in Canada", remote: "true", tag: "blockchain", country: "canada", limit: 5 },
            { _description: "Fetch default jobs with no filters" }
          ],
          modifiers: [
            { phase: "execute", handlerName: "queryJobsMarkdown" }
          ]
        }
      },
      handlers: {
        queryJobsMarkdown: /* @__PURE__ */ __name(async ({ struct, payload, userParams }) => {
          const res = await fetch(payload.url);
          if (!res.ok) {
            struct.status = false;
            struct.messages.push(`HTTP ${res.status}: ${res.statusText}`);
            return { struct, payload };
          }
          const data = await res.json();
          const jobs = data.length > 2 ? data[2] : [];
          const strip = /* @__PURE__ */ __name((txt) => txt.replace(/<[^>]+>/g, "").replace(/\s+/g, " ").trim(), "strip");
          const md = jobs.map((job) => {
            const desc = strip(job.description || "").slice(0, 100);
            return `- **Job ID**: ${job.id}
  - **Title**: ${job.title}
  - **Company**: ${job.company}
  - **Location**: ${job.location}
  - **Remote**: ${job.is_remote ? "Yes" : "No"}
  - **Published At**: ${new Date(job.date_epoch * 1e3).toISOString().slice(0, 10)}
  - **Apply URL**: [Apply](${job.apply_url})
  - **Description**: ${desc}...`;
          }).join("\n\n");
          struct.data = { markdown: "# Web3 Job Listings\n\n" + md + "\n\n*Source: web3.career*" };
          return { struct, payload };
        }, "queryJobsMarkdown")
      }
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/wormholescan/wormholescan.mjs
var wormholescan_exports = {};
__export(wormholescan_exports, {
  schema: () => schema113
});
var schema113;
var init_wormholescan = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/wormholescan/wormholescan.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema113 = {
      namespace: "wormholescan",
      name: "Wormhole Metrics API",
      description: "Query cross-chain transaction metrics from the Wormholescan public API",
      docs: ["https://wormholescan.io", "https://docs.wormholescan.io"],
      tags: ["data", "api"],
      flowMCP: "1.2.0",
      root: "https://api.wormholescan.io",
      requiredServerParams: [],
      headers: {},
      routes: {
        getCrossChainActivity: {
          requestMethod: "GET",
          description: "Returns cross-chain volume between source and destination chains.",
          route: "/api/v1/x-chain-activity",
          parameters: [
            { position: { key: "timeSpan", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(7d,30d,90d,1y,all-time)", options: ["default(7d)"] } },
            { position: { key: "by", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(notional,motional)", options: ["default(notional)"] } },
            { position: { key: "apps", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Default query with 7d and notional", timeSpan: "7d", by: "notional" },
            { _description: "Query with motional", timeSpan: "7d", by: "motional" }
          ],
          modifiers: []
        },
        getMoneyFlow: {
          requestMethod: "GET",
          description: "Returns top money flow data by chain and volume.",
          route: "/api/v1/x-chain-activity/tops",
          parameters: [
            { position: { key: "timespan", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(1h,1d,1mo,1y)", options: ["default(1d)"] } },
            { position: { key: "from", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "to", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "appId", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "sourceChain", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } },
            { position: { key: "targetChain", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "string()", options: ["optional()"] } }
          ],
          tests: [
            { _description: "Money flow with default timespan", timespan: "1d" },
            { _description: "Money flow filtered by source and target", timespan: "1mo", sourceChain: "2", targetChain: "5" }
          ],
          modifiers: []
        },
        getTopAssetsByVolume: {
          requestMethod: "GET",
          description: "Returns top assets by transfer volume.",
          route: "/api/v1/top-assets-by-volume",
          parameters: [
            { position: { key: "timeSpan", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(7d,15d,30d)", options: ["default(7d)"] } }
          ],
          tests: [
            { _description: "Top assets by volume for 7d", timeSpan: "7d" },
            { _description: "Top assets by volume for 30d", timeSpan: "30d" }
          ],
          modifiers: []
        },
        getTopChainPairsByNumTransfers: {
          requestMethod: "GET",
          description: "Returns top chain pairs by number of transfers.",
          route: "/api/v1/top-chain-pairs-by-num-transfers",
          parameters: [
            { position: { key: "timeSpan", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(7d,15d,30d)", options: ["default(7d)"] } }
          ],
          tests: [
            { _description: "Top chain pairs for 7d", timeSpan: "7d" },
            { _description: "Top chain pairs for 15d", timeSpan: "15d" }
          ],
          modifiers: []
        },
        getTopSymbolsByVolume: {
          requestMethod: "GET",
          description: "Returns top transferred token symbols by volume.",
          route: "/api/v1/top-symbols-by-volume",
          parameters: [
            { position: { key: "timeSpan", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(7d,15d,30d)", options: ["default(7d)"] } }
          ],
          tests: [
            { _description: "Top symbols for 7d", timeSpan: "7d" },
            { _description: "Top symbols for 30d", timeSpan: "30d" }
          ],
          modifiers: []
        },
        getTopCorridors: {
          requestMethod: "GET",
          description: "Returns top 100 token corridors by number of transfers.",
          route: "/api/v1/top-100-corridors",
          parameters: [
            { position: { key: "timeSpan", value: "{{USER_PARAM}}", location: "query" }, z: { primitive: "enum(2d,7d)", options: ["default(2d)"] } }
          ],
          tests: [
            { _description: "Top corridors for 2d", timeSpan: "2d" },
            { _description: "Top corridors for 7d", timeSpan: "7d" }
          ],
          modifiers: []
        },
        getKpiList: {
          requestMethod: "GET",
          description: "Returns Wormhole KPIs including volume, message count, and TVL.",
          route: "/api/v1/scorecards",
          parameters: [],
          tests: [
            { _description: "Get general KPI stats" }
          ],
          modifiers: []
        }
      },
      handlers: {}
    };
  }
});

// node_modules/schemaimporter/schemas/v1.2.0/x402/ping.mjs
var ping_exports = {};
__export(ping_exports, {
  schema: () => schema114
});
var schema114;
var init_ping = __esm({
  "node_modules/schemaimporter/schemas/v1.2.0/x402/ping.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    schema114 = {
      namespace: "x402",
      name: "x402 Experimental MCP Interface",
      description: "A test schema for verifying free and paid route behavior under FlowMCP v1.2.0",
      docs: ["https://example.com/x402/docs"],
      tags: [],
      flowMCP: "1.2.0",
      root: "https://api.x402.test/v1",
      requiredServerParams: [],
      headers: {},
      routes: {
        free_ping: {
          requestMethod: "GET",
          description: "Simple free route to verify server responsiveness",
          route: "/ping",
          parameters: [],
          tests: [{ _description: "Basic ping test" }],
          modifiers: [{ phase: "execute", handlerName: "free_ping" }]
        },
        paid_ping: {
          requestMethod: "GET",
          description: "Simulated paid route to test vault access",
          route: "/vault/item",
          parameters: [],
          tests: [{ _description: "Basic paid ping test" }],
          modifiers: [{ phase: "execute", handlerName: "paid_ping" }]
        }
      },
      handlers: {
        free_ping: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.data = {
            method: "free_ping",
            status: "alive",
            version: "x402-experiment",
            time: (/* @__PURE__ */ new Date()).toISOString()
          };
          struct.status = true;
          return { struct, payload };
        }, "free_ping"),
        paid_ping: /* @__PURE__ */ __name(async ({ struct, payload }) => {
          struct.data = {
            method: "paid_ping",
            itemId: "XYZ00001",
            content: "Encrypted payload or structured data here",
            access_level: "licensed",
            metadata: {
              retrieved_at: (/* @__PURE__ */ new Date()).toISOString(),
              source: "x402-vault-test"
            }
          };
          struct.status = true;
          return { struct, payload };
        }, "paid_ping")
      }
    };
  }
});

// node_modules/schemaimporter/src/data/static-import.mjs
var static_import_exports = {};
__export(static_import_exports, {
  allSchemas: () => allSchemas
});
var allSchemas;
var init_static_import = __esm({
  "node_modules/schemaimporter/src/data/static-import.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    allSchemas = [
      {
        "id": "aave_aave",
        "relativePath": "schemas/v1.2.0/aave/aave.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/aave/aave.mjs",
        "internalImport": "./../../schemas/v1.2.0/aave/aave.mjs",
        "folderName": "aave",
        "hasImport": false,
        "namespace": "aave",
        "tags": [
          "defi",
          "lending",
          "protocol"
        ],
        "requiredServerParams": [
          "THEGRAPH_API_KEY"
        ],
        "routeNames": [
          "getReserves",
          "getUserData",
          "getProtocolData"
        ],
        "schemaFolder": "aave",
        "schemaName": "aave",
        "fileName": "aave.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_aave(), aave_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "alternative_fearAndGreed",
        "relativePath": "schemas/v1.2.0/alternative-me/fearAndGreed.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/alternative-me/fearAndGreed.mjs",
        "internalImport": "./../../schemas/v1.2.0/alternative-me/fearAndGreed.mjs",
        "folderName": "alternative-me",
        "hasImport": false,
        "namespace": "alternative",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getCurrentFng",
          "getHistoricalFng",
          "analyzeFngTrend"
        ],
        "schemaFolder": "alternative-me",
        "schemaName": "fearAndGreed",
        "fileName": "fearAndGreed.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_fearAndGreed(), fearAndGreed_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "berlinevents_events",
        "relativePath": "schemas/v1.2.0/berlin-de/events.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/berlin-de/events.mjs",
        "internalImport": "./../../schemas/v1.2.0/berlin-de/events.mjs",
        "folderName": "berlin-de",
        "hasImport": false,
        "namespace": "berlinevents",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "markets_festivals",
          "street_festivals",
          "christmas_markets",
          "police_assemblies"
        ],
        "schemaFolder": "berlin-de",
        "schemaName": "events",
        "fileName": "events.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_events(), events_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "berlinfunds_funds",
        "relativePath": "schemas/v1.2.0/berlin-de/funds.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/berlin-de/funds.mjs",
        "internalImport": "./../../schemas/v1.2.0/berlin-de/funds.mjs",
        "folderName": "berlin-de",
        "hasImport": false,
        "namespace": "berlinfunds",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "funding_opportunities",
          "continuing_education"
        ],
        "schemaFolder": "berlin-de",
        "schemaName": "funds",
        "fileName": "funds.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_funds(), funds_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "berlinvhs_vhs",
        "relativePath": "schemas/v1.2.0/berlin-de/vhs.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/berlin-de/vhs.mjs",
        "internalImport": "./../../schemas/v1.2.0/berlin-de/vhs.mjs",
        "folderName": "berlin-de",
        "hasImport": false,
        "namespace": "berlinvhs",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "all_courses"
        ],
        "schemaFolder": "berlin-de",
        "schemaName": "vhs",
        "fileName": "vhs.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_vhs(), vhs_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "berlinwfs_wfs-locations",
        "relativePath": "schemas/v1.2.0/berlin-de/wfs-locations.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/berlin-de/wfs-locations.mjs",
        "internalImport": "./../../schemas/v1.2.0/berlin-de/wfs-locations.mjs",
        "folderName": "berlin-de",
        "hasImport": false,
        "namespace": "berlinwfs",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "dog_parks",
          "bbq_areas"
        ],
        "schemaFolder": "berlin-de",
        "schemaName": "wfs-locations",
        "fileName": "wfs-locations.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_wfs_locations(), wfs_locations_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "bicscan_bicscan",
        "relativePath": "schemas/v1.2.0/bicscan/bicscan.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/bicscan/bicscan.mjs",
        "internalImport": "./../../schemas/v1.2.0/bicscan/bicscan.mjs",
        "folderName": "bicscan",
        "hasImport": false,
        "namespace": "bicscan",
        "tags": [
          "security",
          "risk",
          "scanning"
        ],
        "requiredServerParams": [
          "BICSCAN_API_KEY"
        ],
        "routeNames": [
          "getRiskScore",
          "getAssets"
        ],
        "schemaFolder": "bicscan",
        "schemaName": "bicscan",
        "fileName": "bicscan.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_bicscan(), bicscan_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "bitget_bitget",
        "relativePath": "schemas/v1.2.0/bitget/bitget.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/bitget/bitget.mjs",
        "internalImport": "./../../schemas/v1.2.0/bitget/bitget.mjs",
        "folderName": "bitget",
        "hasImport": false,
        "namespace": "bitget",
        "tags": [
          "production",
          "exchange",
          "trading",
          "price"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getTokenPrice",
          "getAnnoucements",
          "getCoinInfo"
        ],
        "schemaFolder": "bitget",
        "schemaName": "bitget",
        "fileName": "bitget.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_bitget(), bitget_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "blockberry_mina-mainnet",
        "relativePath": "schemas/v1.2.0/blockberry-one/mina-mainnet.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/blockberry-one/mina-mainnet.mjs",
        "internalImport": "./../../schemas/v1.2.0/blockberry-one/mina-mainnet.mjs",
        "folderName": "blockberry-one",
        "hasImport": false,
        "namespace": "blockberry",
        "tags": [
          "production",
          "blockchain",
          "explorer",
          "mina"
        ],
        "requiredServerParams": [
          "BLOCKBERRY_API_KEY"
        ],
        "routeNames": [
          "getDashboardInfo",
          "getAccountByHash",
          "getAccountBalance",
          "getBlocks",
          "getZkAppTransactions",
          "getZkAppByAddress"
        ],
        "schemaFolder": "blockberry-one",
        "schemaName": "mina-mainnet",
        "fileName": "mina-mainnet.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_mina_mainnet(), mina_mainnet_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "blocknative_gasprice",
        "relativePath": "schemas/v1.2.0/blocknative/gasprice.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/blocknative/gasprice.mjs",
        "internalImport": "./../../schemas/v1.2.0/blocknative/gasprice.mjs",
        "folderName": "blocknative",
        "hasImport": false,
        "namespace": "blocknative",
        "tags": [
          "new"
        ],
        "requiredServerParams": [
          "BLOCKNATIVE_API_KEY"
        ],
        "routeNames": [
          "getGasPrices"
        ],
        "schemaFolder": "blocknative",
        "schemaName": "gasprice",
        "fileName": "gasprice.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_gasprice(), gasprice_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "bridgeRates_bridgerates",
        "relativePath": "schemas/v1.2.0/bridgerates/bridgerates.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/bridgerates/bridgerates.mjs",
        "internalImport": "./../../schemas/v1.2.0/bridgerates/bridgerates.mjs",
        "folderName": "bridgerates",
        "hasImport": false,
        "namespace": "bridgeRates",
        "tags": [
          "bridge",
          "crosschain",
          "defi"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getSupportedChains",
          "getSupportedTools",
          "getConnections",
          "getTransferStatus"
        ],
        "schemaFolder": "bridgerates",
        "schemaName": "bridgerates",
        "fileName": "bridgerates.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_bridgerates(), bridgerates_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "bscscan_getContractBinance",
        "relativePath": "schemas/v1.2.0/bscscan/getContractBinance.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/bscscan/getContractBinance.mjs",
        "internalImport": "./../../schemas/v1.2.0/bscscan/getContractBinance.mjs",
        "folderName": "bscscan",
        "hasImport": false,
        "namespace": "bscscan",
        "tags": [
          "test"
        ],
        "requiredServerParams": [
          "BSCSCAN_API_KEY"
        ],
        "routeNames": [
          "getContractABI",
          "getContractSourceCode"
        ],
        "schemaFolder": "bscscan",
        "schemaName": "getContractBinance",
        "fileName": "getContractBinance.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getContractBinance(), getContractBinance_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "chainlist_chainlist",
        "relativePath": "schemas/v1.2.0/chainlist/chainlist.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/chainlist/chainlist.mjs",
        "internalImport": "./../../schemas/v1.2.0/chainlist/chainlist.mjs",
        "folderName": "chainlist",
        "hasImport": false,
        "namespace": "chainlist",
        "tags": [
          "production",
          "blockchain",
          "rpc",
          "network"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getChainById",
          "getChainsByKeyword",
          "getExplorerURLs",
          "getRPCEndpoints",
          "getWebsocketEndpoints"
        ],
        "schemaFolder": "chainlist",
        "schemaName": "chainlist",
        "fileName": "chainlist.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_chainlist(), chainlist_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "chartImg_tradingview-charts",
        "relativePath": "schemas/v1.2.0/chart-img-com/tradingview-charts.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/chart-img-com/tradingview-charts.mjs",
        "internalImport": "./../../schemas/v1.2.0/chart-img-com/tradingview-charts.mjs",
        "folderName": "chart-img-com",
        "hasImport": false,
        "namespace": "chartImg",
        "tags": [
          "charts",
          "visualization",
          "trading"
        ],
        "requiredServerParams": [
          "CHART_IMG_API_KEY"
        ],
        "routeNames": [
          "getAdvancedChart"
        ],
        "schemaFolder": "chart-img-com",
        "schemaName": "tradingview-charts",
        "fileName": "tradingview-charts.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tradingview_charts(), tradingview_charts_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coincap_assets",
        "relativePath": "schemas/v1.2.0/coincap/assets.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coincap/assets.mjs",
        "internalImport": "./../../schemas/v1.2.0/coincap/assets.mjs",
        "folderName": "coincap",
        "hasImport": false,
        "namespace": "coincap",
        "tags": [],
        "requiredServerParams": [
          "COINCAP_API_KEY"
        ],
        "routeNames": [
          "listAssets",
          "singleAsset",
          "assetMarkets",
          "assetHistory"
        ],
        "schemaFolder": "coincap",
        "schemaName": "assets",
        "fileName": "assets.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_assets(), assets_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coincap_exchanges",
        "relativePath": "schemas/v1.2.0/coincap/exchanges.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coincap/exchanges.mjs",
        "internalImport": "./../../schemas/v1.2.0/coincap/exchanges.mjs",
        "folderName": "coincap",
        "hasImport": false,
        "namespace": "coincap",
        "tags": [],
        "requiredServerParams": [
          "COINCAP_API_KEY"
        ],
        "routeNames": [
          "listExchanges",
          "getExchangeById"
        ],
        "schemaFolder": "coincap",
        "schemaName": "exchanges",
        "fileName": "exchanges.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_exchanges(), exchanges_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coincap_markets",
        "relativePath": "schemas/v1.2.0/coincap/markets.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coincap/markets.mjs",
        "internalImport": "./../../schemas/v1.2.0/coincap/markets.mjs",
        "folderName": "coincap",
        "hasImport": false,
        "namespace": "coincap",
        "tags": [],
        "requiredServerParams": [
          "COINCAP_API_KEY"
        ],
        "routeNames": [
          "listMarkets"
        ],
        "schemaFolder": "coincap",
        "schemaName": "markets",
        "fileName": "markets.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_markets(), markets_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coincap_rates",
        "relativePath": "schemas/v1.2.0/coincap/rates.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coincap/rates.mjs",
        "internalImport": "./../../schemas/v1.2.0/coincap/rates.mjs",
        "folderName": "coincap",
        "hasImport": false,
        "namespace": "coincap",
        "tags": [],
        "requiredServerParams": [
          "COINCAP_API_KEY"
        ],
        "routeNames": [
          "listRates",
          "getRateBySlug"
        ],
        "schemaFolder": "coincap",
        "schemaName": "rates",
        "fileName": "rates.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_rates(), rates_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_coingecko-stablecoins",
        "relativePath": "schemas/v1.2.0/coingecko-com/coingecko-stablecoins.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/coingecko-stablecoins.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/coingecko-stablecoins.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [
          "price",
          "market",
          "stablecoins"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getSupportedStablecoins",
          "getCurrentPrice",
          "getHistoricalData",
          "analyzePegStability"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "coingecko-stablecoins",
        "fileName": "coingecko-stablecoins.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_coingecko_stablecoins(), coingecko_stablecoins_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_coins",
        "relativePath": "schemas/v1.2.0/coingecko-com/coins.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/coins.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/coins.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getCoinsList",
          "getCoinsMarkets",
          "getCoinById",
          "getCoinMarketChart",
          "getCoinHistory",
          "getCoinTickers",
          "getCoinContractInfo"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "coins",
        "fileName": "coins.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_coins(), coins_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_derivatives",
        "relativePath": "schemas/v1.2.0/coingecko-com/derivatives.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/derivatives.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/derivatives.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getDerivativeExchangeIds",
          "getDerivativeExchangesByIds",
          "getDerivativeProductsByExchangeId"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "derivatives",
        "fileName": "derivatives.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_derivatives(), derivatives_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_exchanges",
        "relativePath": "schemas/v1.2.0/coingecko-com/exchanges.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/exchanges.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/exchanges.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getExchangesList",
          "getExchangeById",
          "getExchangeTickers"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "exchanges",
        "fileName": "exchanges.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_exchanges2(), exchanges_exports2));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_getCategories",
        "relativePath": "schemas/v1.2.0/coingecko-com/getCategories.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/getCategories.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/getCategories.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getAvailableCoinCategoryIds",
          "getCoinCategoryDetailsByIds"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "getCategories",
        "fileName": "getCategories.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getCategories(), getCategories_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_global",
        "relativePath": "schemas/v1.2.0/coingecko-com/global.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/global.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/global.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getGlobalData",
          "getDeFiGlobalData"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "global",
        "fileName": "global.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_global(), global_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_simplePrice",
        "relativePath": "schemas/v1.2.0/coingecko-com/simplePrice.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/simplePrice.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/simplePrice.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getSimplePrice",
          "getTokenPrice"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "simplePrice",
        "fileName": "simplePrice.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_simplePrice(), simplePrice_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coingecko_trending",
        "relativePath": "schemas/v1.2.0/coingecko-com/trending.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coingecko-com/trending.mjs",
        "internalImport": "./../../schemas/v1.2.0/coingecko-com/trending.mjs",
        "folderName": "coingecko-com",
        "hasImport": false,
        "namespace": "coingecko",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getTrendingCoins",
          "getTrendingNfts",
          "getTrendingCategories"
        ],
        "schemaFolder": "coingecko-com",
        "schemaName": "trending",
        "fileName": "trending.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_trending(), trending_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coinmarketcap_category",
        "relativePath": "schemas/v1.2.0/coinmarketcap-com/category.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coinmarketcap-com/category.mjs",
        "internalImport": "./../../schemas/v1.2.0/coinmarketcap-com/category.mjs",
        "folderName": "coinmarketcap-com",
        "hasImport": false,
        "namespace": "coinmarketcap",
        "tags": [],
        "requiredServerParams": [
          "CMC_API_KEY"
        ],
        "routeNames": [
          "getCategories",
          "getCategory",
          "getIdMap",
          "getMetadataV2",
          "getQuotesLatestV2"
        ],
        "schemaFolder": "coinmarketcap-com",
        "schemaName": "category",
        "fileName": "category.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_category(), category_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coinmarketcap_cmc-index",
        "relativePath": "schemas/v1.2.0/coinmarketcap-com/cmc-index.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coinmarketcap-com/cmc-index.mjs",
        "internalImport": "./../../schemas/v1.2.0/coinmarketcap-com/cmc-index.mjs",
        "folderName": "coinmarketcap-com",
        "hasImport": false,
        "namespace": "coinmarketcap",
        "tags": [],
        "requiredServerParams": [
          "CMC_API_KEY"
        ],
        "routeNames": [
          "getHistorical",
          "getLatest"
        ],
        "schemaFolder": "coinmarketcap-com",
        "schemaName": "cmc-index",
        "fileName": "cmc-index.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_cmc_index(), cmc_index_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coinmarketcap_fear-and-greed",
        "relativePath": "schemas/v1.2.0/coinmarketcap-com/fear-and-greed.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coinmarketcap-com/fear-and-greed.mjs",
        "internalImport": "./../../schemas/v1.2.0/coinmarketcap-com/fear-and-greed.mjs",
        "folderName": "coinmarketcap-com",
        "hasImport": false,
        "namespace": "coinmarketcap",
        "tags": [],
        "requiredServerParams": [
          "CMC_API_KEY"
        ],
        "routeNames": [
          "getFearAndGreedHistorical",
          "getFearAndGreedLatest"
        ],
        "schemaFolder": "coinmarketcap-com",
        "schemaName": "fear-and-greed",
        "fileName": "fear-and-greed.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_fear_and_greed(), fear_and_greed_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "coinmarketcap_listings",
        "relativePath": "schemas/v1.2.0/coinmarketcap-com/listings.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coinmarketcap-com/listings.mjs",
        "internalImport": "./../../schemas/v1.2.0/coinmarketcap-com/listings.mjs",
        "folderName": "coinmarketcap-com",
        "hasImport": false,
        "namespace": "coinmarketcap",
        "tags": [],
        "requiredServerParams": [
          "CMC_API_KEY"
        ],
        "routeNames": [
          "listingsLatest"
        ],
        "schemaFolder": "coinmarketcap-com",
        "schemaName": "listings",
        "fileName": "listings.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_listings(), listings_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "cryptodata_mixed",
        "relativePath": "schemas/v1.2.0/coinstats/mixed.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/coinstats/mixed.mjs",
        "internalImport": "./../../schemas/v1.2.0/coinstats/mixed.mjs",
        "folderName": "coinstats",
        "hasImport": false,
        "namespace": "cryptodata",
        "tags": [
          "production",
          "price",
          "market",
          "data"
        ],
        "requiredServerParams": [
          "COINSTATS_API_KEY"
        ],
        "routeNames": [
          "getCoins",
          "getCoinById",
          "getCoinChartById",
          "getCoinAvgPrice",
          "getCoinExchangePrice",
          "getTickerExchanges",
          "getTickerMarkets",
          "getBlockchains",
          "getWalletBalance",
          "getWalletBalances",
          "getExchanges",
          "getFiatCurrencies",
          "getNewsSources",
          "getNews",
          "getNewsByType",
          "getNewsById",
          "getMarketCap",
          "getCurrencies"
        ],
        "schemaFolder": "coinstats",
        "schemaName": "mixed",
        "fileName": "mixed.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_mixed(), mixed_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "context7_getDocumentation",
        "relativePath": "schemas/v1.2.0/context-7/getDocumentation.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/context-7/getDocumentation.mjs",
        "internalImport": "./../../schemas/v1.2.0/context-7/getDocumentation.mjs",
        "folderName": "context-7",
        "hasImport": false,
        "namespace": "context7",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "searchLibraryId",
          "getLibraryDocs"
        ],
        "schemaFolder": "context-7",
        "schemaName": "getDocumentation",
        "fileName": "getDocumentation.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getDocumentation(), getDocumentation_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "cryptopanic_getNews",
        "relativePath": "schemas/v1.2.0/cryptopanic/getNews.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/cryptopanic/getNews.mjs",
        "internalImport": "./../../schemas/v1.2.0/cryptopanic/getNews.mjs",
        "folderName": "cryptopanic",
        "hasImport": false,
        "namespace": "cryptopanic",
        "tags": [],
        "requiredServerParams": [
          "CRYPTOPANIC_API_KEY"
        ],
        "routeNames": [
          "getCryptoCryptopanicNews"
        ],
        "schemaFolder": "cryptopanic",
        "schemaName": "getNews",
        "fileName": "getNews.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getNews(), getNews_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "cryptowizards_analytics",
        "relativePath": "schemas/v1.2.0/cryptowizards-net/analytics.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/cryptowizards-net/analytics.mjs",
        "internalImport": "./../../schemas/v1.2.0/cryptowizards-net/analytics.mjs",
        "folderName": "cryptowizards-net",
        "hasImport": false,
        "namespace": "cryptowizards",
        "tags": [
          "production",
          "analytics",
          "trading",
          "backtest"
        ],
        "requiredServerParams": [
          "CRYPTOWIZARDS_API_KEY"
        ],
        "routeNames": [
          "runBacktest",
          "checkCointegration",
          "getCorrelations",
          "analyzeCopula",
          "analyzeSpread",
          "analyzeZScores"
        ],
        "schemaFolder": "cryptowizards-net",
        "schemaName": "analytics",
        "fileName": "analytics.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_analytics(), analytics_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "defillama_api",
        "relativePath": "schemas/v1.2.0/defilama/api.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/defilama/api.mjs",
        "internalImport": "./../../schemas/v1.2.0/defilama/api.mjs",
        "folderName": "defilama",
        "hasImport": false,
        "namespace": "defillama",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getProtocols",
          "getProtocolTvl",
          "getChainTvl"
        ],
        "schemaFolder": "defilama",
        "schemaName": "api",
        "fileName": "api.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_api(), api_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "defillama_coins",
        "relativePath": "schemas/v1.2.0/defilama/coins.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/defilama/coins.mjs",
        "internalImport": "./../../schemas/v1.2.0/defilama/coins.mjs",
        "folderName": "defilama",
        "hasImport": false,
        "namespace": "defillama",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getTokenPrices"
        ],
        "schemaFolder": "defilama",
        "schemaName": "coins",
        "fileName": "coins.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_coins2(), coins_exports2));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "defillama_yields",
        "relativePath": "schemas/v1.2.0/defilama/yields.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/defilama/yields.mjs",
        "internalImport": "./../../schemas/v1.2.0/defilama/yields.mjs",
        "folderName": "defilama",
        "hasImport": false,
        "namespace": "defillama",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getPools",
          "getPoolTvl"
        ],
        "schemaFolder": "defilama",
        "schemaName": "yields",
        "fileName": "yields.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_yields(), yields_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "dexscreener_boosted",
        "relativePath": "schemas/v1.2.0/dexscreener-com/boosted.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/dexscreener-com/boosted.mjs",
        "internalImport": "./../../schemas/v1.2.0/dexscreener-com/boosted.mjs",
        "folderName": "dexscreener-com",
        "hasImport": false,
        "namespace": "dexscreener",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getLatestBoostedTokens",
          "getMostActiveBoostedTokens"
        ],
        "schemaFolder": "dexscreener-com",
        "schemaName": "boosted",
        "fileName": "boosted.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_boosted(), boosted_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "dexscreener_pairs",
        "relativePath": "schemas/v1.2.0/dexscreener-com/pairs.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/dexscreener-com/pairs.mjs",
        "internalImport": "./../../schemas/v1.2.0/dexscreener-com/pairs.mjs",
        "folderName": "dexscreener-com",
        "hasImport": false,
        "namespace": "dexscreener",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getPairByChainAndAddress",
          "checkTokenOrders"
        ],
        "schemaFolder": "dexscreener-com",
        "schemaName": "pairs",
        "fileName": "pairs.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_pairs(), pairs_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "dexscreener_tokenInfo",
        "relativePath": "schemas/v1.2.0/dexscreener-com/tokenInfo.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/dexscreener-com/tokenInfo.mjs",
        "internalImport": "./../../schemas/v1.2.0/dexscreener-com/tokenInfo.mjs",
        "folderName": "dexscreener-com",
        "hasImport": false,
        "namespace": "dexscreener",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getLatestTokenProfiles",
          "searchPairs",
          "getPairsByToken",
          "getTokenPools"
        ],
        "schemaFolder": "dexscreener-com",
        "schemaName": "tokenInfo",
        "fileName": "tokenInfo.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tokenInfo(), tokenInfo_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "dexscreener_tokenpairs",
        "relativePath": "schemas/v1.2.0/dexscreener-com/tokenpairs.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/dexscreener-com/tokenpairs.mjs",
        "internalImport": "./../../schemas/v1.2.0/dexscreener-com/tokenpairs.mjs",
        "folderName": "dexscreener-com",
        "hasImport": false,
        "namespace": "dexscreener",
        "tags": [
          "dex",
          "trading",
          "pairs"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getTokenPairs",
          "searchPairs",
          "getLatestPairs",
          "getPairsByChain",
          "getSpecificPair"
        ],
        "schemaFolder": "dexscreener-com",
        "schemaName": "tokenpairs",
        "fileName": "tokenpairs.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tokenpairs(), tokenpairs_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "duneAnalytics_farcaster",
        "relativePath": "schemas/v1.2.0/dune-analytics/farcaster.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/dune-analytics/farcaster.mjs",
        "internalImport": "./../../schemas/v1.2.0/dune-analytics/farcaster.mjs",
        "folderName": "dune-analytics",
        "hasImport": false,
        "namespace": "duneAnalytics",
        "tags": [],
        "requiredServerParams": [
          "DUNE_API_KEY"
        ],
        "routeNames": [
          "farcasterGetTrendingMemecoins",
          "farcasterGetTrendingChannels",
          "farcasterGetTrendingUsers"
        ],
        "schemaFolder": "dune-analytics",
        "schemaName": "farcaster",
        "fileName": "farcaster.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_farcaster(), farcaster_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "duneAnalytics_getResults",
        "relativePath": "schemas/v1.2.0/dune-analytics/getResults.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/dune-analytics/getResults.mjs",
        "internalImport": "./../../schemas/v1.2.0/dune-analytics/getResults.mjs",
        "folderName": "dune-analytics",
        "hasImport": false,
        "namespace": "duneAnalytics",
        "tags": [],
        "requiredServerParams": [
          "DUNE_API_KEY"
        ],
        "routeNames": [
          "getLatestResult"
        ],
        "schemaFolder": "dune-analytics",
        "schemaName": "getResults",
        "fileName": "getResults.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getResults(), getResults_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "duneAnalytics_trendingContracts",
        "relativePath": "schemas/v1.2.0/dune-analytics/trendingContracts.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/dune-analytics/trendingContracts.mjs",
        "internalImport": "./../../schemas/v1.2.0/dune-analytics/trendingContracts.mjs",
        "folderName": "dune-analytics",
        "hasImport": false,
        "namespace": "duneAnalytics",
        "tags": [],
        "requiredServerParams": [
          "DUNE_API_KEY"
        ],
        "routeNames": [
          "getDexPairStats",
          "getTrendingContracts",
          "getMarketShare"
        ],
        "schemaFolder": "dune-analytics",
        "schemaName": "trendingContracts",
        "fileName": "trendingContracts.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_trendingContracts(), trendingContracts_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "epo_patent-search",
        "relativePath": "schemas/v1.2.0/epo-org/patent-search.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/epo-org/patent-search.mjs",
        "internalImport": "./../../schemas/v1.2.0/epo-org/patent-search.mjs",
        "folderName": "epo-org",
        "hasImport": false,
        "namespace": "epo",
        "tags": [
          "patents",
          "research",
          "search"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "searchPatents",
          "searchByTechnology",
          "searchByKeywords",
          "searchByDate"
        ],
        "schemaFolder": "epo-org",
        "schemaName": "patent-search",
        "fileName": "patent-search.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_patent_search(), patent_search_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "profilejump_profileJump",
        "relativePath": "schemas/v1.2.0/erc725/profileJump.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/erc725/profileJump.mjs",
        "internalImport": "./../../schemas/v1.2.0/erc725/profileJump.mjs",
        "folderName": "erc725",
        "hasImport": false,
        "namespace": "profilejump",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "prices",
          "hotProfiles",
          "tokensList",
          "profilesList",
          "profileByAddress"
        ],
        "schemaFolder": "erc725",
        "schemaName": "profileJump",
        "fileName": "profileJump.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_profileJump(), profileJump_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "etherscan_getContractEthereum",
        "relativePath": "schemas/v1.2.0/etherscan/getContractEthereum.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/etherscan/getContractEthereum.mjs",
        "internalImport": "./../../schemas/v1.2.0/etherscan/getContractEthereum.mjs",
        "folderName": "etherscan",
        "hasImport": false,
        "namespace": "etherscan",
        "tags": [],
        "requiredServerParams": [
          "ETHERSCAN_API_KEY"
        ],
        "routeNames": [
          "getContractABI",
          "getContractSourceCode"
        ],
        "schemaFolder": "etherscan",
        "schemaName": "getContractEthereum",
        "fileName": "getContractEthereum.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getContractEthereum(), getContractEthereum_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "etherscan_getContractMultichain",
        "relativePath": "schemas/v1.2.0/etherscan/getContractMultichain.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/etherscan/getContractMultichain.mjs",
        "internalImport": "./../../schemas/v1.2.0/etherscan/getContractMultichain.mjs",
        "folderName": "etherscan",
        "hasImport": false,
        "namespace": "etherscan",
        "tags": [],
        "requiredServerParams": [
          "ETHERSCAN_API_KEY"
        ],
        "routeNames": [
          "getAvailableChains",
          "getSmartContractAbi",
          "getSourceCode"
        ],
        "schemaFolder": "etherscan",
        "schemaName": "getContractMultichain",
        "fileName": "getContractMultichain.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getContractMultichain(), getContractMultichain_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "etherscan_getGaspriceMultichain",
        "relativePath": "schemas/v1.2.0/etherscan/getGaspriceMultichain.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/etherscan/getGaspriceMultichain.mjs",
        "internalImport": "./../../schemas/v1.2.0/etherscan/getGaspriceMultichain.mjs",
        "folderName": "etherscan",
        "hasImport": false,
        "namespace": "etherscan",
        "tags": [],
        "requiredServerParams": [
          "ETHERSCAN_API_KEY"
        ],
        "routeNames": [
          "getGasOracle",
          "estimateGasCost"
        ],
        "schemaFolder": "etherscan",
        "schemaName": "getGaspriceMultichain",
        "fileName": "getGaspriceMultichain.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getGaspriceMultichain(), getGaspriceMultichain_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "ethscriptions_ethscriptions-api",
        "relativePath": "schemas/v1.2.0/ethscriptions-com/ethscriptions-api.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/ethscriptions-com/ethscriptions-api.mjs",
        "internalImport": "./../../schemas/v1.2.0/ethscriptions-com/ethscriptions-api.mjs",
        "folderName": "ethscriptions-com",
        "hasImport": false,
        "namespace": "ethscriptions",
        "tags": [
          "nft",
          "ethereum",
          "inscriptions"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "listEthscriptions",
          "getEthscription",
          "getEthscriptionData",
          "getEthscriptionAttachment",
          "checkEthscriptionExists",
          "checkMultipleEthscriptionsExistence",
          "listTransfers",
          "listTokens",
          "getTokenDetails",
          "getTokenHistoricalState",
          "getIndexerStatus"
        ],
        "schemaFolder": "ethscriptions-com",
        "schemaName": "ethscriptions-api",
        "fileName": "ethscriptions-api.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_ethscriptions_api(), ethscriptions_api_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "goldskyNouns_goldsky-nouns",
        "relativePath": "schemas/v1.2.0/goldsky-nouns/goldsky-nouns.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/goldsky-nouns/goldsky-nouns.mjs",
        "internalImport": "./../../schemas/v1.2.0/goldsky-nouns/goldsky-nouns.mjs",
        "folderName": "goldsky-nouns",
        "hasImport": false,
        "namespace": "goldskyNouns",
        "tags": [
          "production",
          "dao",
          "governance",
          "nft"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getRecentProposals",
          "getCurrentAuctions",
          "getNounDetails",
          "getTopDelegates"
        ],
        "schemaFolder": "goldsky-nouns",
        "schemaName": "goldsky-nouns",
        "fileName": "goldsky-nouns.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_goldsky_nouns(), goldsky_nouns_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "goldskyLilNouns_lil-nouns",
        "relativePath": "schemas/v1.2.0/goldsky-nouns/lil-nouns.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/goldsky-nouns/lil-nouns.mjs",
        "internalImport": "./../../schemas/v1.2.0/goldsky-nouns/lil-nouns.mjs",
        "folderName": "goldsky-nouns",
        "hasImport": false,
        "namespace": "goldskyLilNouns",
        "tags": [
          "production",
          "data",
          "api"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getProposals",
          "getProposalById"
        ],
        "schemaFolder": "goldsky-nouns",
        "schemaName": "lil-nouns",
        "fileName": "lil-nouns.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_lil_nouns(), lil_nouns_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "goldskyNouns_nouns",
        "relativePath": "schemas/v1.2.0/goldsky-nouns/nouns.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/goldsky-nouns/nouns.mjs",
        "internalImport": "./../../schemas/v1.2.0/goldsky-nouns/nouns.mjs",
        "folderName": "goldsky-nouns",
        "hasImport": false,
        "namespace": "goldskyNouns",
        "tags": [
          "production",
          "dao",
          "governance",
          "nft"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getCandidateProposals",
          "getActivePendingUpdatableProposers",
          "getLatestAuctions"
        ],
        "schemaFolder": "goldsky-nouns",
        "schemaName": "nouns",
        "fileName": "nouns.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_nouns(), nouns_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "honeypot_honeypot",
        "relativePath": "schemas/v1.2.0/honeypot/honeypot.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/honeypot/honeypot.mjs",
        "internalImport": "./../../schemas/v1.2.0/honeypot/honeypot.mjs",
        "folderName": "honeypot",
        "hasImport": false,
        "namespace": "honeypot",
        "tags": [
          "production",
          "security",
          "token",
          "validation"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "check"
        ],
        "schemaFolder": "honeypot",
        "schemaName": "honeypot",
        "fileName": "honeypot.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_honeypot(), honeypot_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "jupiter_jupiter-all",
        "relativePath": "schemas/v1.2.0/jupiter/jupiter-all.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/jupiter/jupiter-all.mjs",
        "internalImport": "./../../schemas/v1.2.0/jupiter/jupiter-all.mjs",
        "folderName": "jupiter",
        "hasImport": false,
        "namespace": "jupiter",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getTokenPrice",
          "getTokenInfo",
          "getTokensInMarket",
          "getAllTradableTokens",
          "getTaggedTokens",
          "getNewTokens",
          "getAllTokens"
        ],
        "schemaFolder": "jupiter",
        "schemaName": "jupiter-all",
        "fileName": "jupiter-all.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_jupiter_all(), jupiter_all_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "llama_getPools",
        "relativePath": "schemas/v1.2.0/llama-fi/getPools.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/llama-fi/getPools.mjs",
        "internalImport": "./../../schemas/v1.2.0/llama-fi/getPools.mjs",
        "folderName": "llama-fi",
        "hasImport": false,
        "namespace": "llama",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getProjectsByName",
          "getPools"
        ],
        "schemaFolder": "llama-fi",
        "schemaName": "getPools",
        "fileName": "getPools.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getPools(), getPools_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_address",
        "relativePath": "schemas/v1.2.0/lukso-network/address.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/address.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/address.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "listAddresses",
          "getAddress",
          "getAddressCounters",
          "getAddressTransactions",
          "getAddressTokenTransfers",
          "getAddressInternalTxs",
          "getAddressLogs",
          "getBlocksValidated",
          "getTokenBalances",
          "getFlatTokenBalances",
          "getCoinBalanceHistory",
          "getCoinBalanceByDay"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "address",
        "fileName": "address.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_address(), address_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_blocks",
        "relativePath": "schemas/v1.2.0/lukso-network/blocks.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/blocks.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/blocks.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getBlocks",
          "getBlockById",
          "getBlockTransactions",
          "getBlockWithdrawals"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "blocks",
        "fileName": "blocks.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_blocks(), blocks_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_graphql",
        "relativePath": "schemas/v1.2.0/lukso-network/graphql.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/graphql.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/graphql.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getLuksoExplorerSchema",
          "fectchLuksoExplorer"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "graphql",
        "fileName": "graphql.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_graphql(), graphql_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_internal",
        "relativePath": "schemas/v1.2.0/lukso-network/internal.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/internal.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/internal.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getMainPageTransactions",
          "getMainPageBlocks"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "internal",
        "fileName": "internal.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_internal(), internal_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_nfts",
        "relativePath": "schemas/v1.2.0/lukso-network/nfts.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/nfts.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/nfts.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getNFTsByAddress",
          "getNFTCollectionsByAddress",
          "getNFTInstancesByContract",
          "getNFTInstanceById",
          "getNFTInstanceTransfers",
          "getNFTInstanceHolders",
          "getNFTInstanceTransfersCount"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "nfts",
        "fileName": "nfts.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_nfts(), nfts_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_search",
        "relativePath": "schemas/v1.2.0/lukso-network/search.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/search.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/search.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "search",
          "searchRedirect"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "search",
        "fileName": "search.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_search(), search_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_sourceCode",
        "relativePath": "schemas/v1.2.0/lukso-network/sourceCode.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/sourceCode.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/sourceCode.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "listcontracts",
          "getabi",
          "getsourcecode",
          "getcontractcreation"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "sourceCode",
        "fileName": "sourceCode.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_sourceCode(), sourceCode_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_stats",
        "relativePath": "schemas/v1.2.0/lukso-network/stats.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/stats.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/stats.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getStats",
          "getTransactionChart",
          "getMarketChart"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "stats",
        "fileName": "stats.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_stats(), stats_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_tokens",
        "relativePath": "schemas/v1.2.0/lukso-network/tokens.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/tokens.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/tokens.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "listTokens",
          "getTokenByAddress",
          "getTokenTransfersByAddress",
          "getTokenHolders",
          "getTokenCounters"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "tokens",
        "fileName": "tokens.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tokens(), tokens_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "luksoNetwork_transactions",
        "relativePath": "schemas/v1.2.0/lukso-network/transactions.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/lukso-network/transactions.mjs",
        "internalImport": "./../../schemas/v1.2.0/lukso-network/transactions.mjs",
        "folderName": "lukso-network",
        "hasImport": false,
        "namespace": "luksoNetwork",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getTransactions",
          "getTransactionByHash",
          "getTokenTransfersByTransactionHash",
          "getInternalTransactions",
          "getLogs",
          "getRawTrace",
          "getStateChanges"
        ],
        "schemaFolder": "lukso-network",
        "schemaName": "transactions",
        "fileName": "transactions.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_transactions(), transactions_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "medium_rss-feeds",
        "relativePath": "schemas/v1.2.0/medium-com/rss-feeds.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/medium-com/rss-feeds.mjs",
        "internalImport": "./../../schemas/v1.2.0/medium-com/rss-feeds.mjs",
        "folderName": "medium-com",
        "hasImport": false,
        "namespace": "medium",
        "tags": [
          "content",
          "social",
          "feeds"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getTagFeed",
          "getUserFeed",
          "getPublicationFeed",
          "getTopicFeed"
        ],
        "schemaFolder": "medium-com",
        "schemaName": "rss-feeds",
        "fileName": "rss-feeds.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_rss_feeds(), rss_feeds_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "memoryLol_twitterNameChanges",
        "relativePath": "schemas/v1.2.0/memory-lol/twitterNameChanges.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/memory-lol/twitterNameChanges.mjs",
        "internalImport": "./../../schemas/v1.2.0/memory-lol/twitterNameChanges.mjs",
        "folderName": "memory-lol",
        "hasImport": false,
        "namespace": "memoryLol",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "queryUsernameChanges"
        ],
        "schemaFolder": "memory-lol",
        "schemaName": "twitterNameChanges",
        "fileName": "twitterNameChanges.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_twitterNameChanges(), twitterNameChanges_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "minascanDevnet_mina-devnet",
        "relativePath": "schemas/v1.2.0/minascan-io/mina-devnet.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/minascan-io/mina-devnet.mjs",
        "internalImport": "./../../schemas/v1.2.0/minascan-io/mina-devnet.mjs",
        "folderName": "minascan-io",
        "hasImport": false,
        "namespace": "minascanDevnet",
        "tags": [
          "production",
          "blockchain",
          "explorer",
          "mina"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getMinaDevnetSchema",
          "getMinaDevnetQuery"
        ],
        "schemaFolder": "minascan-io",
        "schemaName": "mina-devnet",
        "fileName": "mina-devnet.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_mina_devnet(), mina_devnet_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "minascanMainnet_mina-mainnet",
        "relativePath": "schemas/v1.2.0/minascan-io/mina-mainnet.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/minascan-io/mina-mainnet.mjs",
        "internalImport": "./../../schemas/v1.2.0/minascan-io/mina-mainnet.mjs",
        "folderName": "minascan-io",
        "hasImport": false,
        "namespace": "minascanMainnet",
        "tags": [
          "production",
          "blockchain",
          "explorer",
          "mina"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getMinaMainnetSchema",
          "getMinaMainnetQuery"
        ],
        "schemaFolder": "minascan-io",
        "schemaName": "mina-mainnet",
        "fileName": "mina-mainnet.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_mina_mainnet2(), mina_mainnet_exports2));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_blockchainApi",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/blockchainApi.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/blockchainApi.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/blockchainApi.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/block/:block_number_or_hash",
          "/dateToBlock",
          "/transaction/:transaction_hash/verbose",
          "/:address/verbose",
          "/latestBlockNumber/:chain",
          "/transaction/:transaction_hash",
          "/:address"
        ],
        "schemaFolder": "eth",
        "schemaName": "blockchainApi",
        "fileName": "blockchainApi.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_blockchainApi(), blockchainApi_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_defiApi",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/defiApi.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/defiApi.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/defiApi.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/wallets/:address/defi/:protocol/positions",
          "/wallets/:address/defi/positions",
          "/wallets/:address/defi/summary"
        ],
        "schemaFolder": "eth",
        "schemaName": "defiApi",
        "fileName": "defiApi.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_defiApi(), defiApi_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_entity",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/entity.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/entity.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/entity.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/entities/categories"
        ],
        "schemaFolder": "eth",
        "schemaName": "entity",
        "fileName": "entity.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_entity(), entity_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_nftApi",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/nftApi.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/nftApi.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/nftApi.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/market-data/nfts/top-collections",
          "/market-data/nfts/hottest-collections",
          "/nft/:address",
          "/nft/:address/stats",
          "/nft/:address/metadata",
          "/nft/:address/transfers",
          "/nft/:address/:token_id",
          "/nft/:address/owners",
          "/nft/:address/:token_id/owners",
          "/nft/:address/:token_id/trades",
          "/wallets/:address/nfts/trades",
          "/nft/:address/trades",
          "/nft/:address/traits/paginate",
          "/nft/:address/traits",
          "/nft/:address/:token_id/transfers",
          "/:address/nft/collections",
          "/:address/nft/transfers",
          "/:address/nft",
          "/nft/:address/:token_id/metadata/resync",
          "/nft/:address/traits/resync"
        ],
        "schemaFolder": "eth",
        "schemaName": "nftApi",
        "fileName": "nftApi.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_nftApi(), nftApi_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_priceApi",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/priceApi.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/priceApi.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/priceApi.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/nft/:address/price",
          "/nft/:address/floor-price",
          "/nft/:address/:token_id/floor-price",
          "/nft/:address/floor-price/historical",
          "/nft/:address/:token_id/price",
          "/pairs/:address/ohlcv",
          "/erc20/:address/price"
        ],
        "schemaFolder": "eth",
        "schemaName": "priceApi",
        "fileName": "priceApi.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_priceApi(), priceApi_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_tokenApi",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/tokenApi.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/tokenApi.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/tokenApi.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/:pair_address/reserves",
          "/pairs/:address/snipers",
          "/pairs/:address/swaps",
          "/wallets/:address/swaps",
          "/tokens/:address/analytics",
          "/erc20/:token_address/owners",
          "/erc20/metadata/symbols",
          "/erc20/metadata",
          "/erc20/:address/stats",
          "/erc20/:address/transfers",
          "/market-data/erc20s/top-tokens",
          "/erc20/:address/top-gainers",
          "/wallets/:address/approvals",
          "/wallets/:address/tokens",
          "/:address/erc20",
          "/:address/erc20/transfers"
        ],
        "schemaFolder": "eth",
        "schemaName": "tokenApi",
        "fileName": "tokenApi.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tokenApi(), tokenApi_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_utils",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/utils.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/utils.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/utils.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/info/endpointWeights",
          "/web3/version"
        ],
        "schemaFolder": "eth",
        "schemaName": "utils",
        "fileName": "utils.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_utils2(), utils_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "moralis_walletApi",
        "relativePath": "schemas/v1.2.0/moralis-com/eth/walletApi.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/moralis-com/eth/walletApi.mjs",
        "internalImport": "./../../schemas/v1.2.0/moralis-com/eth/walletApi.mjs",
        "folderName": "eth",
        "hasImport": false,
        "namespace": "moralis",
        "tags": [],
        "requiredServerParams": [
          "MORALIS_API_KEY"
        ],
        "routeNames": [
          "/wallets/:address/chains",
          "/:address/balance",
          "/wallets/:address/history",
          "/wallets/:address/net-worth",
          "/wallets/:address/profitability/summary",
          "/wallets/:address/profitability",
          "/wallets/:address/stats",
          "/resolve/:address/domain",
          "/resolve/:address/reverse",
          "/resolve/:domain",
          "/resolve/ens/:domain"
        ],
        "schemaFolder": "eth",
        "schemaName": "walletApi",
        "fileName": "walletApi.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_walletApi(), walletApi_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "newsapi_news",
        "relativePath": "schemas/v1.2.0/newsapi-org/news.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/newsapi-org/news.mjs",
        "internalImport": "./../../schemas/v1.2.0/newsapi-org/news.mjs",
        "folderName": "newsapi-org",
        "hasImport": false,
        "namespace": "newsapi",
        "tags": [
          "news",
          "media",
          "content"
        ],
        "requiredServerParams": [
          "NEWSAPI_API_KEY"
        ],
        "routeNames": [
          "getTopHeadlines",
          "getEverything",
          "getSources"
        ],
        "schemaFolder": "newsapi-org",
        "schemaName": "news",
        "fileName": "news.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_news(), news_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "newsdata_getNews",
        "relativePath": "schemas/v1.2.0/newsdata-io/getNews.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/newsdata-io/getNews.mjs",
        "internalImport": "./../../schemas/v1.2.0/newsdata-io/getNews.mjs",
        "folderName": "newsdata-io",
        "hasImport": false,
        "namespace": "newsdata",
        "tags": [],
        "requiredServerParams": [
          "NEWSDATA_API_KEY"
        ],
        "routeNames": [
          "getLatestNewsdata",
          "getCryptoNewsdata"
        ],
        "schemaFolder": "newsdata-io",
        "schemaName": "getNews",
        "fileName": "getNews.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getNews2(), getNews_exports2));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "pinata_read",
        "relativePath": "schemas/v1.2.0/pinata/read.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/pinata/read.mjs",
        "internalImport": "./../../schemas/v1.2.0/pinata/read.mjs",
        "folderName": "pinata",
        "hasImport": false,
        "namespace": "pinata",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "free_read_example",
          "free_read_cid"
        ],
        "schemaFolder": "pinata",
        "schemaName": "read",
        "fileName": "read.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_read(), read_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "poap_graphql",
        "relativePath": "schemas/v1.2.0/poap/graphql.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/poap/graphql.mjs",
        "internalImport": "./../../schemas/v1.2.0/poap/graphql.mjs",
        "folderName": "poap",
        "hasImport": false,
        "namespace": "poap",
        "tags": [
          "production",
          "graphql",
          "poap"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getTypename",
          "getSchemaDefinition",
          "getPredefinedQueryList",
          "executePrefinedQuery",
          "querySubgraph"
        ],
        "schemaFolder": "poap",
        "schemaName": "graphql",
        "fileName": "graphql.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_graphql2(), graphql_exports2));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "polymarket_marketInfo",
        "relativePath": "schemas/v1.2.0/polymarket/marketInfo.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/polymarket/marketInfo.mjs",
        "internalImport": "./../../schemas/v1.2.0/polymarket/marketInfo.mjs",
        "folderName": "polymarket",
        "hasImport": false,
        "namespace": "polymarket",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getMarkets",
          "getMarketInfo"
        ],
        "schemaFolder": "polymarket",
        "schemaName": "marketInfo",
        "fileName": "marketInfo.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_marketInfo(), marketInfo_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "polymarket_searchBySlug",
        "relativePath": "schemas/v1.2.0/polymarket/searchBySlug.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/polymarket/searchBySlug.mjs",
        "internalImport": "./../../schemas/v1.2.0/polymarket/searchBySlug.mjs",
        "folderName": "polymarket",
        "hasImport": false,
        "namespace": "polymarket",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "searchBySlug"
        ],
        "schemaFolder": "polymarket",
        "schemaName": "searchBySlug",
        "fileName": "searchBySlug.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_searchBySlug(), searchBySlug_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "redditScanner_getTokenMentions",
        "relativePath": "schemas/v1.2.0/reddit/getTokenMentions.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/reddit/getTokenMentions.mjs",
        "internalImport": "./../../schemas/v1.2.0/reddit/getTokenMentions.mjs",
        "folderName": "reddit",
        "hasImport": false,
        "namespace": "redditScanner",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "getTokenMentions",
          "getHotMemes"
        ],
        "schemaFolder": "reddit",
        "schemaName": "getTokenMentions",
        "fileName": "getTokenMentions.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getTokenMentions(), getTokenMentions_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "santiment_schema",
        "relativePath": "schemas/v1.2.0/santiment-net/schema.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/santiment-net/schema.mjs",
        "internalImport": "./../../schemas/v1.2.0/santiment-net/schema.mjs",
        "folderName": "santiment-net",
        "hasImport": false,
        "namespace": "santiment",
        "tags": [],
        "requiredServerParams": [
          "SANTIMENT_API_KEY"
        ],
        "routeNames": [
          "get_sentiment_balance",
          "get_social_volume",
          "alert_social_shift",
          "get_trending_words",
          "get_social_dominance"
        ],
        "schemaFolder": "santiment-net",
        "schemaName": "schema",
        "fileName": "schema.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "simdune_balancesEVM",
        "relativePath": "schemas/v1.2.0/simdune/balancesEVM.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/simdune/balancesEVM.mjs",
        "internalImport": "./../../schemas/v1.2.0/simdune/balancesEVM.mjs",
        "folderName": "simdune",
        "hasImport": false,
        "namespace": "simdune",
        "tags": [
          "production",
          "balances",
          "analytics",
          "portfolio"
        ],
        "requiredServerParams": [
          "DUNE_SIM_API_KEY"
        ],
        "routeNames": [
          "getBalancesEVM"
        ],
        "schemaFolder": "simdune",
        "schemaName": "balancesEVM",
        "fileName": "balancesEVM.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_balancesEVM(), balancesEVM_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "simdune_balancesSVM",
        "relativePath": "schemas/v1.2.0/simdune/balancesSVM.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/simdune/balancesSVM.mjs",
        "internalImport": "./../../schemas/v1.2.0/simdune/balancesSVM.mjs",
        "folderName": "simdune",
        "hasImport": false,
        "namespace": "simdune",
        "tags": [
          "production",
          "balances",
          "analytics",
          "portfolio",
          "svm",
          "solana"
        ],
        "requiredServerParams": [
          "DUNE_SIM_API_KEY"
        ],
        "routeNames": [
          "getBalancesSVM"
        ],
        "schemaFolder": "simdune",
        "schemaName": "balancesSVM",
        "fileName": "balancesSVM.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_balancesSVM(), balancesSVM_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "simdune_collectiblesEVM",
        "relativePath": "schemas/v1.2.0/simdune/collectiblesEVM.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/simdune/collectiblesEVM.mjs",
        "internalImport": "./../../schemas/v1.2.0/simdune/collectiblesEVM.mjs",
        "folderName": "simdune",
        "hasImport": false,
        "namespace": "simdune",
        "tags": [
          "production",
          "nft",
          "collectibles",
          "metadata"
        ],
        "requiredServerParams": [
          "DUNE_SIM_API_KEY"
        ],
        "routeNames": [
          "getCollectiblesEVM"
        ],
        "schemaFolder": "simdune",
        "schemaName": "collectiblesEVM",
        "fileName": "collectiblesEVM.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_collectiblesEVM(), collectiblesEVM_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "simdune_tokenHoldersEVM",
        "relativePath": "schemas/v1.2.0/simdune/tokenHoldersEVM.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/simdune/tokenHoldersEVM.mjs",
        "internalImport": "./../../schemas/v1.2.0/simdune/tokenHoldersEVM.mjs",
        "folderName": "simdune",
        "hasImport": false,
        "namespace": "simdune",
        "tags": [
          "production",
          "token",
          "analytics",
          "holders"
        ],
        "requiredServerParams": [
          "DUNE_SIM_API_KEY"
        ],
        "routeNames": [
          "getTokenHoldersEVM"
        ],
        "schemaFolder": "simdune",
        "schemaName": "tokenHoldersEVM",
        "fileName": "tokenHoldersEVM.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tokenHoldersEVM(), tokenHoldersEVM_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "simdune_tokenInfoEVM",
        "relativePath": "schemas/v1.2.0/simdune/tokenInfoEVM.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/simdune/tokenInfoEVM.mjs",
        "internalImport": "./../../schemas/v1.2.0/simdune/tokenInfoEVM.mjs",
        "folderName": "simdune",
        "hasImport": false,
        "namespace": "simdune",
        "tags": [
          "production",
          "token",
          "analytics",
          "metadata"
        ],
        "requiredServerParams": [
          "DUNE_SIM_API_KEY"
        ],
        "routeNames": [
          "getTokenInfoEVM"
        ],
        "schemaFolder": "simdune",
        "schemaName": "tokenInfoEVM",
        "fileName": "tokenInfoEVM.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tokenInfoEVM(), tokenInfoEVM_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "simdune_transactionsEVM",
        "relativePath": "schemas/v1.2.0/simdune/transactionsEVM.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/simdune/transactionsEVM.mjs",
        "internalImport": "./../../schemas/v1.2.0/simdune/transactionsEVM.mjs",
        "folderName": "simdune",
        "hasImport": false,
        "namespace": "simdune",
        "tags": [
          "production",
          "transactions",
          "analytics",
          "history"
        ],
        "requiredServerParams": [
          "DUNE_SIM_API_KEY"
        ],
        "routeNames": [
          "getTransactionsEVM"
        ],
        "schemaFolder": "simdune",
        "schemaName": "transactionsEVM",
        "fileName": "transactionsEVM.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_transactionsEVM(), transactionsEVM_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "simdune_transactionsSVM",
        "relativePath": "schemas/v1.2.0/simdune/transactionsSVM.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/simdune/transactionsSVM.mjs",
        "internalImport": "./../../schemas/v1.2.0/simdune/transactionsSVM.mjs",
        "folderName": "simdune",
        "hasImport": false,
        "namespace": "simdune",
        "tags": [
          "production",
          "transactions",
          "analytics",
          "history",
          "svm",
          "solana"
        ],
        "requiredServerParams": [
          "DUNE_SIM_API_KEY"
        ],
        "routeNames": [
          "getTransactionsSVM"
        ],
        "schemaFolder": "simdune",
        "schemaName": "transactionsSVM",
        "fileName": "transactionsSVM.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_transactionsSVM(), transactionsSVM_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "snapshot_snapshot",
        "relativePath": "schemas/v1.2.0/snapshot/snapshot.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/snapshot/snapshot.mjs",
        "internalImport": "./../../schemas/v1.2.0/snapshot/snapshot.mjs",
        "folderName": "snapshot",
        "hasImport": false,
        "namespace": "snapshot",
        "tags": [
          "dao",
          "governance",
          "voting"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "listSpaces",
          "listProposals",
          "getProposalDetails"
        ],
        "schemaFolder": "snapshot",
        "schemaName": "snapshot",
        "fileName": "snapshot.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_snapshot(), snapshot_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--additionalRoutes",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--additionalRoutes.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--additionalRoutes.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--additionalRoutes.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "tokenStats",
          "tokenStatsByPool"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--additionalRoutes",
        "fileName": "--additionalRoutes.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_additionalRoutes(), additionalRoutes_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--chartRoutes",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--chartRoutes.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--chartRoutes.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--chartRoutes.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "chartData",
          "chartDataByPool"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--chartRoutes",
        "fileName": "--chartRoutes.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_chartRoutes(), chartRoutes_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--pnlRoutes",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--pnlRoutes.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--pnlRoutes.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--pnlRoutes.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "profitAndLossData",
          "pnlForSpecificToken",
          "firstBuyers"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--pnlRoutes",
        "fileName": "--pnlRoutes.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_pnlRoutes(), pnlRoutes_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--priceEndpoints",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--priceEndpoints.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--priceEndpoints.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--priceEndpoints.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "priceInformation",
          "postPrice",
          "multiPriceInformation",
          "getHistoricPrice",
          "getPriceAtTimestamp",
          "getPriceRange",
          "postMultiPrice"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--priceEndpoints",
        "fileName": "--priceEndpoints.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_priceEndpoints(), priceEndpoints_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--tokenEndpoints",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--tokenEndpoints.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--tokenEndpoints.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--tokenEndpoints.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "tokenInformation",
          "tokenHolders",
          "topTokenHolders",
          "allTimeHighPrice",
          "tokensByDeployer",
          "search",
          "latestTokens",
          "multipleTokens",
          "trendingTokens",
          "tokensByVolume",
          "tokenOverview",
          "graduatedTokens",
          "tokenByPool",
          "trendingTokensByTimeframe",
          "tokensByVolumeTimeframe"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--tokenEndpoints",
        "fileName": "--tokenEndpoints.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tokenEndpoints(), tokenEndpoints_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--topTraderRoutes",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--topTraderRoutes.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--topTraderRoutes.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--topTraderRoutes.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "topTradersAll",
          "topTradersAllPaged",
          "topTradersByToken"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--topTraderRoutes",
        "fileName": "--topTraderRoutes.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_topTraderRoutes(), topTraderRoutes_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--tradeEndpoints",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--tradeEndpoints.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--tradeEndpoints.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--tradeEndpoints.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "tokenTrades",
          "tradesByWallet",
          "tokenPoolTrades",
          "userPoolTrades"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--tradeEndpoints",
        "fileName": "--tradeEndpoints.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_tradeEndpoints(), tradeEndpoints_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solanatracker_--walletEndpoints",
        "relativePath": "schemas/v1.2.0/solanatracker-io/--walletEndpoints.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solanatracker-io/--walletEndpoints.mjs",
        "internalImport": "./../../schemas/v1.2.0/solanatracker-io/--walletEndpoints.mjs",
        "folderName": "solanatracker-io",
        "hasImport": false,
        "namespace": "solanatracker",
        "tags": [],
        "requiredServerParams": [
          "SOLANA_TRACKER_API_KEY"
        ],
        "routeNames": [
          "walletInformation",
          "walletTokensBasic",
          "walletTokensPaged",
          "walletTrades"
        ],
        "schemaFolder": "solanatracker-io",
        "schemaName": "--walletEndpoints",
        "fileName": "--walletEndpoints.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_walletEndpoints(), walletEndpoints_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solscan_getChainInfo",
        "relativePath": "schemas/v1.2.0/solscan-io/getChainInfo.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solscan-io/getChainInfo.mjs",
        "internalImport": "./../../schemas/v1.2.0/solscan-io/getChainInfo.mjs",
        "folderName": "solscan-io",
        "hasImport": false,
        "namespace": "solscan",
        "tags": [],
        "requiredServerParams": [
          "SOLSCAN_API_KEY"
        ],
        "routeNames": [
          "chainInfo"
        ],
        "schemaFolder": "solscan-io",
        "schemaName": "getChainInfo",
        "fileName": "getChainInfo.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getChainInfo(), getChainInfo_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "solsniffer_analysis",
        "relativePath": "schemas/v1.2.0/solsniffer-com/analysis.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/solsniffer-com/analysis.mjs",
        "internalImport": "./../../schemas/v1.2.0/solsniffer-com/analysis.mjs",
        "folderName": "solsniffer-com",
        "hasImport": false,
        "namespace": "solsniffer",
        "tags": [],
        "requiredServerParams": [
          "SOLSNIFFER_API_KEY"
        ],
        "routeNames": [
          "analysisToken"
        ],
        "schemaFolder": "solsniffer-com",
        "schemaName": "analysis",
        "fileName": "analysis.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_analysis(), analysis_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "spaceid_spaceid",
        "relativePath": "schemas/v1.2.0/spaceid/spaceid.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/spaceid/spaceid.mjs",
        "internalImport": "./../../schemas/v1.2.0/spaceid/spaceid.mjs",
        "folderName": "spaceid",
        "hasImport": false,
        "namespace": "spaceid",
        "tags": [
          "production",
          "domain",
          "identity",
          "blockchain"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getSupportedChains",
          "getAddress",
          "getName"
        ],
        "schemaFolder": "spaceid",
        "schemaName": "spaceid",
        "fileName": "spaceid.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_spaceid(), spaceid_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "stolpersteineBerl_memorial-stones",
        "relativePath": "schemas/v1.2.0/stolpersteine-berlin/memorial-stones.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/stolpersteine-berlin/memorial-stones.mjs",
        "internalImport": "./../../schemas/v1.2.0/stolpersteine-berlin/memorial-stones.mjs",
        "folderName": "stolpersteine-berlin",
        "hasImport": false,
        "namespace": "stolpersteineBerl",
        "tags": [
          "memorial",
          "history",
          "berlin"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getAllStones",
          "searchStones",
          "getStonesByDistrict",
          "getStonesByPerson",
          "getStonesByLocation"
        ],
        "schemaFolder": "stolpersteine-berlin",
        "schemaName": "memorial-stones",
        "fileName": "memorial-stones.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_memorial_stones(), memorial_stones_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "swaggerhub_api-registry",
        "relativePath": "schemas/v1.2.0/swaggerhub-com/api-registry.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/swaggerhub-com/api-registry.mjs",
        "internalImport": "./../../schemas/v1.2.0/swaggerhub-com/api-registry.mjs",
        "folderName": "swaggerhub-com",
        "hasImport": false,
        "namespace": "swaggerhub",
        "tags": [
          "production",
          "api",
          "documentation",
          "registry"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "searchApis",
          "listApiVersions"
        ],
        "schemaFolder": "swaggerhub-com",
        "schemaName": "api-registry",
        "fileName": "api-registry.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_api_registry(), api_registry_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "thegraph_getNewUniswapPools",
        "relativePath": "schemas/v1.2.0/thegraph/getNewUniswapPools.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/thegraph/getNewUniswapPools.mjs",
        "internalImport": "./../../schemas/v1.2.0/thegraph/getNewUniswapPools.mjs",
        "folderName": "thegraph",
        "hasImport": false,
        "namespace": "thegraph",
        "tags": [],
        "requiredServerParams": [
          "THEGRAPH_API_KEY"
        ],
        "routeNames": [
          "getNewPools"
        ],
        "schemaFolder": "thegraph",
        "schemaName": "getNewUniswapPools",
        "fileName": "getNewUniswapPools.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getNewUniswapPools(), getNewUniswapPools_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "thegraph_getSchema",
        "relativePath": "schemas/v1.2.0/thegraph/getSchema.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/thegraph/getSchema.mjs",
        "internalImport": "./../../schemas/v1.2.0/thegraph/getSchema.mjs",
        "folderName": "thegraph",
        "hasImport": false,
        "namespace": "thegraph",
        "tags": [],
        "requiredServerParams": [
          "THEGRAPH_API_KEY"
        ],
        "routeNames": [
          "getSubgraphSchema",
          "querySubgraph"
        ],
        "schemaFolder": "thegraph",
        "schemaName": "getSchema",
        "fileName": "getSchema.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_getSchema(), getSchema_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "twitter_search",
        "relativePath": "schemas/v1.2.0/twitter/search.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/twitter/search.mjs",
        "internalImport": "./../../schemas/v1.2.0/twitter/search.mjs",
        "folderName": "twitter",
        "hasImport": false,
        "namespace": "twitter",
        "tags": [],
        "requiredServerParams": [
          "TWITTER_BEARER_TOKEN"
        ],
        "routeNames": [
          "searchRecentTweets"
        ],
        "schemaFolder": "twitter",
        "schemaName": "search",
        "fileName": "search.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_search2(), search_exports2));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "uniswap_uniswap-pool-explorer",
        "relativePath": "schemas/v1.2.0/uniswap-pools/uniswap-pool-explorer.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/uniswap-pools/uniswap-pool-explorer.mjs",
        "internalImport": "./../../schemas/v1.2.0/uniswap-pools/uniswap-pool-explorer.mjs",
        "folderName": "uniswap-pools",
        "hasImport": false,
        "namespace": "uniswap",
        "tags": [
          "production"
        ],
        "requiredServerParams": [
          "THEGRAPH_API_KEY"
        ],
        "routeNames": [
          "getTokenPools",
          "getPoolData"
        ],
        "schemaFolder": "uniswap-pools",
        "schemaName": "uniswap-pool-explorer",
        "fileName": "uniswap-pool-explorer.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_uniswap_pool_explorer(), uniswap_pool_explorer_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "webcareer_job-listings",
        "relativePath": "schemas/v1.2.0/web3-career/job-listings.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/web3-career/job-listings.mjs",
        "internalImport": "./../../schemas/v1.2.0/web3-career/job-listings.mjs",
        "folderName": "web3-career",
        "hasImport": false,
        "namespace": "webcareer",
        "tags": [
          "production",
          "jobs",
          "career",
          "crypto"
        ],
        "requiredServerParams": [
          "WEB3_CAREER_API_TOKEN"
        ],
        "routeNames": [
          "queryJobs"
        ],
        "schemaFolder": "web3-career",
        "schemaName": "job-listings",
        "fileName": "job-listings.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_job_listings(), job_listings_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "wormholescan_wormholescan",
        "relativePath": "schemas/v1.2.0/wormholescan/wormholescan.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/wormholescan/wormholescan.mjs",
        "internalImport": "./../../schemas/v1.2.0/wormholescan/wormholescan.mjs",
        "folderName": "wormholescan",
        "hasImport": false,
        "namespace": "wormholescan",
        "tags": [
          "data",
          "api"
        ],
        "requiredServerParams": [],
        "routeNames": [
          "getCrossChainActivity",
          "getMoneyFlow",
          "getTopAssetsByVolume",
          "getTopChainPairsByNumTransfers",
          "getTopSymbolsByVolume",
          "getTopCorridors",
          "getKpiList"
        ],
        "schemaFolder": "wormholescan",
        "schemaName": "wormholescan",
        "fileName": "wormholescan.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_wormholescan(), wormholescan_exports));
          return { schema: schema115 };
        }, "loadSchema")
      },
      {
        "id": "x402_ping",
        "relativePath": "schemas/v1.2.0/x402/ping.mjs",
        "modulImportPath": "schemaimporter/schemas/v1.2.0/x402/ping.mjs",
        "internalImport": "./../../schemas/v1.2.0/x402/ping.mjs",
        "folderName": "x402",
        "hasImport": false,
        "namespace": "x402",
        "tags": [],
        "requiredServerParams": [],
        "routeNames": [
          "free_ping",
          "paid_ping"
        ],
        "schemaFolder": "x402",
        "schemaName": "ping",
        "fileName": "ping.mjs",
        "loadSchema": /* @__PURE__ */ __name(async () => {
          const { schema: schema115 } = await Promise.resolve().then(() => (init_ping(), ping_exports));
          return { schema: schema115 };
        }, "loadSchema")
      }
    ];
  }
});

// src/index.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/agents/dist/mcp/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/agents/dist/chunk-YDUDMOL6.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/agents/dist/chunk-MH46VMM4.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/ai/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@ai-sdk/provider/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  static {
    __name(this, "_AISDKError");
  }
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name143,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name143;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error42) {
    return _AISDKError2.hasMarker(error42, marker);
  }
  static hasMarker(error42, marker153) {
    const markerSymbol = Symbol.for(marker153);
    return error42 != null && typeof error42 === "object" && markerSymbol in error42 && typeof error42[markerSymbol] === "boolean" && error42[markerSymbol] === true;
  }
};
_a = symbol;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
_a2 = symbol2;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
_a3 = symbol3;
function getErrorMessage(error42) {
  if (error42 == null) {
    return "unknown error";
  }
  if (typeof error42 === "string") {
    return error42;
  }
  if (error42 instanceof Error) {
    return error42.message;
  }
  return JSON.stringify(error42);
}
__name(getErrorMessage, "getErrorMessage");
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  static {
    __name(this, "InvalidArgumentError");
  }
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error42) {
    return AISDKError.hasMarker(error42, marker4);
  }
};
_a4 = symbol4;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
_a6 = symbol6;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  static {
    __name(this, "JSONParseError");
  }
  constructor({ text: text2, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text2;
  }
  static isInstance(error42) {
    return AISDKError.hasMarker(error42, marker7);
  }
};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
_a8 = symbol8;
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
_a9 = symbol9;
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
_a10 = symbol10;
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
_a11 = symbol11;
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
_a12 = symbol12;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  static {
    __name(this, "_TypeValidationError");
  }
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error42) {
    return AISDKError.hasMarker(error42, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
_a14 = symbol14;

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/eventsource-parser/dist/stream.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/eventsource-parser/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ParseError = class extends Error {
  static {
    __name(this, "ParseError");
  }
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
__name(noop, "noop");
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  __name(feed, "feed");
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  __name(parseLine, "parseLine");
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  __name(processField, "processField");
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  __name(dispatchEvent, "dispatchEvent");
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  __name(reset, "reset");
  return { feed, reset };
}
__name(createParser, "createParser");
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
__name(splitLines, "splitLines");

// node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  static {
    __name(this, "EventSourceParserStream");
  }
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: /* @__PURE__ */ __name((event) => {
            controller.enqueue(event);
          }, "onEvent"),
          onError(error42) {
            onError === "terminate" ? controller.error(error42) : typeof onError == "function" && onError(error42);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// node_modules/zod/v4/classic/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint3,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  coerce: () => coerce_exports,
  config: () => config2,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol15,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config2,
  flattenError: () => flattenError,
  formatError: () => formatError,
  function: () => _function,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/core.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name17, initializer3, params) {
  function init(inst, def) {
    var _a18;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a18 = inst._zod).traits ?? (_a18.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name17);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  __name(init, "init");
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
    static {
      __name(this, "Definition");
    }
  }
  Object.defineProperty(Definition, "name", { value: name17 });
  function _(def) {
    var _a18;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a18 = inst._zod).deferred ?? (_a18.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  __name(_, "_");
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: /* @__PURE__ */ __name((inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name17);
    }, "value")
  });
  Object.defineProperty(_, "name", { value: name17 });
  return _;
}
__name($constructor, "$constructor");
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  static {
    __name(this, "$ZodAsyncError");
  }
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
__name(config2, "config");

// node_modules/zod/v4/core/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert3,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function assertEqual(val) {
  return val;
}
__name(assertEqual, "assertEqual");
function assertNotEqual(val) {
  return val;
}
__name(assertNotEqual, "assertNotEqual");
function assertIs(_arg) {
}
__name(assertIs, "assertIs");
function assertNever(_x) {
  throw new Error();
}
__name(assertNever, "assertNever");
function assert3(_) {
}
__name(assert3, "assert");
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
__name(getEnumValues, "getEnumValues");
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
__name(joinValues, "joinValues");
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
__name(jsonStringifyReplacer, "jsonStringifyReplacer");
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
__name(cached, "cached");
function nullish(input) {
  return input === null || input === void 0;
}
__name(nullish, "nullish");
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
__name(cleanRegex, "cleanRegex");
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
function defineLazy(object4, key, getter) {
  const set3 = false;
  Object.defineProperty(object4, key, {
    get() {
      if (!set3) {
        const value = getter();
        object4[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object4, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
__name(defineLazy, "defineLazy");
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
__name(assignProp, "assignProp");
function getElementAtPath(obj, path2) {
  if (!path2)
    return obj;
  return path2.reduce((acc, key) => acc?.[key], obj);
}
__name(getElementAtPath, "getElementAtPath");
function promiseAllObject(promisesObj) {
  const keys2 = Object.keys(promisesObj);
  const promises = keys2.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0; i2 < keys2.length; i2++) {
      resolvedObj[keys2[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
__name(promiseAllObject, "promiseAllObject");
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i2 = 0; i2 < length; i2++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
__name(randomString, "randomString");
function esc(str) {
  return JSON.stringify(str);
}
__name(esc, "esc");
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
__name(isObject, "isObject");
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && "Cloudflare-Workers"?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o2) {
  if (isObject(o2) === false)
    return false;
  const ctor = o2.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
__name(isPlainObject, "isPlainObject");
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
__name(numKeys, "numKeys");
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t2}`);
  }
}, "getParsedType");
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegex, "escapeRegex");
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
__name(clone, "clone");
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: /* @__PURE__ */ __name(() => params, "error") };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: /* @__PURE__ */ __name(() => params.error, "error") };
  return params;
}
__name(normalizeParams, "normalizeParams");
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
__name(createTransparentProxy, "createTransparentProxy");
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
__name(stringifyPrimitive, "stringifyPrimitive");
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
__name(optionalKeys, "optionalKeys");
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema115, mask) {
  const newShape = {};
  const currDef = schema115._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema115, {
    ...schema115._zod.def,
    shape: newShape,
    checks: []
  });
}
__name(pick, "pick");
function omit(schema115, mask) {
  const newShape = { ...schema115._zod.def.shape };
  const currDef = schema115._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema115, {
    ...schema115._zod.def,
    shape: newShape,
    checks: []
  });
}
__name(omit, "omit");
function extend(schema115, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema115._zod.def,
    get shape() {
      const _shape = { ...schema115._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema115, def);
}
__name(extend, "extend");
function merge(a2, b) {
  return clone(a2, {
    ...a2._zod.def,
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
__name(merge, "merge");
function partial(Class2, schema115, mask) {
  const oldShape = schema115._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema115, {
    ...schema115._zod.def,
    shape,
    checks: []
  });
}
__name(partial, "partial");
function required(Class2, schema115, mask) {
  const oldShape = schema115._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema115, {
    ...schema115._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
__name(required, "required");
function aborted(x, startIndex = 0) {
  for (let i2 = startIndex; i2 < x.issues.length; i2++) {
    if (x.issues[i2]?.continue !== true)
      return true;
  }
  return false;
}
__name(aborted, "aborted");
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a18;
    (_a18 = iss).path ?? (_a18.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
__name(prefixIssues, "prefixIssues");
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
__name(unwrapMessage, "unwrapMessage");
function finalizeIssue(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config3.customError?.(iss)) ?? unwrapMessage(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
__name(finalizeIssue, "finalizeIssue");
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
__name(getSizableOrigin, "getSizableOrigin");
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
__name(getLengthableOrigin, "getLengthableOrigin");
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
__name(issue, "issue");
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
__name(cleanEnum, "cleanEnum");
var Class = class {
  static {
    __name(this, "Class");
  }
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = /* @__PURE__ */ __name((inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: /* @__PURE__ */ __name(() => inst.message, "value"),
    enumerable: false
  });
}, "initializer");
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error42, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error42.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
__name(flattenError, "flattenError");
function formatError(error42, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = /* @__PURE__ */ __name((error43) => {
    for (const issue2 of error43.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  }, "processError");
  processError(error42);
  return fieldErrors;
}
__name(formatError, "formatError");
function treeifyError(error42, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = /* @__PURE__ */ __name((error43, path2 = []) => {
    var _a18, _b;
    for (const issue2 of error43.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path2, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i2 = 0;
        while (i2 < fullpath.length) {
          const el = fullpath[i2];
          const terminal = i2 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a18 = curr.properties)[el] ?? (_a18[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i2++;
        }
      }
    }
  }, "processError");
  processError(error42);
  return result;
}
__name(treeifyError, "treeifyError");
function toDotPath(path2) {
  const segs = [];
  for (const seg of path2) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
__name(toDotPath, "toDotPath");
function prettifyError(error42) {
  const lines = [];
  const issues = [...error42.issues].sort((a2, b) => a2.path.length - b.path.length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
__name(prettifyError, "prettifyError");

// node_modules/zod/v4/core/parse.js
var _parse = /* @__PURE__ */ __name((_Err) => (schema115, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema115._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
}, "_parse");
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = /* @__PURE__ */ __name((_Err) => async (schema115, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema115._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
}, "_parseAsync");
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = /* @__PURE__ */ __name((_Err) => (schema115, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema115._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, "_safeParse");
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = /* @__PURE__ */ __name((_Err) => async (schema115, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema115._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, "_safeParseAsync");
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);

// node_modules/zod/v4/core/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/checks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  _emoji: () => _emoji,
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint2,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain2,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hostname: () => hostname,
  html5Email: () => html5Email,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  string: () => string,
  time: () => time3,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = /* @__PURE__ */ __name((version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, "uuid");
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
__name(emoji, "emoji");
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
__name(timeSource, "timeSource");
function time3(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
__name(time3, "time");
function datetime(args) {
  const time5 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex2 = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
__name(datetime, "datetime");
var string = /* @__PURE__ */ __name((params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, "string");
var bigint2 = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a18;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a18 = inst._zod).onattach ?? (_a18.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a18;
    (_a18 = inst2._zod.bag).multipleOf ?? (_a18.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a18;
  $ZodCheck.init(inst, def);
  (_a18 = inst._zod.def).when ?? (_a18.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a18;
  $ZodCheck.init(inst, def);
  (_a18 = inst._zod.def).when ?? (_a18.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a18;
  $ZodCheck.init(inst, def);
  (_a18 = inst._zod.def).when ?? (_a18.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a18;
  $ZodCheck.init(inst, def);
  (_a18 = inst._zod.def).when ?? (_a18.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a18;
  $ZodCheck.init(inst, def);
  (_a18 = inst._zod.def).when ?? (_a18.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a18;
  $ZodCheck.init(inst, def);
  (_a18 = inst._zod.def).when ?? (_a18.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a18, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a18 = inst._zod).check ?? (_a18.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
__name(handleCheckPropertyResult, "handleCheckPropertyResult");
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Doc = class {
  static {
    __name(this, "Doc");
  }
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version2 = {
  major: 4,
  minor: 0,
  patch: 0
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a18;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a18 = inst._zod).deferred ?? (_a18.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = /* @__PURE__ */ __name((payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    }, "runChecks");
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: /* @__PURE__ */ __name((value) => {
      try {
        const r2 = safeParse(inst, value);
        return r2.success ? { value: r2.data } : { issues: r2.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r2) => r2.success ? { value: r2.data } : { issues: r2.error?.issues });
      }
    }, "validate"),
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url2 = new URL(orig);
      const href = url2.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
__name(isValidBase64, "isValidBase64");
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
__name(isValidBase64URL, "isValidBase64URL");
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleArrayResult, "handleArrayResult");
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
__name(handleObjectResult, "handleObjectResult");
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
__name(handleOptionalObjectResult, "handleOptionalObjectResult");
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys2 = Object.keys(def.shape);
    for (const k of keys2) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys: keys2,
      keySet: new Set(keys2),
      numKeys: keys2.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = /* @__PURE__ */ __name((shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = /* @__PURE__ */ __name((key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    }, "parseStr");
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, "generateFastpass");
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r2 = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r2 instanceof Promise) {
          proms.push(r2.then((r3) => isOptional ? handleOptionalObjectResult(r3, payload, key, input) : handleObjectResult(r3, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r2, payload, key, input);
        } else {
          handleObjectResult(r2, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t2 = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t2 === "never") {
        unrecognized.push(key);
        continue;
      }
      const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r2 instanceof Promise) {
        proms.push(r2.then((r3) => handleObjectResult(r3, payload, key)));
      } else {
        handleObjectResult(r2, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  });
  return final;
}
__name(handleUnionResults, "handleUnionResults");
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o2 of opts) {
      const values = o2._zod.propValues[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o2)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o2);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a2, b) {
  if (a2 === b) {
    return { valid: true, data: a2 };
  }
  if (a2 instanceof Date && b instanceof Date && +a2 === +b) {
    return { valid: true, data: a2 };
  }
  if (isPlainObject(a2) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b)) {
    if (a2.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
__name(mergeValues, "mergeValues");
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
__name(handleIntersectionResults, "handleIntersectionResults");
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i2 = -1;
    for (const item of items) {
      i2++;
      if (i2 >= input.length) {
        if (i2 >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i2],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
      } else {
        handleTupleResult(result, payload, i2);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i2++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
        } else {
          handleTupleResult(result, payload, i2);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleTupleResult, "handleTupleResult");
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
__name(handleMapResult, "handleMapResult");
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
__name(handleSetResult, "handleSetResult");
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2 ? o2.toString() : String(o2)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
__name(handleDefaultResult, "handleDefaultResult");
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
__name(handleNonOptionalResult, "handleNonOptionalResult");
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
__name(handlePipeResult, "handlePipeResult");
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
__name(handleReadonlyResult, "handleReadonlyResult");
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r2 = def.fn(input);
    if (r2 instanceof Promise) {
      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));
    }
    handleRefineResult(r2, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
__name(handleRefineResult, "handleRefineResult");

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  it: () => it_default,
  ja: () => ja_default,
  kh: () => kh_default,
  ko: () => ko_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  ur: () => ur_default,
  vi: () => vi_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/locales/ar.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error3 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
}, "error");
function ar_default() {
  return {
    localeError: error3()
  };
}
__name(ar_default, "default");

// node_modules/zod/v4/locales/az.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error4 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
}, "error");
function az_default() {
  return {
    localeError: error4()
  };
}
__name(az_default, "default");

// node_modules/zod/v4/locales/be.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getBelarusianPlural(count3, one, few, many) {
  const absCount = Math.abs(count3);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getBelarusianPlural, "getBelarusianPlural");
var error5 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
}, "error");
function be_default() {
  return {
    localeError: error5()
  };
}
__name(be_default, "default");

// node_modules/zod/v4/locales/ca.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error6 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType4(issue2.input)}`;
      // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
}, "error");
function ca_default() {
  return {
    localeError: error6()
  };
}
__name(ca_default, "default");

// node_modules/zod/v4/locales/cs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error7 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
}, "error");
function cs_default() {
  return {
    localeError: error7()
  };
}
__name(cs_default, "default");

// node_modules/zod/v4/locales/de.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error8 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
}, "error");
function de_default() {
  return {
    localeError: error8()
  };
}
__name(de_default, "default");

// node_modules/zod/v4/locales/en.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
}, "parsedType");
var error9 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
}, "error");
function en_default() {
  return {
    localeError: error9()
  };
}
__name(en_default, "default");

// node_modules/zod/v4/locales/eo.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType2 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
}, "parsedType");
var error10 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
}, "error");
function eo_default() {
  return {
    localeError: error10()
  };
}
__name(eo_default, "default");

// node_modules/zod/v4/locales/es.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error11 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${issue2.expected}, recibido ${parsedType4(issue2.input)}`;
      // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
}, "error");
function es_default() {
  return {
    localeError: error11()
  };
}
__name(es_default, "default");

// node_modules/zod/v4/locales/fa.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error12 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType4(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
}, "error");
function fa_default() {
  return {
    localeError: error12()
  };
}
__name(fa_default, "default");

// node_modules/zod/v4/locales/fi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error13 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
}, "error");
function fi_default() {
  return {
    localeError: error13()
  };
}
__name(fi_default, "default");

// node_modules/zod/v4/locales/fr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error14 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_default() {
  return {
    localeError: error14()
  };
}
__name(fr_default, "default");

// node_modules/zod/v4/locales/fr-CA.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error15 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
__name(fr_CA_default, "default");

// node_modules/zod/v4/locales/he.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error16 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType4(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
}, "error");
function he_default() {
  return {
    localeError: error16()
  };
}
__name(he_default, "default");

// node_modules/zod/v4/locales/hu.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error17 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType4(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
}, "error");
function hu_default() {
  return {
    localeError: error17()
  };
}
__name(hu_default, "default");

// node_modules/zod/v4/locales/id.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error18 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
}, "error");
function id_default() {
  return {
    localeError: error18()
  };
}
__name(id_default, "default");

// node_modules/zod/v4/locales/it.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error19 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
}, "error");
function it_default() {
  return {
    localeError: error19()
  };
}
__name(it_default, "default");

// node_modules/zod/v4/locales/ja.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error20 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType4(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
}, "error");
function ja_default() {
  return {
    localeError: error20()
  };
}
__name(ja_default, "default");

// node_modules/zod/v4/locales/kh.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error21 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
}, "error");
function kh_default() {
  return {
    localeError: error21()
  };
}
__name(kh_default, "default");

// node_modules/zod/v4/locales/ko.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error22 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType4(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
}, "error");
function ko_default() {
  return {
    localeError: error22()
  };
}
__name(ko_default, "default");

// node_modules/zod/v4/locales/mk.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error23 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType4(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
}, "error");
function mk_default() {
  return {
    localeError: error23()
  };
}
__name(mk_default, "default");

// node_modules/zod/v4/locales/ms.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error24 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
}, "error");
function ms_default() {
  return {
    localeError: error24()
  };
}
__name(ms_default, "default");

// node_modules/zod/v4/locales/nl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error25 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
}, "error");
function nl_default() {
  return {
    localeError: error25()
  };
}
__name(nl_default, "default");

// node_modules/zod/v4/locales/no.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error26 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
}, "error");
function no_default() {
  return {
    localeError: error26()
  };
}
__name(no_default, "default");

// node_modules/zod/v4/locales/ota.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error27 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType4(issue2.input)}`;
      // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
}, "error");
function ota_default() {
  return {
    localeError: error27()
  };
}
__name(ota_default, "default");

// node_modules/zod/v4/locales/ps.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error28 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType4(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
}, "error");
function ps_default() {
  return {
    localeError: error28()
  };
}
__name(ps_default, "default");

// node_modules/zod/v4/locales/pl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error29 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
}, "error");
function pl_default() {
  return {
    localeError: error29()
  };
}
__name(pl_default, "default");

// node_modules/zod/v4/locales/pt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error30 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
}, "error");
function pt_default() {
  return {
    localeError: error30()
  };
}
__name(pt_default, "default");

// node_modules/zod/v4/locales/ru.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getRussianPlural(count3, one, few, many) {
  const absCount = Math.abs(count3);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getRussianPlural, "getRussianPlural");
var error31 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
}, "error");
function ru_default() {
  return {
    localeError: error31()
  };
}
__name(ru_default, "default");

// node_modules/zod/v4/locales/sl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error32 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
}, "error");
function sl_default() {
  return {
    localeError: error32()
  };
}
__name(sl_default, "default");

// node_modules/zod/v4/locales/sv.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error33 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
}, "error");
function sv_default() {
  return {
    localeError: error33()
  };
}
__name(sv_default, "default");

// node_modules/zod/v4/locales/ta.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error34 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
}, "error");
function ta_default() {
  return {
    localeError: error34()
  };
}
__name(ta_default, "default");

// node_modules/zod/v4/locales/th.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error35 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
}, "error");
function th_default() {
  return {
    localeError: error35()
  };
}
__name(th_default, "default");

// node_modules/zod/v4/locales/tr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType3 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
}, "parsedType");
var error36 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
}, "error");
function tr_default() {
  return {
    localeError: error36()
  };
}
__name(tr_default, "default");

// node_modules/zod/v4/locales/ua.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error37 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType4(issue2.input)}`;
      // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
}, "error");
function ua_default() {
  return {
    localeError: error37()
  };
}
__name(ua_default, "default");

// node_modules/zod/v4/locales/ur.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error38 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType4(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
}, "error");
function ur_default() {
  return {
    localeError: error38()
  };
}
__name(ur_default, "default");

// node_modules/zod/v4/locales/vi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error39 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
}, "error");
function vi_default() {
  return {
    localeError: error39()
  };
}
__name(vi_default, "default");

// node_modules/zod/v4/locales/zh-CN.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error40 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
}, "error");
function zh_CN_default() {
  return {
    localeError: error40()
  };
}
__name(zh_CN_default, "default");

// node_modules/zod/v4/locales/zh-TW.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error41 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType4 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
}, "error");
function zh_TW_default() {
  return {
    localeError: error41()
  };
}
__name(zh_TW_default, "default");

// node_modules/zod/v4/core/registries.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  static {
    __name(this, "$ZodRegistry");
  }
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema115, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema115, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema115);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema115) {
    const meta = this._map.get(schema115);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema115);
    return this;
  }
  get(schema115) {
    const p = schema115._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema115) };
    }
    return this._map.get(schema115);
  }
  has(schema115) {
    return this._map.has(schema115);
  }
};
function registry() {
  return new $ZodRegistry();
}
__name(registry, "registry");
var globalRegistry = /* @__PURE__ */ registry();

// node_modules/zod/v4/core/function.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/api.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
__name(_string, "_string");
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedString, "_coercedString");
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_email, "_email");
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_guid, "_guid");
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_uuid, "_uuid");
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
__name(_uuidv4, "_uuidv4");
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
__name(_uuidv6, "_uuidv6");
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
__name(_uuidv7, "_uuidv7");
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_url, "_url");
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_emoji2, "_emoji");
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_nanoid, "_nanoid");
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid, "_cuid");
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid2, "_cuid2");
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ulid, "_ulid");
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_xid, "_xid");
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ksuid, "_ksuid");
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv4, "_ipv4");
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv6, "_ipv6");
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv4, "_cidrv4");
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv6, "_cidrv6");
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64, "_base64");
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64url, "_base64url");
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_e164, "_e164");
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_jwt, "_jwt");
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoDateTime, "_isoDateTime");
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDate, "_isoDate");
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoTime, "_isoTime");
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDuration, "_isoDuration");
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_number, "_number");
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_coercedNumber, "_coercedNumber");
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
__name(_int, "_int");
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
__name(_float32, "_float32");
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
__name(_float64, "_float64");
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
__name(_int32, "_int32");
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
__name(_uint32, "_uint32");
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
__name(_boolean, "_boolean");
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBoolean, "_coercedBoolean");
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
__name(_bigint, "_bigint");
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBigint, "_coercedBigint");
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
__name(_int64, "_int64");
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
__name(_uint64, "_uint64");
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
__name(_symbol, "_symbol");
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
__name(_undefined2, "_undefined");
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
__name(_null2, "_null");
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
__name(_any, "_any");
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
__name(_unknown, "_unknown");
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
__name(_never, "_never");
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
__name(_void, "_void");
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
__name(_date, "_date");
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedDate, "_coercedDate");
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
__name(_nan, "_nan");
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
__name(_lt, "_lt");
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
__name(_lte, "_lte");
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
__name(_gt, "_gt");
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
__name(_gte, "_gte");
function _positive(params) {
  return _gt(0, params);
}
__name(_positive, "_positive");
function _negative(params) {
  return _lt(0, params);
}
__name(_negative, "_negative");
function _nonpositive(params) {
  return _lte(0, params);
}
__name(_nonpositive, "_nonpositive");
function _nonnegative(params) {
  return _gte(0, params);
}
__name(_nonnegative, "_nonnegative");
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
__name(_multipleOf, "_multipleOf");
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
__name(_maxSize, "_maxSize");
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minSize, "_minSize");
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
__name(_size, "_size");
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
__name(_maxLength, "_maxLength");
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minLength, "_minLength");
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
__name(_length, "_length");
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
__name(_regex, "_regex");
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
__name(_lowercase, "_lowercase");
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
__name(_uppercase, "_uppercase");
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
__name(_includes, "_includes");
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
__name(_startsWith, "_startsWith");
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
__name(_endsWith, "_endsWith");
function _property(property, schema115, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema: schema115,
    ...normalizeParams(params)
  });
}
__name(_property, "_property");
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
__name(_mime, "_mime");
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
__name(_overwrite, "_overwrite");
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
__name(_normalize, "_normalize");
function _trim() {
  return _overwrite((input) => input.trim());
}
__name(_trim, "_trim");
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
__name(_toLowerCase, "_toLowerCase");
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
__name(_toUpperCase, "_toUpperCase");
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
__name(_array, "_array");
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
__name(_union, "_union");
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
__name(_discriminatedUnion, "_discriminatedUnion");
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
__name(_intersection, "_intersection");
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
__name(_tuple, "_tuple");
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_record, "_record");
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_map, "_map");
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
__name(_set, "_set");
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
__name(_enum, "_enum");
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
__name(_nativeEnum, "_nativeEnum");
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
__name(_literal, "_literal");
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
__name(_file, "_file");
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
__name(_transform, "_transform");
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
__name(_optional, "_optional");
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
__name(_nullable, "_nullable");
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
__name(_default, "_default");
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
__name(_nonoptional, "_nonoptional");
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
__name(_success, "_success");
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch, "_catch");
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
__name(_pipe, "_pipe");
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
__name(_readonly, "_readonly");
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
__name(_templateLiteral, "_templateLiteral");
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
__name(_lazy, "_lazy");
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
__name(_promise, "_promise");
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema115 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema115;
}
__name(_custom, "_custom");
function _refine(Class2, fn, _params) {
  const schema115 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema115;
}
__name(_refine, "_refine");
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: /* @__PURE__ */ __name((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    }, "transform"),
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
__name(_stringbool, "_stringbool");
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
__name(_stringFormat, "_stringFormat");

// node_modules/zod/v4/core/function.js
var $ZodFunction = class {
  static {
    __name(this, "$ZodFunction");
  }
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = /* @__PURE__ */ __name((...args) => {
      const parsedArgs = this._def.input ? parse(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse(this._def.output, output, void 0, { callee: impl }) : output;
    }, "impl");
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = /* @__PURE__ */ __name(async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output, void 0, { callee: impl }) : output;
    }, "impl");
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output
    });
  }
};
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}
__name(_function, "_function");

// node_modules/zod/v4/core/to-json-schema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JSONSchemaGenerator = class {
  static {
    __name(this, "JSONSchemaGenerator");
  }
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema115, _params = { path: [], schemaPath: [] }) {
    var _a18;
    const def = schema115._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema115);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema115);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema115, result);
    const overrideSchema = schema115._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema115],
        path: _params.path
      };
      const parent = schema115._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema115._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema115._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number")
              json2.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json2.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema115._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            json2.anyOf = def.options.map((x, i2) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i2]
            }));
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a2 = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = /* @__PURE__ */ __name((val) => "allOf" in val && Object.keys(val).length === 1, "isSimpleIntersection");
            const allOf = [
              ...isSimpleIntersection(a2) ? a2.allOf : [a2],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixItems = def.items.map((x, i2) => this.process(x, { ...params, path: [...params.path, "prefixItems", i2] }));
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
            } else {
              json2.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json2.items = rest;
              } else {
                json2.additionalItems = rest;
              }
            }
            if (def.rest) {
              json2.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema115._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            json2.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              json2.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema115._zod.bag;
            if (minimum !== void 0)
              file2.minLength = minimum;
            if (maximum !== void 0)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema115._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema115._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema115);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema115)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a18 = result.schema).default ?? (_a18.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema115);
    return _result.schema;
  }
  emit(schema115, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0
    };
    const root = this.seen.get(schema115);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = /* @__PURE__ */ __name((entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    }, "makeURI");
    const extractToDef = /* @__PURE__ */ __name((entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema116 = seen.schema;
      for (const key in schema116) {
        delete schema116[key];
      }
      schema116.$ref = ref;
    }, "extractToDef");
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema115 === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema115 !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = /* @__PURE__ */ __name((zodSchema2, params2) => {
      const seen = this.seen.get(zodSchema2);
      const schema116 = seen.def ?? seen.schema;
      const _cached = { ...schema116 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema116.allOf = schema116.allOf ?? [];
          schema116.allOf.push(refSchema);
        } else {
          Object.assign(schema116, refSchema);
          Object.assign(schema116, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema: zodSchema2,
          jsonSchema: schema116,
          path: seen.path ?? []
        });
    }, "flattenRef");
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema115)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema115] = entry;
      gen2.process(schema115);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema115] = entry;
      schemas[key] = gen2.emit(schema115, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
__name(toJSONSchema, "toJSONSchema");
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema115 = _schema;
  const def = schema115._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
__name(isTransforming, "isTransforming");

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/checks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time4
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
__name(datetime2, "datetime");
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
__name(date2, "date");
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time4(params) {
  return _isoTime(ZodISOTime, params);
}
__name(time4, "time");
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
__name(duration2, "duration");

// node_modules/zod/v4/classic/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var initializer2 = /* @__PURE__ */ __name((inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: /* @__PURE__ */ __name((mapper) => formatError(inst, mapper), "value")
      // enumerable: false,
    },
    flatten: {
      value: /* @__PURE__ */ __name((mapper) => flattenError(inst, mapper), "value")
      // enumerable: false,
    },
    addIssue: {
      value: /* @__PURE__ */ __name((issue2) => inst.issues.push(issue2), "value")
      // enumerable: false,
    },
    addIssues: {
      value: /* @__PURE__ */ __name((issues2) => inst.issues.push(...issues2), "value")
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, "initializer");
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
__name(string2, "string");
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
__name(email2, "email");
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
__name(guid2, "guid");
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
__name(uuid2, "uuid");
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
__name(uuidv4, "uuidv4");
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
__name(uuidv6, "uuidv6");
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
__name(uuidv7, "uuidv7");
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
__name(url, "url");
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
__name(emoji2, "emoji");
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
__name(nanoid2, "nanoid");
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
__name(cuid3, "cuid");
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
__name(cuid22, "cuid2");
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
__name(ulid2, "ulid");
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
__name(xid2, "xid");
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
__name(ksuid2, "ksuid");
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
__name(ipv42, "ipv4");
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
__name(ipv62, "ipv6");
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
__name(cidrv42, "cidrv4");
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
__name(cidrv62, "cidrv6");
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
__name(base642, "base64");
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
__name(base64url2, "base64url");
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
__name(e1642, "e164");
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
__name(jwt, "jwt");
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
__name(stringFormat, "stringFormat");
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
__name(number2, "number");
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
__name(int, "int");
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
__name(float32, "float32");
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
__name(float64, "float64");
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
__name(int32, "int32");
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
__name(uint32, "uint32");
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
__name(boolean2, "boolean");
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint3(params) {
  return _bigint(ZodBigInt, params);
}
__name(bigint3, "bigint");
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
__name(int64, "int64");
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
__name(uint64, "uint64");
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol15(params) {
  return _symbol(ZodSymbol, params);
}
__name(symbol15, "symbol");
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
__name(_undefined3, "_undefined");
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
__name(_null3, "_null");
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
__name(any, "any");
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
__name(unknown, "unknown");
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
__name(never, "never");
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
__name(_void2, "_void");
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
__name(date3, "date");
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
__name(array, "array");
function keyof(schema115) {
  const shape = schema115._zod.def.shape;
  return literal(Object.keys(shape));
}
__name(keyof, "keyof");
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
__name(object, "object");
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
__name(strictObject, "strictObject");
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
__name(looseObject, "looseObject");
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
__name(union, "union");
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
__name(discriminatedUnion, "discriminatedUnion");
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
__name(intersection, "intersection");
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
__name(tuple, "tuple");
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(record, "record");
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(partialRecord, "partialRecord");
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(map, "map");
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(set, "set");
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys2 = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys2.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys2.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
__name(_enum2, "_enum");
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
__name(nativeEnum, "nativeEnum");
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
__name(literal, "literal");
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
__name(file, "file");
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
__name(transform, "transform");
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
__name(optional, "optional");
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
__name(nullable, "nullable");
function nullish2(innerType) {
  return optional(nullable(innerType));
}
__name(nullish2, "nullish");
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
__name(_default2, "_default");
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
__name(prefault, "prefault");
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
__name(nonoptional, "nonoptional");
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
__name(success, "success");
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch2, "_catch");
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
__name(nan, "nan");
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
__name(pipe, "pipe");
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
__name(readonly, "readonly");
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
__name(templateLiteral, "templateLiteral");
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
__name(lazy, "lazy");
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
__name(promise, "promise");
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
__name(check, "check");
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
__name(custom, "custom");
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
__name(refine, "refine");
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
__name(superRefine, "superRefine");
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: /* @__PURE__ */ __name((data) => data instanceof cls, "fn"),
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
__name(_instanceof, "_instanceof");
var stringbool = /* @__PURE__ */ __name((...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args), "stringbool");
function json(params) {
  const jsonSchema2 = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema2), record(string2(), jsonSchema2)]);
  });
  return jsonSchema2;
}
__name(json, "json");
function preprocess(fn, schema115) {
  return pipe(transform(fn), schema115);
}
__name(preprocess, "preprocess");

// node_modules/zod/v4/classic/compat.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config2({
    customError: map2
  });
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return config2().customError;
}
__name(getErrorMap, "getErrorMap");

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint4,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function string3(params) {
  return _coercedString(ZodString, params);
}
__name(string3, "string");
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
__name(number3, "number");
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
__name(boolean3, "boolean");
function bigint4(params) {
  return _coercedBigint(ZodBigInt, params);
}
__name(bigint4, "bigint");
function date4(params) {
  return _coercedDate(ZodDate, params);
}
__name(date4, "date");

// node_modules/zod/v4/classic/external.js
config2(en_default());

// node_modules/zod/v3/external.js
var external_exports2 = {};
__export(external_exports2, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER2,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType2,
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBigInt: () => ZodBigInt2,
  ZodBoolean: () => ZodBoolean2,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch2,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum2,
  ZodError: () => ZodError2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever2,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSchema: () => ZodType2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodSymbol: () => ZodSymbol2,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom2,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default2,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap2,
  getParsedType: () => getParsedType2,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap2,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/locales/en.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/ZodError.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/util.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var util;
(function(util3) {
  util3.assertEqual = (_) => {
  };
  function assertIs2(_arg) {
  }
  __name(assertIs2, "assertIs");
  util3.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  __name(assertNever2, "assertNever");
  util3.assertNever = assertNever2;
  util3.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util3.getValidEnumValues = (obj) => {
    const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util3.objectValues(filtered);
  };
  util3.objectValues = (obj) => {
    return util3.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object4) => {
    const keys2 = [];
    for (const key in object4) {
      if (Object.prototype.hasOwnProperty.call(object4, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util3.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues2, "joinValues");
  util3.joinValues = joinValues2;
  util3.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType2 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");

// node_modules/zod/v3/ZodError.js
var ZodIssueCode2 = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError2 = class _ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error42) => {
      for (const issue2 of error42.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue2.path.length) {
            const el = issue2.path[i2];
            const terminal = i2 === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError2.create = (issues) => {
  const error42 = new ZodError2(issues);
  return error42;
};

// node_modules/zod/v3/locales/en.js
var errorMap = /* @__PURE__ */ __name((issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode2.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode2.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode2.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode2.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode2.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode2.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode2.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode2.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode2.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode2.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode2.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode2.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue2);
  }
  return { message };
}, "errorMap");
var en_default2 = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default2;
function setErrorMap2(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap2, "setErrorMap");
function getErrorMap2() {
  return overrideErrorMap;
}
__name(getErrorMap2, "getErrorMap");

// node_modules/zod/v3/helpers/parseUtil.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap2();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default2 ? void 0 : en_default2
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// node_modules/zod/v3/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/errorUtil.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error42 = new ZodError2(ctx.common.issues);
        this._error = error42;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType2 = class {
  static {
    __name(this, "ZodType");
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType2(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode2.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
    };
  }
  optional() {
    return ZodOptional2.create(this, this._def);
  }
  nullable() {
    return ZodNullable2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray2.create(this);
  }
  promise() {
    return ZodPromise2.create(this, this._def);
  }
  or(option) {
    return ZodUnion2.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection2.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault2({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch2({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly2.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function isValidJWT2(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return false;
  try {
    const [header] = jwt2.split(".");
    if (!header)
      return false;
    const base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base643));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT2, "isValidJWT");
function isValidCidr(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidCidr, "isValidCidr");
var ZodString2 = class _ZodString2 extends ZodType2 {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "date",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex = timeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "time",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT2(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode2.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString2.create = (params) => {
  return new ZodString2({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder2, "floatSafeRemainder");
var ZodNumber2 = class _ZodNumber extends ZodType2 {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder2(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber2.create = (params) => {
  return new ZodNumber2({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt2 = class _ZodBigInt extends ZodType2 {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt2.create = (params) => {
  return new ZodBigInt2({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean2 = class extends ZodType2 {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean2.create = (params) => {
  return new ZodBoolean2({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate2 = class _ZodDate extends ZodType2 {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate2.create = (params) => {
  return new ZodDate2({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol2 = class extends ZodType2 {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol2.create = (params) => {
  return new ZodSymbol2({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined2 = class extends ZodType2 {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined2.create = (params) => {
  return new ZodUndefined2({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull2 = class extends ZodType2 {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull2.create = (params) => {
  return new ZodNull2({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny2 = class extends ZodType2 {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny2.create = (params) => {
  return new ZodAny2({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown2 = class extends ZodType2 {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown2.create = (params) => {
  return new ZodUnknown2({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever2 = class extends ZodType2 {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever2.create = (params) => {
  return new ZodNever2({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid2 = class extends ZodType2 {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid2.create = (params) => {
  return new ZodVoid2({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray2 = class _ZodArray extends ZodType2 {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray2.create = (schema115, params) => {
  return new ZodArray2({
    type: schema115,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema115) {
  if (schema115 instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema115.shape) {
      const fieldSchema = schema115.shape[key];
      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2({
      ...schema115._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema115 instanceof ZodArray2) {
    return new ZodArray2({
      ...schema115._def,
      type: deepPartialify(schema115.element)
    });
  } else if (schema115 instanceof ZodOptional2) {
    return ZodOptional2.create(deepPartialify(schema115.unwrap()));
  } else if (schema115 instanceof ZodNullable2) {
    return ZodNullable2.create(deepPartialify(schema115.unwrap()));
  } else if (schema115 instanceof ZodTuple2) {
    return ZodTuple2.create(schema115.items.map((item) => deepPartialify(item)));
  } else {
    return schema115;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject2 = class _ZodObject extends ZodType2 {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    this._cached = { shape, keys: keys2 };
    return this._cached;
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever2) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue2, ctx) => {
          const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema115) {
    return this.augment({ [key]: schema115 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional2) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject2.create = (shape, params) => {
  return new ZodObject2({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject2.strictCreate = (shape, params) => {
  return new ZodObject2({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject2.lazycreate = (shape, params) => {
  return new ZodObject2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion2 = class extends ZodType2 {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError2(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion2.create = (types, params) => {
  return new ZodUnion2({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy2) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral2) {
    return [type.value];
  } else if (type instanceof ZodEnum2) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault2) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined2) {
    return [void 0];
  } else if (type instanceof ZodNull2) {
    return [null];
  } else if (type instanceof ZodOptional2) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable2) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly2) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch2) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion2 = class _ZodDiscriminatedUnion extends ZodType2 {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues2(a2, b) {
  const aType = getParsedType2(a2);
  const bType = getParsedType2(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a2[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
__name(mergeValues2, "mergeValues");
var ZodIntersection2 = class extends ZodType2 {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues2(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection2.create = (left, right, params) => {
  return new ZodIntersection2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple2 = class _ZodTuple extends ZodType2 {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema115 = this._def.items[itemIndex] || this._def.rest;
      if (!schema115)
        return null;
      return schema115._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple2.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple2({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord2 = class _ZodRecord extends ZodType2 {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType2) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString2.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap2 = class extends ZodType2 {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap2.create = (keyType, valueType, params) => {
  return new ZodMap2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet2 = class _ZodSet extends ZodType2 {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet2.create = (valueType, params) => {
  return new ZodSet2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType2 {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error42) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_arguments,
          argumentsError: error42
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error42) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_return_type,
          returnTypeError: error42
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise2) {
      const me = this;
      return OK(async function(...args) {
        const error42 = new ZodError2([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error42.addIssue(makeArgsIssue(args, e));
          throw error42;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error42.addIssue(makeReturnsIssue(result, e));
          throw error42;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple2.create(items).rest(ZodUnknown2.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
      returns: returns || ZodUnknown2.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy2 = class extends ZodType2 {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy2.create = (getter, params) => {
  return new ZodLazy2({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral2 = class extends ZodType2 {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral2.create = (value, params) => {
  return new ZodLiteral2({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum2({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum2 = class _ZodEnum extends ZodType2 {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum2.create = createZodEnum;
var ZodNativeEnum = class extends ZodType2 {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise2 = class extends ZodType2 {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise2.create = (schema115, params) => {
  return new ZodPromise2({
    type: schema115,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType2 {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema115, effect, params) => {
  return new ZodEffects({
    schema: schema115,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema115, params) => {
  return new ZodEffects({
    schema: schema115,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional2 = class extends ZodType2 {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional2.create = (type, params) => {
  return new ZodOptional2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable2 = class extends ZodType2 {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable2.create = (type, params) => {
  return new ZodNullable2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault2 = class extends ZodType2 {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault2.create = (type, params) => {
  return new ZodDefault2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch2 = class extends ZodType2 {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError2(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError2(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch2.create = (type, params) => {
  return new ZodCatch2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN2 = class extends ZodType2 {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType4 = this._getType(input);
    if (parsedType4 !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN2.create = (params) => {
  return new ZodNaN2({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType2 {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType2 {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b) {
    return new _ZodPipeline({
      in: a2,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly2 = class extends ZodType2 {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly2.create = (type, params) => {
  return new ZodReadonly2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
__name(cleanParams, "cleanParams");
function custom2(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny2.create().superRefine((data, ctx) => {
      const r2 = check2(data);
      if (r2 instanceof Promise) {
        return r2.then((r3) => {
          if (!r3) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r2) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny2.create();
}
__name(custom2, "custom");
var late = {
  object: ZodObject2.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom2((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString2.create;
var numberType = ZodNumber2.create;
var nanType = ZodNaN2.create;
var bigIntType = ZodBigInt2.create;
var booleanType = ZodBoolean2.create;
var dateType = ZodDate2.create;
var symbolType = ZodSymbol2.create;
var undefinedType = ZodUndefined2.create;
var nullType = ZodNull2.create;
var anyType = ZodAny2.create;
var unknownType = ZodUnknown2.create;
var neverType = ZodNever2.create;
var voidType = ZodVoid2.create;
var arrayType = ZodArray2.create;
var objectType = ZodObject2.create;
var strictObjectType = ZodObject2.strictCreate;
var unionType = ZodUnion2.create;
var discriminatedUnionType = ZodDiscriminatedUnion2.create;
var intersectionType = ZodIntersection2.create;
var tupleType = ZodTuple2.create;
var recordType = ZodRecord2.create;
var mapType = ZodMap2.create;
var setType = ZodSet2.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy2.create;
var literalType = ZodLiteral2.create;
var enumType = ZodEnum2.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise2.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional2.create;
var nullableType = ZodNullable2.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString2.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber2.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean2.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt2.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate2.create({ ...arg, coerce: true }), "date")
};
var NEVER2 = INVALID;

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
var createIdGenerator = /* @__PURE__ */ __name(({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = /* @__PURE__ */ __name(() => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i2 = 0; i2 < size; i2++) {
      chars[i2] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  }, "generator");
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
}, "createIdGenerator");
var generateId = createIdGenerator();
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse2(text2) {
  const obj = JSON.parse(text2);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text2) === false && suspectConstructorRx.test(text2) === false) {
    return obj;
  }
  return filter(obj);
}
__name(_parse2, "_parse");
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
__name(filter, "filter");
function secureJsonParse(text2) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse2(text2);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
__name(secureJsonParse, "secureJsonParse");
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
__name(validator, "validator");
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
__name(isValidator, "isValidator");
function asValidator(value) {
  return isValidator(value) ? value : standardSchemaValidator(value);
}
__name(asValidator, "asValidator");
function standardSchemaValidator(standardSchema) {
  return validator(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError({
        value,
        cause: result.issues
      })
    };
  });
}
__name(standardSchemaValidator, "standardSchemaValidator");
async function safeValidateTypes({
  value,
  schema: schema115
}) {
  const validator2 = asValidator(schema115);
  try {
    if (validator2.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator2.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error42) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error42 }),
      rawValue: value
    };
  }
}
__name(safeValidateTypes, "safeValidateTypes");
async function safeParseJSON({
  text: text2,
  schema: schema115
}) {
  try {
    const value = secureJsonParse(text2);
    if (schema115 == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes({ value, schema: schema115 });
  } catch (error42) {
    return {
      success: false,
      error: JSONParseError.isInstance(error42) ? error42 : new JSONParseError({ text: text2, cause: error42 }),
      rawValue: void 0
    };
  }
}
__name(safeParseJSON, "safeParseJSON");
var getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) {
    if (pathA[i2] !== pathB[i2])
      break;
  }
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
}, "getRelativePath");
var ignoreOverride = Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
}, "getDefaultOptions");
function parseAnyDef() {
  return {};
}
__name(parseAnyDef, "parseAnyDef");
function parseArrayDef(def, refs) {
  var _a18, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a18 = def.type) == null ? void 0 : _a18._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");
function parseBigintDef(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (check2.inclusive) {
          res.minimum = check2.value;
        } else {
          res.exclusiveMinimum = check2.value;
        }
        break;
      case "max":
        if (check2.inclusive) {
          res.maximum = check2.value;
        } else {
          res.exclusiveMaximum = check2.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");
function parseBooleanDef() {
  return { type: "boolean" };
}
__name(parseBooleanDef, "parseBooleanDef");
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");
var parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseCatchDef");
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def);
  }
}
__name(parseDateDef, "parseDateDef");
var integerDateParser = /* @__PURE__ */ __name((def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        res.minimum = check2.value;
        break;
      case "max":
        res.maximum = check2.value;
        break;
    }
  }
  return res;
}, "integerDateParser");
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
__name(parseDefaultDef, "parseDefaultDef");
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
__name(parseEffectsDef, "parseEffectsDef");
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
__name(parseEnumDef, "parseEnumDef");
var isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema115) => {
    if (isJsonSchema7AllOfType(schema115)) {
      mergedAllOf.push(...schema115.allOf);
    } else {
      let nestedSchema = schema115;
      if ("additionalProperties" in schema115 && schema115.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema115;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");
function parseLiteralDef(def) {
  const parsedType4 = typeof def.value;
  if (parsedType4 !== "bigint" && parsedType4 !== "number" && parsedType4 !== "boolean" && parsedType4 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType4 === "bigint" ? "integer" : parsedType4,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");
var emojiRegex2 = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: /* @__PURE__ */ __name(() => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex2;
  }, "emoji"),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern(
            res,
            RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`),
            check2.message,
            refs
          );
          break;
        case "endsWith":
          addPattern(
            res,
            RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`),
            check2.message,
            refs
          );
          break;
        case "datetime":
          addFormat(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check2.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
          break;
        case "includes": {
          addPattern(
            res,
            RegExp(escapeLiteralCheckValue(check2.value, refs)),
            check2.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check2.message, refs);
          break;
        case "cidr": {
          if (check2.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
          }
          if (check2.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check2.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check2);
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
function escapeLiteralCheckValue(literal2, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;
}
__name(escapeLiteralCheckValue, "escapeLiteralCheckValue");
var ALPHA_NUMERIC = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC.has(source[i2])) {
      result += "\\";
    }
    result += source[i2];
  }
  return result;
}
__name(escapeNonAlphaNumeric, "escapeNonAlphaNumeric");
function addFormat(schema115, value, message, refs) {
  var _a18;
  if (schema115.format || ((_a18 = schema115.anyOf) == null ? void 0 : _a18.some((x) => x.format))) {
    if (!schema115.anyOf) {
      schema115.anyOf = [];
    }
    if (schema115.format) {
      schema115.anyOf.push({
        format: schema115.format
      });
      delete schema115.format;
    }
    schema115.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema115.format = value;
  }
}
__name(addFormat, "addFormat");
function addPattern(schema115, regex, message, refs) {
  var _a18;
  if (schema115.pattern || ((_a18 = schema115.allOf) == null ? void 0 : _a18.some((x) => x.pattern))) {
    if (!schema115.allOf) {
      schema115.allOf = [];
    }
    if (schema115.pattern) {
      schema115.allOf.push({
        pattern: schema115.pattern
      });
      delete schema115.pattern;
    }
    schema115.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema115.pattern = stringifyRegExpWithFlags(regex, refs);
  }
}
__name(addPattern, "addPattern");
function stringifyRegExpWithFlags(regex, refs) {
  var _a18;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && ((_a18 = source[i2 + 2]) == null ? void 0 : _a18.match(/[a-z]/))) {
            pattern += source[i2];
            inCharRange = true;
          } else {
            pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i2] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i2] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
__name(stringifyRegExpWithFlags, "stringifyRegExpWithFlags");
function parseRecordDef(def, refs) {
  var _a18, _b, _c, _d, _e, _f;
  const schema115 = {
    type: "object",
    additionalProperties: (_a18 = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a18 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema115,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema115,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef(
      def.keyType._def,
      refs
    );
    return {
      ...schema115,
      propertyNames: keyType
    };
  }
  return schema115;
}
__name(parseRecordDef, "parseRecordDef");
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys2 = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef();
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys2, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");
function parseNativeEnumDef(def) {
  const object4 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object4[object4[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object4[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");
function parseNeverDef() {
  return { not: parseAnyDef() };
}
__name(parseNeverDef, "parseNeverDef");
function parseNullDef() {
  return {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null)
              return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i2, a2) => a2.indexOf(x) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
var asAnyOf = /* @__PURE__ */ __name((def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i2) => parseDef(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i2}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
}, "asAnyOf");
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");
function parseNumberDef(def) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check2.inclusive) {
          res.minimum = check2.value;
        } else {
          res.exclusiveMinimum = check2.value;
        }
        break;
      case "max":
        if (check2.inclusive) {
          res.maximum = check2.value;
        } else {
          res.exclusiveMaximum = check2.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required2 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional(propDef);
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required2.push(propName);
    }
  }
  if (required2.length) {
    result.required = required2;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
__name(parseObjectDef, "parseObjectDef");
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
__name(decideAdditionalProperties, "decideAdditionalProperties");
function safeIsOptional(schema115) {
  try {
    return schema115.isOptional();
  } catch (e) {
    return true;
  }
}
__name(safeIsOptional, "safeIsOptional");
var parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
  var _a18;
  if (refs.currentPath.toString() === ((_a18 = refs.propertyPath) == null ? void 0 : _a18.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
}, "parseOptionalDef");
var parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a2 = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
  });
  return {
    allOf: [a2, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema115 = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema115.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema115.maxItems = def.maxSize.value;
  }
  return schema115;
}
__name(parseSetDef, "parseSetDef");
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i2) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i2) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
__name(parseTupleDef, "parseTupleDef");
function parseUndefinedDef() {
  return {
    not: parseAnyDef()
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");
function parseUnknownDef() {
  return parseAnyDef();
}
__name(parseUnknownDef, "parseUnknownDef");
var parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseReadonlyDef");
var selectParser = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef();
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");
function parseDef(def, refs, forceResolution = false) {
  var _a18;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a18 = refs.override) == null ? void 0 : _a18.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema2) {
    addMeta(def, refs, jsonSchema2);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    newItem.jsonSchema = jsonSchema2;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema2;
  return jsonSchema2;
}
__name(parseDef, "parseDef");
var get$ref = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
    }
  }
}, "get$ref");
var addMeta = /* @__PURE__ */ __name((def, refs, jsonSchema2) => {
  if (def.description) {
    jsonSchema2.description = def.description;
  }
  return jsonSchema2;
}, "addMeta");
var getRefs = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name17, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name17],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
}, "getRefs");
var zodToJsonSchema = /* @__PURE__ */ __name((schema115, options) => {
  var _a18;
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name23, schema210]) => {
      var _a23;
      return {
        ...acc,
        [name23]: (_a23 = parseDef(
          schema210._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name23]
          },
          true
        )) != null ? _a23 : parseAnyDef()
      };
    },
    {}
  ) : void 0;
  const name17 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a18 = parseDef(
    schema115._def,
    name17 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name17]
    },
    false
  )) != null ? _a18 : parseAnyDef();
  const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title2 !== void 0) {
    main.title = title2;
  }
  const combined = name17 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name17
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name17]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
}, "zodToJsonSchema");
var zod_to_json_schema_default = zodToJsonSchema;
function zod3Schema(zodSchema2, options) {
  var _a18;
  const useReferences = (_a18 = options == null ? void 0 : options.useReferences) != null ? _a18 : false;
  return jsonSchema(
    zod_to_json_schema_default(zodSchema2, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: /* @__PURE__ */ __name(async (value) => {
        const result = await zodSchema2.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }, "validate")
    }
  );
}
__name(zod3Schema, "zod3Schema");
function zod4Schema(zodSchema2, options) {
  var _a18;
  const useReferences = (_a18 = options == null ? void 0 : options.useReferences) != null ? _a18 : false;
  const z4JSONSchema = toJSONSchema(zodSchema2, {
    target: "draft-7",
    io: "output",
    reused: useReferences ? "ref" : "inline"
  });
  return jsonSchema(z4JSONSchema, {
    validate: /* @__PURE__ */ __name(async (value) => {
      const result = await safeParseAsync2(zodSchema2, value);
      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
    }, "validate")
  });
}
__name(zod4Schema, "zod4Schema");
function isZod4Schema(zodSchema2) {
  return "_zod" in zodSchema2;
}
__name(isZod4Schema, "isZod4Schema");
function zodSchema(zodSchema2, options) {
  if (isZod4Schema(zodSchema2)) {
    return zod4Schema(zodSchema2, options);
  } else {
    return zod3Schema(zodSchema2, options);
  }
}
__name(zodSchema, "zodSchema");
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol]: true,
    jsonSchema: jsonSchema2,
    validate
  };
}
__name(jsonSchema, "jsonSchema");
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
__name(isSchema, "isSchema");
function asSchema(schema115) {
  return schema115 == null ? jsonSchema({
    properties: {},
    additionalProperties: false
  }) : isSchema(schema115) ? schema115 : zodSchema(schema115);
}
__name(asSchema, "asSchema");
var { btoa: btoa2, atob: atob2 } = globalThis;

// node_modules/ai/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __export2 = /* @__PURE__ */ __name((target, all) => {
  for (var name17 in all)
    __defProp2(target, name17, { get: all[name17], enumerable: true });
}, "__export");
var name14 = "AI_NoOutputSpecifiedError";
var marker15 = `vercel.ai.error.${name14}`;
var symbol16 = Symbol.for(marker15);
var _a15;
_a15 = symbol16;
var name22 = "AI_InvalidArgumentError";
var marker22 = `vercel.ai.error.${name22}`;
var symbol22 = Symbol.for(marker22);
var _a22;
_a22 = symbol22;
var name32 = "AI_InvalidStreamPartError";
var marker32 = `vercel.ai.error.${name32}`;
var symbol32 = Symbol.for(marker32);
var _a32;
_a32 = symbol32;
var name42 = "AI_InvalidToolInputError";
var marker42 = `vercel.ai.error.${name42}`;
var symbol42 = Symbol.for(marker42);
var _a42;
_a42 = symbol42;
var name52 = "AI_MCPClientError";
var marker52 = `vercel.ai.error.${name52}`;
var symbol52 = Symbol.for(marker52);
var _a52;
_a52 = symbol52;
var name62 = "AI_NoImageGeneratedError";
var marker62 = `vercel.ai.error.${name62}`;
var symbol62 = Symbol.for(marker62);
var _a62;
_a62 = symbol62;
var name72 = "AI_NoObjectGeneratedError";
var marker72 = `vercel.ai.error.${name72}`;
var symbol72 = Symbol.for(marker72);
var _a72;
var NoObjectGeneratedError = class extends AISDKError {
  static {
    __name(this, "NoObjectGeneratedError");
  }
  constructor({
    message = "No object generated.",
    cause,
    text: text2,
    response,
    usage,
    finishReason
  }) {
    super({ name: name72, message, cause });
    this[_a72] = true;
    this.text = text2;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error42) {
    return AISDKError.hasMarker(error42, marker72);
  }
};
_a72 = symbol72;
var name82 = "AI_NoOutputGeneratedError";
var marker82 = `vercel.ai.error.${name82}`;
var symbol82 = Symbol.for(marker82);
var _a82;
_a82 = symbol82;
var name92 = "AI_NoSuchToolError";
var marker92 = `vercel.ai.error.${name92}`;
var symbol92 = Symbol.for(marker92);
var _a92;
_a92 = symbol92;
var name102 = "AI_ToolCallRepairError";
var marker102 = `vercel.ai.error.${name102}`;
var symbol102 = Symbol.for(marker102);
var _a102;
_a102 = symbol102;
var name112 = "AI_InvalidDataContentError";
var marker112 = `vercel.ai.error.${name112}`;
var symbol112 = Symbol.for(marker112);
var _a112;
_a112 = symbol112;
var name122 = "AI_InvalidMessageRoleError";
var marker122 = `vercel.ai.error.${name122}`;
var symbol122 = Symbol.for(marker122);
var _a122;
_a122 = symbol122;
var name132 = "AI_MessageConversionError";
var marker132 = `vercel.ai.error.${name132}`;
var symbol132 = Symbol.for(marker132);
var _a132;
_a132 = symbol132;
var name142 = "AI_DownloadError";
var marker142 = `vercel.ai.error.${name142}`;
var symbol142 = Symbol.for(marker142);
var _a142;
_a142 = symbol142;
var name15 = "AI_RetryError";
var marker152 = `vercel.ai.error.${name15}`;
var symbol152 = Symbol.for(marker152);
var _a152;
_a152 = symbol152;
var dataContentSchema = external_exports.union([
  external_exports.string(),
  external_exports.instanceof(Uint8Array),
  external_exports.instanceof(ArrayBuffer),
  external_exports.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a172, _b;
      return (_b = (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) != null ? _b : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema = external_exports.lazy(
  () => external_exports.union([
    external_exports.null(),
    external_exports.string(),
    external_exports.number(),
    external_exports.boolean(),
    external_exports.record(external_exports.string(), jsonValueSchema),
    external_exports.array(jsonValueSchema)
  ])
);
var providerMetadataSchema = external_exports.record(
  external_exports.string(),
  external_exports.record(external_exports.string(), jsonValueSchema)
);
var textPartSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string(),
  providerOptions: providerMetadataSchema.optional()
});
var imagePartSchema = external_exports.object({
  type: external_exports.literal("image"),
  image: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
  mediaType: external_exports.string().optional(),
  providerOptions: providerMetadataSchema.optional()
});
var filePartSchema = external_exports.object({
  type: external_exports.literal("file"),
  data: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
  filename: external_exports.string().optional(),
  mediaType: external_exports.string(),
  providerOptions: providerMetadataSchema.optional()
});
var reasoningPartSchema = external_exports.object({
  type: external_exports.literal("reasoning"),
  text: external_exports.string(),
  providerOptions: providerMetadataSchema.optional()
});
var toolCallPartSchema = external_exports.object({
  type: external_exports.literal("tool-call"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  input: external_exports.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  providerExecuted: external_exports.boolean().optional()
});
var outputSchema = external_exports.discriminatedUnion("type", [
  external_exports.object({
    type: external_exports.literal("text"),
    value: external_exports.string()
  }),
  external_exports.object({
    type: external_exports.literal("json"),
    value: jsonValueSchema
  }),
  external_exports.object({
    type: external_exports.literal("error-text"),
    value: external_exports.string()
  }),
  external_exports.object({
    type: external_exports.literal("error-json"),
    value: jsonValueSchema
  }),
  external_exports.object({
    type: external_exports.literal("content"),
    value: external_exports.array(
      external_exports.union([
        external_exports.object({
          type: external_exports.literal("text"),
          text: external_exports.string()
        }),
        external_exports.object({
          type: external_exports.literal("media"),
          data: external_exports.string(),
          mediaType: external_exports.string()
        })
      ])
    )
  })
]);
var toolResultPartSchema = external_exports.object({
  type: external_exports.literal("tool-result"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  output: outputSchema,
  providerOptions: providerMetadataSchema.optional()
});
var systemModelMessageSchema = external_exports.object(
  {
    role: external_exports.literal("system"),
    content: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  }
);
var userModelMessageSchema = external_exports.object({
  role: external_exports.literal("user"),
  content: external_exports.union([
    external_exports.string(),
    external_exports.array(external_exports.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  providerOptions: providerMetadataSchema.optional()
});
var assistantModelMessageSchema = external_exports.object({
  role: external_exports.literal("assistant"),
  content: external_exports.union([
    external_exports.string(),
    external_exports.array(
      external_exports.union([
        textPartSchema,
        filePartSchema,
        reasoningPartSchema,
        toolCallPartSchema,
        toolResultPartSchema
      ])
    )
  ]),
  providerOptions: providerMetadataSchema.optional()
});
var toolModelMessageSchema = external_exports.object({
  role: external_exports.literal("tool"),
  content: external_exports.array(toolResultPartSchema),
  providerOptions: providerMetadataSchema.optional()
});
var modelMessageSchema = external_exports.union([
  systemModelMessageSchema,
  userModelMessageSchema,
  assistantModelMessageSchema,
  toolModelMessageSchema
]);
var originalGenerateId = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
var JsonToSseTransformStream = class extends TransformStream {
  static {
    __name(this, "JsonToSseTransformStream");
  }
  constructor() {
    super({
      transform(part, controller) {
        controller.enqueue(`data: ${JSON.stringify(part)}

`);
      },
      flush(controller) {
        controller.enqueue("data: [DONE]\n\n");
      }
    });
  }
};
var uiMessageChunkSchema = external_exports.union([
  external_exports.strictObject({
    type: external_exports.literal("text-start"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("text-delta"),
    id: external_exports.string(),
    delta: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("text-end"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("error"),
    errorText: external_exports.string()
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-start"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    providerExecuted: external_exports.boolean().optional(),
    dynamic: external_exports.boolean().optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-delta"),
    toolCallId: external_exports.string(),
    inputTextDelta: external_exports.string()
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-available"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    input: external_exports.unknown(),
    providerExecuted: external_exports.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: external_exports.boolean().optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-error"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    input: external_exports.unknown(),
    providerExecuted: external_exports.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: external_exports.boolean().optional(),
    errorText: external_exports.string()
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-output-available"),
    toolCallId: external_exports.string(),
    output: external_exports.unknown(),
    providerExecuted: external_exports.boolean().optional(),
    dynamic: external_exports.boolean().optional(),
    preliminary: external_exports.boolean().optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-output-error"),
    toolCallId: external_exports.string(),
    errorText: external_exports.string(),
    providerExecuted: external_exports.boolean().optional(),
    dynamic: external_exports.boolean().optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning"),
    text: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning-start"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning-delta"),
    id: external_exports.string(),
    delta: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning-end"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning-part-finish")
  }),
  external_exports.strictObject({
    type: external_exports.literal("source-url"),
    sourceId: external_exports.string(),
    url: external_exports.string(),
    title: external_exports.string().optional(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("source-document"),
    sourceId: external_exports.string(),
    mediaType: external_exports.string(),
    title: external_exports.string(),
    filename: external_exports.string().optional(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("file"),
    url: external_exports.string(),
    mediaType: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  external_exports.strictObject({
    type: external_exports.string().startsWith("data-"),
    id: external_exports.string().optional(),
    data: external_exports.unknown(),
    transient: external_exports.boolean().optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("start-step")
  }),
  external_exports.strictObject({
    type: external_exports.literal("finish-step")
  }),
  external_exports.strictObject({
    type: external_exports.literal("start"),
    messageId: external_exports.string().optional(),
    messageMetadata: external_exports.unknown().optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("finish"),
    messageMetadata: external_exports.unknown().optional()
  }),
  external_exports.strictObject({
    type: external_exports.literal("abort")
  }),
  external_exports.strictObject({
    type: external_exports.literal("message-metadata"),
    messageMetadata: external_exports.unknown()
  })
]);
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i2, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i2;
          literalStart = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  __name(processValueStart, "processValueStart");
  function processAfterObjectValue(char, i2) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i2;
        stack.pop();
        break;
      }
    }
  }
  __name(processAfterObjectValue, "processAfterObjectValue");
  function processAfterArrayValue(char, i2) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i2;
        stack.pop();
        break;
      }
    }
  }
  __name(processAfterArrayValue, "processAfterArrayValue");
  for (let i2 = 0; i2 < input.length; i2++) {
    const char = input[i2];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i2, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i2;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i2, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i2);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i2;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i2;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i2;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i2;
            processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i2;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i2;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i2;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i2;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i2);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i2);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i2);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i2);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i2 + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i2);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i2);
          }
        } else {
          lastValidIndex = i2;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i2 = stack.length - 1; i2 >= 0; i2--) {
    const state = stack[i2];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
__name(fixJson, "fixJson");
async function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
__name(parsePartialJson, "parsePartialJson");
var originalGenerateId2 = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
var originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });
var originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });
var output_exports = {};
__export2(output_exports, {
  object: /* @__PURE__ */ __name(() => object2, "object"),
  text: /* @__PURE__ */ __name(() => text, "text")
});
var text = /* @__PURE__ */ __name(() => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text2 }) {
    return { partial: text2 };
  },
  async parseOutput({ text: text2 }) {
    return text2;
  }
}), "text");
var object2 = /* @__PURE__ */ __name(({
  schema: inputSchema
}) => {
  const schema115 = asSchema(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema115.jsonSchema
    },
    async parsePartial({ text: text2 }) {
      const result = await parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text2 }, context2) {
      const parseResult = await safeParseJSON({ text: text2 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      const validationResult = await safeValidateTypes({
        value: parseResult.value,
        schema: schema115
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      }
      return validationResult.value;
    }
  };
}, "object");
var name16 = "AI_NoSuchProviderError";
var marker16 = `vercel.ai.error.${name16}`;
var symbol162 = Symbol.for(marker16);
var _a16;
_a16 = symbol162;
var ClientOrServerImplementationSchema = external_exports.looseObject({
  name: external_exports.string(),
  version: external_exports.string()
});
var BaseParamsSchema = external_exports.looseObject({
  _meta: external_exports.optional(external_exports.object({}).loose())
});
var ResultSchema = BaseParamsSchema;
var RequestSchema = external_exports.object({
  method: external_exports.string(),
  params: external_exports.optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = external_exports.looseObject({
  experimental: external_exports.optional(external_exports.object({}).loose()),
  logging: external_exports.optional(external_exports.object({}).loose()),
  prompts: external_exports.optional(
    external_exports.looseObject({
      listChanged: external_exports.optional(external_exports.boolean())
    })
  ),
  resources: external_exports.optional(
    external_exports.looseObject({
      subscribe: external_exports.optional(external_exports.boolean()),
      listChanged: external_exports.optional(external_exports.boolean())
    })
  ),
  tools: external_exports.optional(
    external_exports.looseObject({
      listChanged: external_exports.optional(external_exports.boolean())
    })
  )
});
var InitializeResultSchema = ResultSchema.extend({
  protocolVersion: external_exports.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ClientOrServerImplementationSchema,
  instructions: external_exports.optional(external_exports.string())
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: external_exports.optional(external_exports.string())
});
var ToolSchema = external_exports.object({
  name: external_exports.string(),
  description: external_exports.optional(external_exports.string()),
  inputSchema: external_exports.object({
    type: external_exports.literal("object"),
    properties: external_exports.optional(external_exports.object({}).loose())
  }).loose()
}).loose();
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: external_exports.array(ToolSchema)
});
var TextContentSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string()
}).loose();
var ImageContentSchema = external_exports.object({
  type: external_exports.literal("image"),
  data: external_exports.base64(),
  mimeType: external_exports.string()
}).loose();
var ResourceContentsSchema = external_exports.object({
  /**
   * The URI of this resource.
   */
  uri: external_exports.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: external_exports.optional(external_exports.string())
}).loose();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: external_exports.string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: external_exports.base64()
});
var EmbeddedResourceSchema = external_exports.object({
  type: external_exports.literal("resource"),
  resource: external_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema])
}).loose();
var CallToolResultSchema = ResultSchema.extend({
  content: external_exports.array(
    external_exports.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])
  ),
  isError: external_exports.boolean().default(false).optional()
}).or(
  ResultSchema.extend({
    toolResult: external_exports.unknown()
  })
);
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = external_exports.object({
  jsonrpc: external_exports.literal(JSONRPC_VERSION),
  id: external_exports.union([external_exports.string(), external_exports.number().int()])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = external_exports.object({
  jsonrpc: external_exports.literal(JSONRPC_VERSION),
  id: external_exports.union([external_exports.string(), external_exports.number().int()]),
  result: ResultSchema
}).strict();
var JSONRPCErrorSchema = external_exports.object({
  jsonrpc: external_exports.literal(JSONRPC_VERSION),
  id: external_exports.union([external_exports.string(), external_exports.number().int()]),
  error: external_exports.object({
    code: external_exports.number().int(),
    message: external_exports.string(),
    data: external_exports.optional(external_exports.unknown())
  })
}).strict();
var JSONRPCNotificationSchema = external_exports.object({
  jsonrpc: external_exports.literal(JSONRPC_VERSION)
}).merge(
  external_exports.object({
    method: external_exports.string(),
    params: external_exports.optional(BaseParamsSchema)
  })
).strict();
var JSONRPCMessageSchema = external_exports.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema
]);
var textUIPartSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string(),
  state: external_exports.enum(["streaming", "done"]).optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var reasoningUIPartSchema = external_exports.object({
  type: external_exports.literal("reasoning"),
  text: external_exports.string(),
  state: external_exports.enum(["streaming", "done"]).optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var sourceUrlUIPartSchema = external_exports.object({
  type: external_exports.literal("source-url"),
  sourceId: external_exports.string(),
  url: external_exports.string(),
  title: external_exports.string().optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var sourceDocumentUIPartSchema = external_exports.object({
  type: external_exports.literal("source-document"),
  sourceId: external_exports.string(),
  mediaType: external_exports.string(),
  title: external_exports.string(),
  filename: external_exports.string().optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var fileUIPartSchema = external_exports.object({
  type: external_exports.literal("file"),
  mediaType: external_exports.string(),
  filename: external_exports.string().optional(),
  url: external_exports.string(),
  providerMetadata: providerMetadataSchema.optional()
});
var stepStartUIPartSchema = external_exports.object({
  type: external_exports.literal("step-start")
});
var dataUIPartSchema = external_exports.object({
  type: external_exports.string().startsWith("data-"),
  id: external_exports.string().optional(),
  data: external_exports.unknown()
});
var dynamicToolUIPartSchemas = [
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-streaming"),
    input: external_exports.unknown().optional(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional()
  }),
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-available"),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional()
  }),
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-available"),
    input: external_exports.unknown(),
    output: external_exports.unknown(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
    preliminary: external_exports.boolean().optional()
  }),
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-error"),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.string(),
    callProviderMetadata: providerMetadataSchema.optional()
  })
];
var toolUIPartSchemas = [
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-streaming"),
    input: external_exports.unknown().optional(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional()
  }),
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-available"),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional()
  }),
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-available"),
    input: external_exports.unknown(),
    output: external_exports.unknown(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
    preliminary: external_exports.boolean().optional()
  }),
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-error"),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.string(),
    callProviderMetadata: providerMetadataSchema.optional()
  })
];
var uiMessageSchema = external_exports.object({
  id: external_exports.string(),
  role: external_exports.enum(["system", "user", "assistant"]),
  metadata: external_exports.unknown().optional(),
  parts: external_exports.array(
    external_exports.union([
      textUIPartSchema,
      reasoningUIPartSchema,
      sourceUrlUIPartSchema,
      sourceDocumentUIPartSchema,
      fileUIPartSchema,
      stepStartUIPartSchema,
      dataUIPartSchema,
      ...dynamicToolUIPartSchemas,
      ...toolUIPartSchemas
    ])
  )
});

// node_modules/nanoid/index.browser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/nanoid/url-alphabet/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid3 = /* @__PURE__ */ __name((size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
}, "nanoid");

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-06-18";
var SUPPORTED_PROTOCOL_VERSIONS = [
  LATEST_PROTOCOL_VERSION,
  "2025-03-26",
  "2024-11-05",
  "2024-10-07"
];
var JSONRPC_VERSION2 = "2.0";
var ProgressTokenSchema = external_exports2.union([external_exports2.string(), external_exports2.number().int()]);
var CursorSchema = external_exports2.string();
var RequestMetaSchema = external_exports2.object({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: external_exports2.optional(ProgressTokenSchema)
}).passthrough();
var BaseRequestParamsSchema = external_exports2.object({
  _meta: external_exports2.optional(RequestMetaSchema)
}).passthrough();
var RequestSchema2 = external_exports2.object({
  method: external_exports2.string(),
  params: external_exports2.optional(BaseRequestParamsSchema)
});
var BaseNotificationParamsSchema = external_exports2.object({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var NotificationSchema = external_exports2.object({
  method: external_exports2.string(),
  params: external_exports2.optional(BaseNotificationParamsSchema)
});
var ResultSchema2 = external_exports2.object({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var RequestIdSchema = external_exports2.union([external_exports2.string(), external_exports2.number().int()]);
var JSONRPCRequestSchema2 = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION2),
  id: RequestIdSchema
}).merge(RequestSchema2).strict();
var isJSONRPCRequest = /* @__PURE__ */ __name((value) => JSONRPCRequestSchema2.safeParse(value).success, "isJSONRPCRequest");
var JSONRPCNotificationSchema2 = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION2)
}).merge(NotificationSchema).strict();
var isJSONRPCNotification = /* @__PURE__ */ __name((value) => JSONRPCNotificationSchema2.safeParse(value).success, "isJSONRPCNotification");
var JSONRPCResponseSchema2 = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION2),
  id: RequestIdSchema,
  result: ResultSchema2
}).strict();
var isJSONRPCResponse = /* @__PURE__ */ __name((value) => JSONRPCResponseSchema2.safeParse(value).success, "isJSONRPCResponse");
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorSchema2 = external_exports2.object({
  jsonrpc: external_exports2.literal(JSONRPC_VERSION2),
  id: RequestIdSchema,
  error: external_exports2.object({
    /**
     * The error type that occurred.
     */
    code: external_exports2.number().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: external_exports2.string(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: external_exports2.optional(external_exports2.unknown())
  })
}).strict();
var isJSONRPCError = /* @__PURE__ */ __name((value) => JSONRPCErrorSchema2.safeParse(value).success, "isJSONRPCError");
var JSONRPCMessageSchema2 = external_exports2.union([
  JSONRPCRequestSchema2,
  JSONRPCNotificationSchema2,
  JSONRPCResponseSchema2,
  JSONRPCErrorSchema2
]);
var EmptyResultSchema = ResultSchema2.strict();
var CancelledNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/cancelled"),
  params: BaseNotificationParamsSchema.extend({
    /**
     * The ID of the request to cancel.
     *
     * This MUST correspond to the ID of a request previously issued in the same direction.
     */
    requestId: RequestIdSchema,
    /**
     * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
     */
    reason: external_exports2.string().optional()
  })
});
var IconSchema = external_exports2.object({
  /**
   * URL or data URI for the icon.
   */
  src: external_exports2.string(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: external_exports2.optional(external_exports2.string()),
  /**
   * Optional string specifying icon dimensions (e.g., "48x48 96x96").
   */
  sizes: external_exports2.optional(external_exports2.string())
}).passthrough();
var BaseMetadataSchema = external_exports2.object({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: external_exports2.string(),
  /**
  * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
  * even by those unfamiliar with domain-specific terminology.
  *
  * If not provided, the name should be used for display (except for Tool,
  * where `annotations.title` should be given precedence over using `name`,
  * if present).
  */
  title: external_exports2.optional(external_exports2.string())
}).passthrough();
var ImplementationSchema = BaseMetadataSchema.extend({
  version: external_exports2.string(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: external_exports2.optional(external_exports2.string()),
  /**
   * An optional list of icons for this implementation.
   * This can be used by clients to display the implementation in a user interface.
   * Each icon should have a `kind` property that specifies whether it is a data representation or a URL source, a `src` property that points to the icon file or data representation, and may also include a `mimeType` and `sizes` property.
   * The `mimeType` property should be a valid MIME type for the icon file, such as "image/png" or "image/svg+xml".
   * The `sizes` property should be a string that specifies one or more sizes at which the icon file can be used, such as "48x48" or "any" for scalable formats like SVG.
   * The `sizes` property is optional, and if not provided, the client should assume that the icon can be used at any size.
   */
  icons: external_exports2.optional(external_exports2.array(IconSchema))
});
var ClientCapabilitiesSchema = external_exports2.object({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: external_exports2.optional(external_exports2.object({}).passthrough()),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: external_exports2.optional(external_exports2.object({}).passthrough()),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: external_exports2.optional(external_exports2.object({}).passthrough()),
  /**
   * Present if the client supports listing roots.
   */
  roots: external_exports2.optional(external_exports2.object({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: external_exports2.optional(external_exports2.boolean())
  }).passthrough())
}).passthrough();
var InitializeRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("initialize"),
  params: BaseRequestParamsSchema.extend({
    /**
     * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
     */
    protocolVersion: external_exports2.string(),
    capabilities: ClientCapabilitiesSchema,
    clientInfo: ImplementationSchema
  })
});
var ServerCapabilitiesSchema2 = external_exports2.object({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: external_exports2.optional(external_exports2.object({}).passthrough()),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: external_exports2.optional(external_exports2.object({}).passthrough()),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: external_exports2.optional(external_exports2.object({}).passthrough()),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: external_exports2.optional(external_exports2.object({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: external_exports2.optional(external_exports2.boolean())
  }).passthrough()),
  /**
   * Present if the server offers any resources to read.
   */
  resources: external_exports2.optional(external_exports2.object({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: external_exports2.optional(external_exports2.boolean()),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: external_exports2.optional(external_exports2.boolean())
  }).passthrough()),
  /**
   * Present if the server offers any tools to call.
   */
  tools: external_exports2.optional(external_exports2.object({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: external_exports2.optional(external_exports2.boolean())
  }).passthrough())
}).passthrough();
var InitializeResultSchema2 = ResultSchema2.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: external_exports2.string(),
  capabilities: ServerCapabilitiesSchema2,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: external_exports2.optional(external_exports2.string())
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/initialized")
});
var isInitializedNotification = /* @__PURE__ */ __name((value) => InitializedNotificationSchema.safeParse(value).success, "isInitializedNotification");
var PingRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("ping")
});
var ProgressSchema = external_exports2.object({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: external_exports2.number(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: external_exports2.optional(external_exports2.number()),
  /**
   * An optional message describing the current progress.
   */
  message: external_exports2.optional(external_exports2.string())
}).passthrough();
var ProgressNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/progress"),
  params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({
    /**
     * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
     */
    progressToken: ProgressTokenSchema
  })
});
var PaginatedRequestSchema = RequestSchema2.extend({
  params: BaseRequestParamsSchema.extend({
    /**
     * An opaque token representing the current pagination position.
     * If provided, the server should return results starting after this cursor.
     */
    cursor: external_exports2.optional(CursorSchema)
  }).optional()
});
var PaginatedResultSchema2 = ResultSchema2.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: external_exports2.optional(CursorSchema)
});
var ResourceContentsSchema2 = external_exports2.object({
  /**
   * The URI of this resource.
   */
  uri: external_exports2.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: external_exports2.optional(external_exports2.string()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var TextResourceContentsSchema2 = ResourceContentsSchema2.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: external_exports2.string()
});
var Base64Schema = external_exports2.string().refine((val) => {
  try {
    atob(val);
    return true;
  } catch (_a18) {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema2 = ResourceContentsSchema2.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
var ResourceSchema = BaseMetadataSchema.extend({
  /**
   * The URI of this resource.
   */
  uri: external_exports2.string(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: external_exports2.optional(external_exports2.string()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: external_exports2.optional(external_exports2.string()),
  /**
   * An optional list of icons for this resource.
   */
  icons: external_exports2.optional(external_exports2.array(IconSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
});
var ResourceTemplateSchema = BaseMetadataSchema.extend({
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: external_exports2.string(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: external_exports2.optional(external_exports2.string()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: external_exports2.optional(external_exports2.string()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: external_exports2.literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema2.extend({
  resources: external_exports2.array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: external_exports2.literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema2.extend({
  resourceTemplates: external_exports2.array(ResourceTemplateSchema)
});
var ReadResourceRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("resources/read"),
  params: BaseRequestParamsSchema.extend({
    /**
     * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
     */
    uri: external_exports2.string()
  })
});
var ReadResourceResultSchema = ResultSchema2.extend({
  contents: external_exports2.array(external_exports2.union([TextResourceContentsSchema2, BlobResourceContentsSchema2]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/resources/list_changed")
});
var SubscribeRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("resources/subscribe"),
  params: BaseRequestParamsSchema.extend({
    /**
     * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
     */
    uri: external_exports2.string()
  })
});
var UnsubscribeRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("resources/unsubscribe"),
  params: BaseRequestParamsSchema.extend({
    /**
     * The URI of the resource to unsubscribe from.
     */
    uri: external_exports2.string()
  })
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/resources/updated"),
  params: BaseNotificationParamsSchema.extend({
    /**
     * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
     */
    uri: external_exports2.string()
  })
});
var PromptArgumentSchema = external_exports2.object({
  /**
   * The name of the argument.
   */
  name: external_exports2.string(),
  /**
   * A human-readable description of the argument.
   */
  description: external_exports2.optional(external_exports2.string()),
  /**
   * Whether this argument must be provided.
   */
  required: external_exports2.optional(external_exports2.boolean())
}).passthrough();
var PromptSchema = BaseMetadataSchema.extend({
  /**
   * An optional description of what this prompt provides
   */
  description: external_exports2.optional(external_exports2.string()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: external_exports2.optional(external_exports2.array(PromptArgumentSchema)),
  /**
   * An optional list of icons for this prompt.
   */
  icons: external_exports2.optional(external_exports2.array(IconSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: external_exports2.literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema2.extend({
  prompts: external_exports2.array(PromptSchema)
});
var GetPromptRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("prompts/get"),
  params: BaseRequestParamsSchema.extend({
    /**
     * The name of the prompt or prompt template.
     */
    name: external_exports2.string(),
    /**
     * Arguments to use for templating the prompt.
     */
    arguments: external_exports2.optional(external_exports2.record(external_exports2.string()))
  })
});
var TextContentSchema2 = external_exports2.object({
  type: external_exports2.literal("text"),
  /**
   * The text content of the message.
   */
  text: external_exports2.string(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var ImageContentSchema2 = external_exports2.object({
  type: external_exports2.literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: external_exports2.string(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var AudioContentSchema = external_exports2.object({
  type: external_exports2.literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: external_exports2.string(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var EmbeddedResourceSchema2 = external_exports2.object({
  type: external_exports2.literal("resource"),
  resource: external_exports2.union([TextResourceContentsSchema2, BlobResourceContentsSchema2]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var ResourceLinkSchema = ResourceSchema.extend({
  type: external_exports2.literal("resource_link")
});
var ContentBlockSchema = external_exports2.union([
  TextContentSchema2,
  ImageContentSchema2,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema2
]);
var PromptMessageSchema = external_exports2.object({
  role: external_exports2.enum(["user", "assistant"]),
  content: ContentBlockSchema
}).passthrough();
var GetPromptResultSchema = ResultSchema2.extend({
  /**
   * An optional description for the prompt.
   */
  description: external_exports2.optional(external_exports2.string()),
  messages: external_exports2.array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/prompts/list_changed")
});
var ToolAnnotationsSchema = external_exports2.object({
  /**
   * A human-readable title for the tool.
   */
  title: external_exports2.optional(external_exports2.string()),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: external_exports2.optional(external_exports2.boolean()),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: external_exports2.optional(external_exports2.boolean()),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: external_exports2.optional(external_exports2.boolean()),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: external_exports2.optional(external_exports2.boolean())
}).passthrough();
var ToolSchema2 = BaseMetadataSchema.extend({
  /**
   * A human-readable description of the tool.
   */
  description: external_exports2.optional(external_exports2.string()),
  /**
   * A JSON Schema object defining the expected parameters for the tool.
   */
  inputSchema: external_exports2.object({
    type: external_exports2.literal("object"),
    properties: external_exports2.optional(external_exports2.object({}).passthrough()),
    required: external_exports2.optional(external_exports2.array(external_exports2.string()))
  }).passthrough(),
  /**
   * An optional JSON Schema object defining the structure of the tool's output returned in
   * the structuredContent field of a CallToolResult.
   */
  outputSchema: external_exports2.optional(external_exports2.object({
    type: external_exports2.literal("object"),
    properties: external_exports2.optional(external_exports2.object({}).passthrough()),
    required: external_exports2.optional(external_exports2.array(external_exports2.string()))
  }).passthrough()),
  /**
   * Optional additional tool information.
   */
  annotations: external_exports2.optional(ToolAnnotationsSchema),
  /**
   * An optional list of icons for this tool.
   */
  icons: external_exports2.optional(external_exports2.array(IconSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: external_exports2.literal("tools/list")
});
var ListToolsResultSchema2 = PaginatedResultSchema2.extend({
  tools: external_exports2.array(ToolSchema2)
});
var CallToolResultSchema2 = ResultSchema2.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: external_exports2.array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: external_exports2.object({}).passthrough().optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: external_exports2.optional(external_exports2.boolean())
});
var CompatibilityCallToolResultSchema = CallToolResultSchema2.or(ResultSchema2.extend({
  toolResult: external_exports2.unknown()
}));
var CallToolRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("tools/call"),
  params: BaseRequestParamsSchema.extend({
    name: external_exports2.string(),
    arguments: external_exports2.optional(external_exports2.record(external_exports2.unknown()))
  })
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/tools/list_changed")
});
var LoggingLevelSchema = external_exports2.enum([
  "debug",
  "info",
  "notice",
  "warning",
  "error",
  "critical",
  "alert",
  "emergency"
]);
var SetLevelRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("logging/setLevel"),
  params: BaseRequestParamsSchema.extend({
    /**
     * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
     */
    level: LoggingLevelSchema
  })
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/message"),
  params: BaseNotificationParamsSchema.extend({
    /**
     * The severity of this log message.
     */
    level: LoggingLevelSchema,
    /**
     * An optional name of the logger issuing this message.
     */
    logger: external_exports2.optional(external_exports2.string()),
    /**
     * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
     */
    data: external_exports2.unknown()
  })
});
var ModelHintSchema = external_exports2.object({
  /**
   * A hint for a model name.
   */
  name: external_exports2.string().optional()
}).passthrough();
var ModelPreferencesSchema = external_exports2.object({
  /**
   * Optional hints to use for model selection.
   */
  hints: external_exports2.optional(external_exports2.array(ModelHintSchema)),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: external_exports2.optional(external_exports2.number().min(0).max(1)),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: external_exports2.optional(external_exports2.number().min(0).max(1)),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: external_exports2.optional(external_exports2.number().min(0).max(1))
}).passthrough();
var SamplingMessageSchema = external_exports2.object({
  role: external_exports2.enum(["user", "assistant"]),
  content: external_exports2.union([TextContentSchema2, ImageContentSchema2, AudioContentSchema])
}).passthrough();
var CreateMessageRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("sampling/createMessage"),
  params: BaseRequestParamsSchema.extend({
    messages: external_exports2.array(SamplingMessageSchema),
    /**
     * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
     */
    systemPrompt: external_exports2.optional(external_exports2.string()),
    /**
     * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
     */
    includeContext: external_exports2.optional(external_exports2.enum(["none", "thisServer", "allServers"])),
    temperature: external_exports2.optional(external_exports2.number()),
    /**
     * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
     */
    maxTokens: external_exports2.number().int(),
    stopSequences: external_exports2.optional(external_exports2.array(external_exports2.string())),
    /**
     * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
     */
    metadata: external_exports2.optional(external_exports2.object({}).passthrough()),
    /**
     * The server's preferences for which model to select.
     */
    modelPreferences: external_exports2.optional(ModelPreferencesSchema)
  })
});
var CreateMessageResultSchema = ResultSchema2.extend({
  /**
   * The name of the model that generated the message.
   */
  model: external_exports2.string(),
  /**
   * The reason why sampling stopped.
   */
  stopReason: external_exports2.optional(external_exports2.enum(["endTurn", "stopSequence", "maxTokens"]).or(external_exports2.string())),
  role: external_exports2.enum(["user", "assistant"]),
  content: external_exports2.discriminatedUnion("type", [
    TextContentSchema2,
    ImageContentSchema2,
    AudioContentSchema
  ])
});
var BooleanSchemaSchema = external_exports2.object({
  type: external_exports2.literal("boolean"),
  title: external_exports2.optional(external_exports2.string()),
  description: external_exports2.optional(external_exports2.string()),
  default: external_exports2.optional(external_exports2.boolean())
}).passthrough();
var StringSchemaSchema = external_exports2.object({
  type: external_exports2.literal("string"),
  title: external_exports2.optional(external_exports2.string()),
  description: external_exports2.optional(external_exports2.string()),
  minLength: external_exports2.optional(external_exports2.number()),
  maxLength: external_exports2.optional(external_exports2.number()),
  format: external_exports2.optional(external_exports2.enum(["email", "uri", "date", "date-time"]))
}).passthrough();
var NumberSchemaSchema = external_exports2.object({
  type: external_exports2.enum(["number", "integer"]),
  title: external_exports2.optional(external_exports2.string()),
  description: external_exports2.optional(external_exports2.string()),
  minimum: external_exports2.optional(external_exports2.number()),
  maximum: external_exports2.optional(external_exports2.number())
}).passthrough();
var EnumSchemaSchema = external_exports2.object({
  type: external_exports2.literal("string"),
  title: external_exports2.optional(external_exports2.string()),
  description: external_exports2.optional(external_exports2.string()),
  enum: external_exports2.array(external_exports2.string()),
  enumNames: external_exports2.optional(external_exports2.array(external_exports2.string()))
}).passthrough();
var PrimitiveSchemaDefinitionSchema = external_exports2.union([
  BooleanSchemaSchema,
  StringSchemaSchema,
  NumberSchemaSchema,
  EnumSchemaSchema
]);
var ElicitRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("elicitation/create"),
  params: BaseRequestParamsSchema.extend({
    /**
     * The message to present to the user.
     */
    message: external_exports2.string(),
    /**
     * The schema for the requested user input.
     */
    requestedSchema: external_exports2.object({
      type: external_exports2.literal("object"),
      properties: external_exports2.record(external_exports2.string(), PrimitiveSchemaDefinitionSchema),
      required: external_exports2.optional(external_exports2.array(external_exports2.string()))
    }).passthrough()
  })
});
var ElicitResultSchema = ResultSchema2.extend({
  /**
   * The user's response action.
   */
  action: external_exports2.enum(["accept", "decline", "cancel"]),
  /**
   * The collected user input content (only present if action is "accept").
   */
  content: external_exports2.optional(external_exports2.record(external_exports2.string(), external_exports2.unknown()))
});
var ResourceTemplateReferenceSchema = external_exports2.object({
  type: external_exports2.literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: external_exports2.string()
}).passthrough();
var PromptReferenceSchema = external_exports2.object({
  type: external_exports2.literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: external_exports2.string()
}).passthrough();
var CompleteRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("completion/complete"),
  params: BaseRequestParamsSchema.extend({
    ref: external_exports2.union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
    /**
     * The argument's information
     */
    argument: external_exports2.object({
      /**
       * The name of the argument
       */
      name: external_exports2.string(),
      /**
       * The value of the argument to use for completion matching.
       */
      value: external_exports2.string()
    }).passthrough(),
    context: external_exports2.optional(external_exports2.object({
      /**
       * Previously-resolved variables in a URI template or prompt.
       */
      arguments: external_exports2.optional(external_exports2.record(external_exports2.string(), external_exports2.string()))
    }))
  })
});
var CompleteResultSchema = ResultSchema2.extend({
  completion: external_exports2.object({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: external_exports2.array(external_exports2.string()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: external_exports2.optional(external_exports2.number().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: external_exports2.optional(external_exports2.boolean())
  }).passthrough()
});
var RootSchema = external_exports2.object({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: external_exports2.string().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: external_exports2.optional(external_exports2.string()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: external_exports2.optional(external_exports2.object({}).passthrough())
}).passthrough();
var ListRootsRequestSchema = RequestSchema2.extend({
  method: external_exports2.literal("roots/list")
});
var ListRootsResultSchema = ResultSchema2.extend({
  roots: external_exports2.array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: external_exports2.literal("notifications/roots/list_changed")
});
var ClientRequestSchema = external_exports2.union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema
]);
var ClientNotificationSchema = external_exports2.union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema
]);
var ClientResultSchema = external_exports2.union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  ElicitResultSchema,
  ListRootsResultSchema
]);
var ServerRequestSchema = external_exports2.union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema
]);
var ServerNotificationSchema = external_exports2.union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema
]);
var ServerResultSchema = external_exports2.union([
  EmptyResultSchema,
  InitializeResultSchema2,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema2,
  ListToolsResultSchema2
]);
var McpError = class extends Error {
  static {
    __name(this, "McpError");
  }
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
var Protocol = class {
  static {
    __name(this, "Protocol");
  }
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
      controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info3 = this._timeoutInfo.get(messageId);
    if (!info3)
      return false;
    const totalElapsed = Date.now() - info3.startTime;
    if (info3.maxTotalTimeout && totalElapsed >= info3.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: info3.maxTotalTimeout, totalElapsed });
    }
    clearTimeout(info3.timeoutId);
    info3.timeoutId = setTimeout(info3.onTimeout, info3.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info3 = this._timeoutInfo.get(messageId);
    if (info3) {
      clearTimeout(info3.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    var _a18, _b, _c;
    this._transport = transport;
    const _onclose = (_a18 = this.transport) === null || _a18 === void 0 ? void 0 : _a18.onclose;
    this._transport.onclose = () => {
      _onclose === null || _onclose === void 0 ? void 0 : _onclose();
      this._onclose();
    };
    const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
    this._transport.onerror = (error42) => {
      _onerror === null || _onerror === void 0 ? void 0 : _onerror(error42);
      this._onerror(error42);
    };
    const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage === null || _onmessage === void 0 ? void 0 : _onmessage(message, extra);
      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    var _a18;
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._pendingDebouncedNotifications.clear();
    this._transport = void 0;
    (_a18 = this.onclose) === null || _a18 === void 0 ? void 0 : _a18.call(this);
    const error42 = new McpError(ErrorCode.ConnectionClosed, "Connection closed");
    for (const handler of responseHandlers.values()) {
      handler(error42);
    }
  }
  _onerror(error42) {
    var _a18;
    (_a18 = this.onerror) === null || _a18 === void 0 ? void 0 : _a18.call(this, error42);
  }
  _onnotification(notification) {
    var _a18;
    const handler = (_a18 = this._notificationHandlers.get(notification.method)) !== null && _a18 !== void 0 ? _a18 : this.fallbackNotificationHandler;
    if (handler === void 0) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error42) => this._onerror(new Error(`Uncaught error in notification handler: ${error42}`)));
  }
  _onrequest(request, extra) {
    var _a18, _b;
    const handler = (_a18 = this._requestHandlers.get(request.method)) !== null && _a18 !== void 0 ? _a18 : this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    if (handler === void 0) {
      capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      }).catch((error42) => this._onerror(new Error(`Failed to send an error response: ${error42}`)));
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
      _meta: (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta,
      sendNotification: /* @__PURE__ */ __name((notification) => this.notification(notification, { relatedRequestId: request.id }), "sendNotification"),
      sendRequest: /* @__PURE__ */ __name((r2, resultSchema, options) => this.request(r2, resultSchema, { ...options, relatedRequestId: request.id }), "sendRequest"),
      authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
      requestId: request.id,
      requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
    };
    Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {
      if (abortController.signal.aborted) {
        return;
      }
      return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
        result,
        jsonrpc: "2.0",
        id: request.id
      });
    }, (error42) => {
      var _a19;
      if (abortController.signal.aborted) {
        return;
      }
      return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error42["code"]) ? error42["code"] : ErrorCode.InternalError,
          message: (_a19 = error42.message) !== null && _a19 !== void 0 ? _a19 : "Internal error"
        }
      });
    }).catch((error42) => this._onerror(new Error(`Failed to send response: ${error42}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error42) {
        responseHandler(error42);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._progressHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    if (isJSONRPCResponse(response)) {
      handler(response);
    } else {
      const error42 = new McpError(response.error.code, response.error.message, response.error.data);
      handler(error42);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    var _a18;
    await ((_a18 = this._transport) === null || _a18 === void 0 ? void 0 : _a18.close());
  }
  /**
   * Sends a request and wait for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
    return new Promise((resolve, reject) => {
      var _a18, _b, _c, _d, _e, _f;
      if (!this._transport) {
        reject(new Error("Not connected"));
        return;
      }
      if (((_a18 = this._options) === null || _a18 === void 0 ? void 0 : _a18.enforceStrictCapabilities) === true) {
        this.assertCapabilityForMethod(request.method);
      }
      (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options === null || options === void 0 ? void 0 : options.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
            progressToken: messageId
          }
        };
      }
      const cancel = /* @__PURE__ */ __name((reason) => {
        var _a19;
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        (_a19 = this._transport) === null || _a19 === void 0 ? void 0 : _a19.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error42) => this._onerror(new Error(`Failed to send cancellation: ${error42}`)));
        reject(reason);
      }, "cancel");
      this._responseHandlers.set(messageId, (response) => {
        var _a19;
        if ((_a19 = options === null || options === void 0 ? void 0 : options.signal) === null || _a19 === void 0 ? void 0 : _a19.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const result = resultSchema.parse(response.result);
          resolve(result);
        } catch (error42) {
          reject(error42);
        }
      });
      (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.addEventListener("abort", () => {
        var _a19;
        cancel((_a19 = options === null || options === void 0 ? void 0 : options.signal) === null || _a19 === void 0 ? void 0 : _a19.reason);
      });
      const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = /* @__PURE__ */ __name(() => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout })), "timeoutHandler");
      this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
      this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error42) => {
        this._cleanupTimeout(messageId);
        reject(error42);
      });
    });
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    var _a18, _b;
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const debouncedMethods = (_b = (_a18 = this._options) === null || _a18 === void 0 ? void 0 : _a18.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId);
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        var _a19;
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        const jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        (_a19 = this._transport) === null || _a19 === void 0 ? void 0 : _a19.send(jsonrpcNotification2, options).catch((error42) => this._onerror(error42));
      });
      return;
    }
    const jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    const method = requestSchema.shape.method.value;
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      return Promise.resolve(handler(requestSchema.parse(request), extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
};
function mergeCapabilities(base, additional) {
  return Object.entries(additional).reduce((acc, [key, value]) => {
    if (value && typeof value === "object") {
      acc[key] = acc[key] ? { ...acc[key], ...value } : value;
    } else {
      acc[key] = value;
    }
    return acc;
  }, { ...base });
}
__name(mergeCapabilities, "mergeCapabilities");

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
var import_ajv = __toESM(require_ajv(), 1);
var Client = class extends Protocol {
  static {
    __name(this, "Client");
  }
  /**
   * Initializes this client with the given name and version information.
   */
  constructor(_clientInfo, options) {
    var _a18;
    super(options);
    this._clientInfo = _clientInfo;
    this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
    this._capabilities = (_a18 = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a18 !== void 0 ? _a18 : {};
    this._ajv = new import_ajv.default();
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  assertCapability(capability, method) {
    var _a18;
    if (!((_a18 = this._serverCapabilities) === null || _a18 === void 0 ? void 0 : _a18[capability])) {
      throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
  }
  async connect(transport, options) {
    await super.connect(transport);
    if (transport.sessionId !== void 0) {
      return;
    }
    try {
      const result = await this.request({
        method: "initialize",
        params: {
          protocolVersion: LATEST_PROTOCOL_VERSION,
          capabilities: this._capabilities,
          clientInfo: this._clientInfo
        }
      }, InitializeResultSchema2, options);
      if (result === void 0) {
        throw new Error(`Server sent invalid initialize result: ${result}`);
      }
      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
        throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
      }
      this._serverCapabilities = result.capabilities;
      this._serverVersion = result.serverInfo;
      if (transport.setProtocolVersion) {
        transport.setProtocolVersion(result.protocolVersion);
      }
      this._instructions = result.instructions;
      await this.notification({
        method: "notifications/initialized"
      });
    } catch (error42) {
      void this.close();
      throw error42;
    }
  }
  /**
   * After initialization has completed, this will be populated with the server's reported capabilities.
   */
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the server's name and version.
   */
  getServerVersion() {
    return this._serverVersion;
  }
  /**
   * After initialization has completed, this may be populated with information about the server's instructions.
   */
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(method) {
    var _a18, _b, _c, _d, _e;
    switch (method) {
      case "logging/setLevel":
        if (!((_a18 = this._serverCapabilities) === null || _a18 === void 0 ? void 0 : _a18.logging)) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
          throw new Error(`Server does not support resource subscriptions (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "completion/complete":
        if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
      case "initialize":
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    var _a18;
    switch (method) {
      case "notifications/roots/list_changed":
        if (!((_a18 = this._capabilities.roots) === null || _a18 === void 0 ? void 0 : _a18.listChanged)) {
          throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
        }
        break;
      case "notifications/initialized":
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Client does not support sampling capability (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._capabilities.elicitation) {
          throw new Error(`Client does not support elicitation capability (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._capabilities.roots) {
          throw new Error(`Client does not support roots capability (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  async ping(options) {
    return this.request({ method: "ping" }, EmptyResultSchema, options);
  }
  async complete(params, options) {
    return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
  }
  async setLoggingLevel(level, options) {
    return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
  }
  async getPrompt(params, options) {
    return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
  }
  async listPrompts(params, options) {
    return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
  }
  async listResources(params, options) {
    return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
  }
  async listResourceTemplates(params, options) {
    return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
  }
  async readResource(params, options) {
    return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
  }
  async subscribeResource(params, options) {
    return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
  }
  async unsubscribeResource(params, options) {
    return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
  }
  async callTool(params, resultSchema = CallToolResultSchema2, options) {
    const result = await this.request({ method: "tools/call", params }, resultSchema, options);
    const validator2 = this.getToolOutputValidator(params.name);
    if (validator2) {
      if (!result.structuredContent && !result.isError) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
      }
      if (result.structuredContent) {
        try {
          const isValid2 = validator2(result.structuredContent);
          if (!isValid2) {
            throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator2.errors)}`);
          }
        } catch (error42) {
          if (error42 instanceof McpError) {
            throw error42;
          }
          throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error42 instanceof Error ? error42.message : String(error42)}`);
        }
      }
    }
    return result;
  }
  cacheToolOutputSchemas(tools) {
    this._cachedToolOutputValidators.clear();
    for (const tool2 of tools) {
      if (tool2.outputSchema) {
        try {
          const validator2 = this._ajv.compile(tool2.outputSchema);
          this._cachedToolOutputValidators.set(tool2.name, validator2);
        } catch (_a18) {
        }
      }
    }
  }
  getToolOutputValidator(toolName) {
    return this._cachedToolOutputValidators.get(toolName);
  }
  async listTools(params, options) {
    const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema2, options);
    this.cacheToolOutputSchemas(result.tools);
    return result;
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/sse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/eventsource/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ErrorEvent = class extends Event {
  static {
    __name(this, "ErrorEvent");
  }
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(type, errorEventInitDict) {
    var _a18, _b;
    super(type), this.code = (_a18 = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a18 : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
    return inspect(inspectableError(this), options);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](inspect, options) {
    return inspect(inspectableError(this), options);
  }
};
function syntaxError(message) {
  const DomException = globalThis.DOMException;
  return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
__name(syntaxError, "syntaxError");
function flattenError2(err) {
  return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError2).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError2(err.cause)}` : err.message : `${err}`;
}
__name(flattenError2, "flattenError");
function inspectableError(err) {
  return {
    type: err.type,
    message: err.message,
    code: err.code,
    defaultPrevented: err.defaultPrevented,
    cancelable: err.cancelable,
    timeStamp: err.timeStamp
  };
}
__name(inspectableError, "inspectableError");
var __typeError = /* @__PURE__ */ __name((msg) => {
  throw TypeError(msg);
}, "__typeError");
var __accessCheck = /* @__PURE__ */ __name((obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), "__accessCheck");
var __privateGet = /* @__PURE__ */ __name((obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), "__privateGet");
var __privateAdd = /* @__PURE__ */ __name((obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), "__privateAdd");
var __privateSet = /* @__PURE__ */ __name((obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value), "__privateSet");
var __privateMethod = /* @__PURE__ */ __name((obj, member, method) => (__accessCheck(obj, member, "access private method"), method), "__privateMethod");
var _readyState;
var _url2;
var _redirectUrl;
var _withCredentials;
var _fetch;
var _reconnectInterval;
var _reconnectTimer;
var _lastEventId;
var _controller;
var _parser;
var _onError;
var _onMessage;
var _onOpen;
var _EventSource_instances;
var connect_fn;
var _onFetchResponse;
var _onFetchError;
var getRequestOptions_fn;
var _onEvent;
var _onRetryChange;
var failConnection_fn;
var scheduleReconnect_fn;
var _reconnect;
var EventSource = class extends EventTarget {
  static {
    __name(this, "EventSource");
  }
  constructor(url2, eventSourceInitDict) {
    var _a18, _b;
    super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url2), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response) => {
      var _a23;
      __privateGet(this, _parser).reset();
      const { body, redirected, status, headers } = response;
      if (status === 204) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
        return;
      }
      if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
        return;
      }
      if (__privateGet(this, _readyState) === this.CLOSED)
        return;
      __privateSet(this, _readyState, this.OPEN);
      const openEvent = new Event("open");
      if ((_a23 = __privateGet(this, _onOpen)) == null || _a23.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
        return;
      }
      const decoder = new TextDecoder(), reader = body.getReader();
      let open3 = true;
      do {
        const { done, value } = await reader.read();
        value && __privateGet(this, _parser).feed(decoder.decode(value, { stream: !done })), done && (open3 = false, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
      } while (open3);
    }), __privateAdd(this, _onFetchError, (err) => {
      __privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError2(err));
    }), __privateAdd(this, _onEvent, (event) => {
      typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
      const messageEvent = new MessageEvent(event.event || "message", {
        data: event.data,
        origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url2).origin,
        lastEventId: event.id || ""
      });
      __privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
    }), __privateAdd(this, _onRetryChange, (value) => {
      __privateSet(this, _reconnectInterval, value);
    }), __privateAdd(this, _reconnect, () => {
      __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    });
    try {
      if (url2 instanceof URL)
        __privateSet(this, _url2, url2);
      else if (typeof url2 == "string")
        __privateSet(this, _url2, new URL(url2, getBaseURL()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw syntaxError("An invalid or illegal string was specified");
    }
    __privateSet(this, _parser, createParser({
      onEvent: __privateGet(this, _onEvent),
      onRetry: __privateGet(this, _onRetryChange)
    })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a18 = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a18 : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : false), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return __privateGet(this, _readyState);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return __privateGet(this, _url2).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return __privateGet(this, _withCredentials);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return __privateGet(this, _onError);
  }
  set onerror(value) {
    __privateSet(this, _onError, value);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return __privateGet(this, _onMessage);
  }
  set onmessage(value) {
    __privateSet(this, _onMessage, value);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return __privateGet(this, _onOpen);
  }
  set onopen(value) {
    __privateSet(this, _onOpen, value);
  }
  addEventListener(type, listener, options) {
    const listen = listener;
    super.addEventListener(type, listen, options);
  }
  removeEventListener(type, listener, options) {
    const listen = listener;
    super.removeEventListener(type, listen, options);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
  }
};
_readyState = /* @__PURE__ */ new WeakMap(), _url2 = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
connect_fn = /* @__PURE__ */ __name(function() {
  __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url2), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
}, "connect_fn"), _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
getRequestOptions_fn = /* @__PURE__ */ __name(function() {
  var _a18;
  const init = {
    // [spec] Let `corsAttributeState` be `Anonymous`
    // [spec] will have their mode set to "cors"
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...__privateGet(this, _lastEventId) ? { "Last-Event-ID": __privateGet(this, _lastEventId) } : void 0 },
    cache: "no-store",
    signal: (_a18 = __privateGet(this, _controller)) == null ? void 0 : _a18.signal
  };
  return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, "getRequestOptions_fn"), _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
failConnection_fn = /* @__PURE__ */ __name(function(message, code) {
  var _a18;
  __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
  const errorEvent = new ErrorEvent("error", { code, message });
  (_a18 = __privateGet(this, _onError)) == null || _a18.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, "failConnection_fn"), /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
scheduleReconnect_fn = /* @__PURE__ */ __name(function(message, code) {
  var _a18;
  if (__privateGet(this, _readyState) === this.CLOSED)
    return;
  __privateSet(this, _readyState, this.CONNECTING);
  const errorEvent = new ErrorEvent("error", { code, message });
  (_a18 = __privateGet(this, _onError)) == null || _a18.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
}, "scheduleReconnect_fn"), _reconnect = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
EventSource.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
EventSource.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
EventSource.CLOSED = 2;
function getBaseURL() {
  const doc = "document" in globalThis ? globalThis.document : void 0;
  return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}
__name(getBaseURL, "getBaseURL");

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/pkce-challenge/dist/index.browser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var crypto2;
crypto2 = globalThis.crypto;
async function getRandomValues(size) {
  return (await crypto2).getRandomValues(new Uint8Array(size));
}
__name(getRandomValues, "getRandomValues");
async function random(size) {
  const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
  let result = "";
  const randomUints = await getRandomValues(size);
  for (let i2 = 0; i2 < size; i2++) {
    const randomIndex = randomUints[i2] % mask.length;
    result += mask[randomIndex];
  }
  return result;
}
__name(random, "random");
async function generateVerifier(length) {
  return await random(length);
}
__name(generateVerifier, "generateVerifier");
async function generateChallenge(code_verifier) {
  const buffer = await (await crypto2).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
  return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
__name(generateChallenge, "generateChallenge");
async function pkceChallenge(length) {
  if (!length)
    length = 43;
  if (length < 43 || length > 128) {
    throw `Expected a length between 43 and 128. Received ${length}.`;
  }
  const verifier = await generateVerifier(length);
  const challenge = await generateChallenge(verifier);
  return {
    code_verifier: verifier,
    code_challenge: challenge
  };
}
__name(pkceChallenge, "pkceChallenge");

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SafeUrlSchema = external_exports2.string().url().superRefine((val, ctx) => {
  if (!URL.canParse(val)) {
    ctx.addIssue({
      code: external_exports2.ZodIssueCode.custom,
      message: "URL must be parseable",
      fatal: true
    });
    return external_exports2.NEVER;
  }
}).refine((url2) => {
  const u2 = new URL(url2);
  return u2.protocol !== "javascript:" && u2.protocol !== "data:" && u2.protocol !== "vbscript:";
}, { message: "URL cannot use javascript:, data:, or vbscript: scheme" });
var OAuthProtectedResourceMetadataSchema = external_exports2.object({
  resource: external_exports2.string().url(),
  authorization_servers: external_exports2.array(SafeUrlSchema).optional(),
  jwks_uri: external_exports2.string().url().optional(),
  scopes_supported: external_exports2.array(external_exports2.string()).optional(),
  bearer_methods_supported: external_exports2.array(external_exports2.string()).optional(),
  resource_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  resource_name: external_exports2.string().optional(),
  resource_documentation: external_exports2.string().optional(),
  resource_policy_uri: external_exports2.string().url().optional(),
  resource_tos_uri: external_exports2.string().url().optional(),
  tls_client_certificate_bound_access_tokens: external_exports2.boolean().optional(),
  authorization_details_types_supported: external_exports2.array(external_exports2.string()).optional(),
  dpop_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  dpop_bound_access_tokens_required: external_exports2.boolean().optional()
}).passthrough();
var OAuthMetadataSchema = external_exports2.object({
  issuer: external_exports2.string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: external_exports2.array(external_exports2.string()).optional(),
  response_types_supported: external_exports2.array(external_exports2.string()),
  response_modes_supported: external_exports2.array(external_exports2.string()).optional(),
  grant_types_supported: external_exports2.array(external_exports2.string()).optional(),
  token_endpoint_auth_methods_supported: external_exports2.array(external_exports2.string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  service_documentation: SafeUrlSchema.optional(),
  revocation_endpoint: SafeUrlSchema.optional(),
  revocation_endpoint_auth_methods_supported: external_exports2.array(external_exports2.string()).optional(),
  revocation_endpoint_auth_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  introspection_endpoint: external_exports2.string().optional(),
  introspection_endpoint_auth_methods_supported: external_exports2.array(external_exports2.string()).optional(),
  introspection_endpoint_auth_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  code_challenge_methods_supported: external_exports2.array(external_exports2.string()).optional()
}).passthrough();
var OpenIdProviderMetadataSchema = external_exports2.object({
  issuer: external_exports2.string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  userinfo_endpoint: SafeUrlSchema.optional(),
  jwks_uri: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: external_exports2.array(external_exports2.string()).optional(),
  response_types_supported: external_exports2.array(external_exports2.string()),
  response_modes_supported: external_exports2.array(external_exports2.string()).optional(),
  grant_types_supported: external_exports2.array(external_exports2.string()).optional(),
  acr_values_supported: external_exports2.array(external_exports2.string()).optional(),
  subject_types_supported: external_exports2.array(external_exports2.string()),
  id_token_signing_alg_values_supported: external_exports2.array(external_exports2.string()),
  id_token_encryption_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  id_token_encryption_enc_values_supported: external_exports2.array(external_exports2.string()).optional(),
  userinfo_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  userinfo_encryption_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  userinfo_encryption_enc_values_supported: external_exports2.array(external_exports2.string()).optional(),
  request_object_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  request_object_encryption_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  request_object_encryption_enc_values_supported: external_exports2.array(external_exports2.string()).optional(),
  token_endpoint_auth_methods_supported: external_exports2.array(external_exports2.string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: external_exports2.array(external_exports2.string()).optional(),
  display_values_supported: external_exports2.array(external_exports2.string()).optional(),
  claim_types_supported: external_exports2.array(external_exports2.string()).optional(),
  claims_supported: external_exports2.array(external_exports2.string()).optional(),
  service_documentation: external_exports2.string().optional(),
  claims_locales_supported: external_exports2.array(external_exports2.string()).optional(),
  ui_locales_supported: external_exports2.array(external_exports2.string()).optional(),
  claims_parameter_supported: external_exports2.boolean().optional(),
  request_parameter_supported: external_exports2.boolean().optional(),
  request_uri_parameter_supported: external_exports2.boolean().optional(),
  require_request_uri_registration: external_exports2.boolean().optional(),
  op_policy_uri: SafeUrlSchema.optional(),
  op_tos_uri: SafeUrlSchema.optional()
}).passthrough();
var OpenIdProviderDiscoveryMetadataSchema = OpenIdProviderMetadataSchema.merge(OAuthMetadataSchema.pick({
  code_challenge_methods_supported: true
}));
var OAuthTokensSchema = external_exports2.object({
  access_token: external_exports2.string(),
  id_token: external_exports2.string().optional(),
  // Optional for OAuth 2.1, but necessary in OpenID Connect
  token_type: external_exports2.string(),
  expires_in: external_exports2.number().optional(),
  scope: external_exports2.string().optional(),
  refresh_token: external_exports2.string().optional()
}).strip();
var OAuthErrorResponseSchema = external_exports2.object({
  error: external_exports2.string(),
  error_description: external_exports2.string().optional(),
  error_uri: external_exports2.string().optional()
});
var OAuthClientMetadataSchema = external_exports2.object({
  redirect_uris: external_exports2.array(SafeUrlSchema),
  token_endpoint_auth_method: external_exports2.string().optional(),
  grant_types: external_exports2.array(external_exports2.string()).optional(),
  response_types: external_exports2.array(external_exports2.string()).optional(),
  client_name: external_exports2.string().optional(),
  client_uri: SafeUrlSchema.optional(),
  logo_uri: SafeUrlSchema.optional(),
  scope: external_exports2.string().optional(),
  contacts: external_exports2.array(external_exports2.string()).optional(),
  tos_uri: SafeUrlSchema.optional(),
  policy_uri: external_exports2.string().optional(),
  jwks_uri: SafeUrlSchema.optional(),
  jwks: external_exports2.any().optional(),
  software_id: external_exports2.string().optional(),
  software_version: external_exports2.string().optional(),
  software_statement: external_exports2.string().optional()
}).strip();
var OAuthClientInformationSchema = external_exports2.object({
  client_id: external_exports2.string(),
  client_secret: external_exports2.string().optional(),
  client_id_issued_at: external_exports2.number().optional(),
  client_secret_expires_at: external_exports2.number().optional()
}).strip();
var OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
var OAuthClientRegistrationErrorSchema = external_exports2.object({
  error: external_exports2.string(),
  error_description: external_exports2.string().optional()
}).strip();
var OAuthTokenRevocationRequestSchema = external_exports2.object({
  token: external_exports2.string(),
  token_type_hint: external_exports2.string().optional()
}).strip();

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth-utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function resourceUrlFromServerUrl(url2) {
  const resourceURL = typeof url2 === "string" ? new URL(url2) : new URL(url2.href);
  resourceURL.hash = "";
  return resourceURL;
}
__name(resourceUrlFromServerUrl, "resourceUrlFromServerUrl");
function checkResourceAllowed({ requestedResource, configuredResource }) {
  const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
  const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
  if (requested.origin !== configured.origin) {
    return false;
  }
  if (requested.pathname.length < configured.pathname.length) {
    return false;
  }
  const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
  const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
  return requestedPath.startsWith(configuredPath);
}
__name(checkResourceAllowed, "checkResourceAllowed");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/auth/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OAuthError = class extends Error {
  static {
    __name(this, "OAuthError");
  }
  constructor(message, errorUri) {
    super(message);
    this.errorUri = errorUri;
    this.name = this.constructor.name;
  }
  /**
   * Converts the error to a standard OAuth error response object
   */
  toResponseObject() {
    const response = {
      error: this.errorCode,
      error_description: this.message
    };
    if (this.errorUri) {
      response.error_uri = this.errorUri;
    }
    return response;
  }
  get errorCode() {
    return this.constructor.errorCode;
  }
};
var InvalidRequestError = class extends OAuthError {
  static {
    __name(this, "InvalidRequestError");
  }
};
InvalidRequestError.errorCode = "invalid_request";
var InvalidClientError = class extends OAuthError {
  static {
    __name(this, "InvalidClientError");
  }
};
InvalidClientError.errorCode = "invalid_client";
var InvalidGrantError = class extends OAuthError {
  static {
    __name(this, "InvalidGrantError");
  }
};
InvalidGrantError.errorCode = "invalid_grant";
var UnauthorizedClientError = class extends OAuthError {
  static {
    __name(this, "UnauthorizedClientError");
  }
};
UnauthorizedClientError.errorCode = "unauthorized_client";
var UnsupportedGrantTypeError = class extends OAuthError {
  static {
    __name(this, "UnsupportedGrantTypeError");
  }
};
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
var InvalidScopeError = class extends OAuthError {
  static {
    __name(this, "InvalidScopeError");
  }
};
InvalidScopeError.errorCode = "invalid_scope";
var AccessDeniedError = class extends OAuthError {
  static {
    __name(this, "AccessDeniedError");
  }
};
AccessDeniedError.errorCode = "access_denied";
var ServerError = class extends OAuthError {
  static {
    __name(this, "ServerError");
  }
};
ServerError.errorCode = "server_error";
var TemporarilyUnavailableError = class extends OAuthError {
  static {
    __name(this, "TemporarilyUnavailableError");
  }
};
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
var UnsupportedResponseTypeError = class extends OAuthError {
  static {
    __name(this, "UnsupportedResponseTypeError");
  }
};
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
var UnsupportedTokenTypeError = class extends OAuthError {
  static {
    __name(this, "UnsupportedTokenTypeError");
  }
};
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
var InvalidTokenError = class extends OAuthError {
  static {
    __name(this, "InvalidTokenError");
  }
};
InvalidTokenError.errorCode = "invalid_token";
var MethodNotAllowedError = class extends OAuthError {
  static {
    __name(this, "MethodNotAllowedError");
  }
};
MethodNotAllowedError.errorCode = "method_not_allowed";
var TooManyRequestsError = class extends OAuthError {
  static {
    __name(this, "TooManyRequestsError");
  }
};
TooManyRequestsError.errorCode = "too_many_requests";
var InvalidClientMetadataError = class extends OAuthError {
  static {
    __name(this, "InvalidClientMetadataError");
  }
};
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
var InsufficientScopeError = class extends OAuthError {
  static {
    __name(this, "InsufficientScopeError");
  }
};
InsufficientScopeError.errorCode = "insufficient_scope";
var OAUTH_ERRORS = {
  [InvalidRequestError.errorCode]: InvalidRequestError,
  [InvalidClientError.errorCode]: InvalidClientError,
  [InvalidGrantError.errorCode]: InvalidGrantError,
  [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
  [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
  [InvalidScopeError.errorCode]: InvalidScopeError,
  [AccessDeniedError.errorCode]: AccessDeniedError,
  [ServerError.errorCode]: ServerError,
  [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
  [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
  [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
  [InvalidTokenError.errorCode]: InvalidTokenError,
  [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
  [TooManyRequestsError.errorCode]: TooManyRequestsError,
  [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
  [InsufficientScopeError.errorCode]: InsufficientScopeError
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
var UnauthorizedError = class extends Error {
  static {
    __name(this, "UnauthorizedError");
  }
  constructor(message) {
    super(message !== null && message !== void 0 ? message : "Unauthorized");
  }
};
function selectClientAuthMethod(clientInformation, supportedMethods) {
  const hasClientSecret = clientInformation.client_secret !== void 0;
  if (supportedMethods.length === 0) {
    return hasClientSecret ? "client_secret_post" : "none";
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_basic")) {
    return "client_secret_basic";
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_post")) {
    return "client_secret_post";
  }
  if (supportedMethods.includes("none")) {
    return "none";
  }
  return hasClientSecret ? "client_secret_post" : "none";
}
__name(selectClientAuthMethod, "selectClientAuthMethod");
function applyClientAuthentication(method, clientInformation, headers, params) {
  const { client_id, client_secret } = clientInformation;
  switch (method) {
    case "client_secret_basic":
      applyBasicAuth(client_id, client_secret, headers);
      return;
    case "client_secret_post":
      applyPostAuth(client_id, client_secret, params);
      return;
    case "none":
      applyPublicAuth(client_id, params);
      return;
    default:
      throw new Error(`Unsupported client authentication method: ${method}`);
  }
}
__name(applyClientAuthentication, "applyClientAuthentication");
function applyBasicAuth(clientId, clientSecret, headers) {
  if (!clientSecret) {
    throw new Error("client_secret_basic authentication requires a client_secret");
  }
  const credentials = btoa(`${clientId}:${clientSecret}`);
  headers.set("Authorization", `Basic ${credentials}`);
}
__name(applyBasicAuth, "applyBasicAuth");
function applyPostAuth(clientId, clientSecret, params) {
  params.set("client_id", clientId);
  if (clientSecret) {
    params.set("client_secret", clientSecret);
  }
}
__name(applyPostAuth, "applyPostAuth");
function applyPublicAuth(clientId, params) {
  params.set("client_id", clientId);
}
__name(applyPublicAuth, "applyPublicAuth");
async function parseErrorResponse(input) {
  const statusCode = input instanceof Response ? input.status : void 0;
  const body = input instanceof Response ? await input.text() : input;
  try {
    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));
    const { error: error42, error_description, error_uri } = result;
    const errorClass = OAUTH_ERRORS[error42] || ServerError;
    return new errorClass(error_description || "", error_uri);
  } catch (error42) {
    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error42}. Raw body: ${body}`;
    return new ServerError(errorMessage);
  }
}
__name(parseErrorResponse, "parseErrorResponse");
async function auth(provider, options) {
  var _a18, _b;
  try {
    return await authInternal(provider, options);
  } catch (error42) {
    if (error42 instanceof InvalidClientError || error42 instanceof UnauthorizedClientError) {
      await ((_a18 = provider.invalidateCredentials) === null || _a18 === void 0 ? void 0 : _a18.call(provider, "all"));
      return await authInternal(provider, options);
    } else if (error42 instanceof InvalidGrantError) {
      await ((_b = provider.invalidateCredentials) === null || _b === void 0 ? void 0 : _b.call(provider, "tokens"));
      return await authInternal(provider, options);
    }
    throw error42;
  }
}
__name(auth, "auth");
async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
  let resourceMetadata;
  let authorizationServerUrl;
  try {
    resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);
    if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
      authorizationServerUrl = resourceMetadata.authorization_servers[0];
    }
  } catch (_a18) {
  }
  if (!authorizationServerUrl) {
    authorizationServerUrl = serverUrl;
  }
  const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
  const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {
    fetchFn
  });
  let clientInformation = await Promise.resolve(provider.clientInformation());
  if (!clientInformation) {
    if (authorizationCode !== void 0) {
      throw new Error("Existing OAuth client information is required when exchanging an authorization code");
    }
    if (!provider.saveClientInformation) {
      throw new Error("OAuth client information must be saveable for dynamic registration");
    }
    const fullInformation = await registerClient(authorizationServerUrl, {
      metadata,
      clientMetadata: provider.clientMetadata,
      fetchFn
    });
    await provider.saveClientInformation(fullInformation);
    clientInformation = fullInformation;
  }
  if (authorizationCode !== void 0) {
    const codeVerifier2 = await provider.codeVerifier();
    const tokens2 = await exchangeAuthorization(authorizationServerUrl, {
      metadata,
      clientInformation,
      authorizationCode,
      codeVerifier: codeVerifier2,
      redirectUri: provider.redirectUrl,
      resource,
      addClientAuthentication: provider.addClientAuthentication,
      fetchFn
    });
    await provider.saveTokens(tokens2);
    return "AUTHORIZED";
  }
  const tokens = await provider.tokens();
  if (tokens === null || tokens === void 0 ? void 0 : tokens.refresh_token) {
    try {
      const newTokens = await refreshAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        refreshToken: tokens.refresh_token,
        resource,
        addClientAuthentication: provider.addClientAuthentication,
        fetchFn
      });
      await provider.saveTokens(newTokens);
      return "AUTHORIZED";
    } catch (error42) {
      if (!(error42 instanceof OAuthError) || error42 instanceof ServerError) {
      } else {
        throw error42;
      }
    }
  }
  const state = provider.state ? await provider.state() : void 0;
  const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
    metadata,
    clientInformation,
    state,
    redirectUrl: provider.redirectUrl,
    scope: scope || provider.clientMetadata.scope,
    resource
  });
  await provider.saveCodeVerifier(codeVerifier);
  await provider.redirectToAuthorization(authorizationUrl);
  return "REDIRECT";
}
__name(authInternal, "authInternal");
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
  const defaultResource = resourceUrlFromServerUrl(serverUrl);
  if (provider.validateResourceURL) {
    return await provider.validateResourceURL(defaultResource, resourceMetadata === null || resourceMetadata === void 0 ? void 0 : resourceMetadata.resource);
  }
  if (!resourceMetadata) {
    return void 0;
  }
  if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {
    throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
  }
  return new URL(resourceMetadata.resource);
}
__name(selectResourceURL, "selectResourceURL");
function extractResourceMetadataUrl(res) {
  const authenticateHeader = res.headers.get("WWW-Authenticate");
  if (!authenticateHeader) {
    return void 0;
  }
  const [type, scheme] = authenticateHeader.split(" ");
  if (type.toLowerCase() !== "bearer" || !scheme) {
    return void 0;
  }
  const regex = /resource_metadata="([^"]*)"/;
  const match = regex.exec(authenticateHeader);
  if (!match) {
    return void 0;
  }
  try {
    return new URL(match[1]);
  } catch (_a18) {
    return void 0;
  }
}
__name(extractResourceMetadataUrl, "extractResourceMetadataUrl");
async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
  const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
    protocolVersion: opts === null || opts === void 0 ? void 0 : opts.protocolVersion,
    metadataUrl: opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl
  });
  if (!response || response.status === 404) {
    throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
  }
  if (!response.ok) {
    throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
  }
  return OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
__name(discoverOAuthProtectedResourceMetadata, "discoverOAuthProtectedResourceMetadata");
async function fetchWithCorsRetry(url2, headers, fetchFn = fetch) {
  try {
    return await fetchFn(url2, { headers });
  } catch (error42) {
    if (error42 instanceof TypeError) {
      if (headers) {
        return fetchWithCorsRetry(url2, void 0, fetchFn);
      } else {
        return void 0;
      }
    }
    throw error42;
  }
}
__name(fetchWithCorsRetry, "fetchWithCorsRetry");
function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
__name(buildWellKnownPath, "buildWellKnownPath");
async function tryMetadataDiscovery(url2, protocolVersion, fetchFn = fetch) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion
  };
  return await fetchWithCorsRetry(url2, headers, fetchFn);
}
__name(tryMetadataDiscovery, "tryMetadataDiscovery");
function shouldAttemptFallback(response, pathname) {
  return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
__name(shouldAttemptFallback, "shouldAttemptFallback");
async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
  var _a18, _b;
  const issuer = new URL(serverUrl);
  const protocolVersion = (_a18 = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a18 !== void 0 ? _a18 : LATEST_PROTOCOL_VERSION;
  let url2;
  if (opts === null || opts === void 0 ? void 0 : opts.metadataUrl) {
    url2 = new URL(opts.metadataUrl);
  } else {
    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
    url2 = new URL(wellKnownPath, (_b = opts === null || opts === void 0 ? void 0 : opts.metadataServerUrl) !== null && _b !== void 0 ? _b : issuer);
    url2.search = issuer.search;
  }
  let response = await tryMetadataDiscovery(url2, protocolVersion, fetchFn);
  if (!(opts === null || opts === void 0 ? void 0 : opts.metadataUrl) && shouldAttemptFallback(response, issuer.pathname)) {
    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
  }
  return response;
}
__name(discoverMetadataWithFallback, "discoverMetadataWithFallback");
function buildDiscoveryUrls(authorizationServerUrl) {
  const url2 = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
  const hasPath = url2.pathname !== "/";
  const urlsToTry = [];
  if (!hasPath) {
    urlsToTry.push({
      url: new URL("/.well-known/oauth-authorization-server", url2.origin),
      type: "oauth"
    });
    urlsToTry.push({
      url: new URL(`/.well-known/openid-configuration`, url2.origin),
      type: "oidc"
    });
    return urlsToTry;
  }
  let pathname = url2.pathname;
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  urlsToTry.push({
    url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url2.origin),
    type: "oauth"
  });
  urlsToTry.push({
    url: new URL("/.well-known/oauth-authorization-server", url2.origin),
    type: "oauth"
  });
  urlsToTry.push({
    url: new URL(`/.well-known/openid-configuration${pathname}`, url2.origin),
    type: "oidc"
  });
  urlsToTry.push({
    url: new URL(`${pathname}/.well-known/openid-configuration`, url2.origin),
    type: "oidc"
  });
  return urlsToTry;
}
__name(buildDiscoveryUrls, "buildDiscoveryUrls");
async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = LATEST_PROTOCOL_VERSION } = {}) {
  var _a18;
  const headers = { "MCP-Protocol-Version": protocolVersion };
  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
  for (const { url: endpointUrl, type } of urlsToTry) {
    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
    if (!response) {
      continue;
    }
    if (!response.ok) {
      if (response.status >= 400 && response.status < 500) {
        continue;
      }
      throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
    }
    if (type === "oauth") {
      return OAuthMetadataSchema.parse(await response.json());
    } else {
      const metadata = OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
      if (!((_a18 = metadata.code_challenge_methods_supported) === null || _a18 === void 0 ? void 0 : _a18.includes("S256"))) {
        throw new Error(`Incompatible OIDC provider at ${endpointUrl}: does not support S256 code challenge method required by MCP specification`);
      }
      return metadata;
    }
  }
  return void 0;
}
__name(discoverAuthorizationServerMetadata, "discoverAuthorizationServerMetadata");
async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
  const responseType = "code";
  const codeChallengeMethod = "S256";
  let authorizationUrl;
  if (metadata) {
    authorizationUrl = new URL(metadata.authorization_endpoint);
    if (!metadata.response_types_supported.includes(responseType)) {
      throw new Error(`Incompatible auth server: does not support response type ${responseType}`);
    }
    if (!metadata.code_challenge_methods_supported || !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)) {
      throw new Error(`Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`);
    }
  } else {
    authorizationUrl = new URL("/authorize", authorizationServerUrl);
  }
  const challenge = await pkceChallenge();
  const codeVerifier = challenge.code_verifier;
  const codeChallenge = challenge.code_challenge;
  authorizationUrl.searchParams.set("response_type", responseType);
  authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
  authorizationUrl.searchParams.set("code_challenge", codeChallenge);
  authorizationUrl.searchParams.set("code_challenge_method", codeChallengeMethod);
  authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
  if (state) {
    authorizationUrl.searchParams.set("state", state);
  }
  if (scope) {
    authorizationUrl.searchParams.set("scope", scope);
  }
  if (scope === null || scope === void 0 ? void 0 : scope.includes("offline_access")) {
    authorizationUrl.searchParams.append("prompt", "consent");
  }
  if (resource) {
    authorizationUrl.searchParams.set("resource", resource.href);
  }
  return { authorizationUrl, codeVerifier };
}
__name(startAuthorization, "startAuthorization");
async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri, resource, addClientAuthentication, fetchFn }) {
  var _a18;
  const grantType = "authorization_code";
  const tokenUrl = (metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint) ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
  if ((metadata === null || metadata === void 0 ? void 0 : metadata.grant_types_supported) && !metadata.grant_types_supported.includes(grantType)) {
    throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
  }
  const headers = new Headers({
    "Content-Type": "application/x-www-form-urlencoded",
    "Accept": "application/json"
  });
  const params = new URLSearchParams({
    grant_type: grantType,
    code: authorizationCode,
    code_verifier: codeVerifier,
    redirect_uri: String(redirectUri)
  });
  if (addClientAuthentication) {
    addClientAuthentication(headers, params, authorizationServerUrl, metadata);
  } else {
    const supportedMethods = (_a18 = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a18 !== void 0 ? _a18 : [];
    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
    applyClientAuthentication(authMethod, clientInformation, headers, params);
  }
  if (resource) {
    params.set("resource", resource.href);
  }
  const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
    method: "POST",
    headers,
    body: params
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthTokensSchema.parse(await response.json());
}
__name(exchangeAuthorization, "exchangeAuthorization");
async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
  var _a18;
  const grantType = "refresh_token";
  let tokenUrl;
  if (metadata) {
    tokenUrl = new URL(metadata.token_endpoint);
    if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {
      throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
    }
  } else {
    tokenUrl = new URL("/token", authorizationServerUrl);
  }
  const headers = new Headers({
    "Content-Type": "application/x-www-form-urlencoded"
  });
  const params = new URLSearchParams({
    grant_type: grantType,
    refresh_token: refreshToken
  });
  if (addClientAuthentication) {
    addClientAuthentication(headers, params, authorizationServerUrl, metadata);
  } else {
    const supportedMethods = (_a18 = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a18 !== void 0 ? _a18 : [];
    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
    applyClientAuthentication(authMethod, clientInformation, headers, params);
  }
  if (resource) {
    params.set("resource", resource.href);
  }
  const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
    method: "POST",
    headers,
    body: params
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthTokensSchema.parse({ refresh_token: refreshToken, ...await response.json() });
}
__name(refreshAuthorization, "refreshAuthorization");
async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
  let registrationUrl;
  if (metadata) {
    if (!metadata.registration_endpoint) {
      throw new Error("Incompatible auth server: does not support dynamic client registration");
    }
    registrationUrl = new URL(metadata.registration_endpoint);
  } else {
    registrationUrl = new URL("/register", authorizationServerUrl);
  }
  const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(registrationUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(clientMetadata)
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthClientInformationFullSchema.parse(await response.json());
}
__name(registerClient, "registerClient");

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/sse.js
var SseError = class extends Error {
  static {
    __name(this, "SseError");
  }
  constructor(code, message, event) {
    super(`SSE error: ${message}`);
    this.code = code;
    this.event = event;
  }
};
var SSEClientTransport = class {
  static {
    __name(this, "SSEClientTransport");
  }
  constructor(url2, opts) {
    this._url = url2;
    this._resourceMetadataUrl = void 0;
    this._eventSourceInit = opts === null || opts === void 0 ? void 0 : opts.eventSourceInit;
    this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
    this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
    this._fetch = opts === null || opts === void 0 ? void 0 : opts.fetch;
  }
  async _authThenStart() {
    var _a18;
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });
    } catch (error42) {
      (_a18 = this.onerror) === null || _a18 === void 0 ? void 0 : _a18.call(this, error42);
      throw error42;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuth();
  }
  async _commonHeaders() {
    var _a18;
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    return new Headers({ ...headers, ...(_a18 = this._requestInit) === null || _a18 === void 0 ? void 0 : _a18.headers });
  }
  _startOrAuth() {
    var _a18, _b, _c;
    const fetchImpl = (_c = (_b = (_a18 = this === null || this === void 0 ? void 0 : this._eventSourceInit) === null || _a18 === void 0 ? void 0 : _a18.fetch) !== null && _b !== void 0 ? _b : this._fetch) !== null && _c !== void 0 ? _c : fetch;
    return new Promise((resolve, reject) => {
      this._eventSource = new EventSource(this._url.href, {
        ...this._eventSourceInit,
        fetch: /* @__PURE__ */ __name(async (url2, init) => {
          const headers = await this._commonHeaders();
          headers.set("Accept", "text/event-stream");
          const response = await fetchImpl(url2, {
            ...init,
            headers
          });
          if (response.status === 401 && response.headers.has("www-authenticate")) {
            this._resourceMetadataUrl = extractResourceMetadataUrl(response);
          }
          return response;
        }, "fetch")
      });
      this._abortController = new AbortController();
      this._eventSource.onerror = (event) => {
        var _a19;
        if (event.code === 401 && this._authProvider) {
          this._authThenStart().then(resolve, reject);
          return;
        }
        const error42 = new SseError(event.code, event.message, event);
        reject(error42);
        (_a19 = this.onerror) === null || _a19 === void 0 ? void 0 : _a19.call(this, error42);
      };
      this._eventSource.onopen = () => {
      };
      this._eventSource.addEventListener("endpoint", (event) => {
        var _a19;
        const messageEvent = event;
        try {
          this._endpoint = new URL(messageEvent.data, this._url);
          if (this._endpoint.origin !== this._url.origin) {
            throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
          }
        } catch (error42) {
          reject(error42);
          (_a19 = this.onerror) === null || _a19 === void 0 ? void 0 : _a19.call(this, error42);
          void this.close();
          return;
        }
        resolve();
      });
      this._eventSource.onmessage = (event) => {
        var _a19, _b2;
        const messageEvent = event;
        let message;
        try {
          message = JSONRPCMessageSchema2.parse(JSON.parse(messageEvent.data));
        } catch (error42) {
          (_a19 = this.onerror) === null || _a19 === void 0 ? void 0 : _a19.call(this, error42);
          return;
        }
        (_b2 = this.onmessage) === null || _b2 === void 0 ? void 0 : _b2.call(this, message);
      };
    });
  }
  async start() {
    if (this._eventSource) {
      throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    return await this._startOrAuth();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, { serverUrl: this._url, authorizationCode, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    var _a18, _b, _c;
    (_a18 = this._abortController) === null || _a18 === void 0 ? void 0 : _a18.abort();
    (_b = this._eventSource) === null || _b === void 0 ? void 0 : _b.close();
    (_c = this.onclose) === null || _c === void 0 ? void 0 : _c.call(this);
  }
  async send(message) {
    var _a18, _b, _c;
    if (!this._endpoint) {
      throw new Error("Not connected");
    }
    try {
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: (_a18 = this._abortController) === null || _a18 === void 0 ? void 0 : _a18.signal
      };
      const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._endpoint, init);
      if (!response.ok) {
        if (response.status === 401 && this._authProvider) {
          this._resourceMetadataUrl = extractResourceMetadataUrl(response);
          const result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          return this.send(message);
        }
        const text2 = await response.text().catch(() => null);
        throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text2}`);
      }
    } catch (error42) {
      (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error42);
      throw error42;
    }
  }
  setProtocolVersion(version3) {
    this._protocolVersion = version3;
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
  initialReconnectionDelay: 1e3,
  maxReconnectionDelay: 3e4,
  reconnectionDelayGrowFactor: 1.5,
  maxRetries: 2
};
var StreamableHTTPError = class extends Error {
  static {
    __name(this, "StreamableHTTPError");
  }
  constructor(code, message) {
    super(`Streamable HTTP error: ${message}`);
    this.code = code;
  }
};
var StreamableHTTPClientTransport = class {
  static {
    __name(this, "StreamableHTTPClientTransport");
  }
  constructor(url2, opts) {
    var _a18;
    this._url = url2;
    this._resourceMetadataUrl = void 0;
    this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
    this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
    this._fetch = opts === null || opts === void 0 ? void 0 : opts.fetch;
    this._sessionId = opts === null || opts === void 0 ? void 0 : opts.sessionId;
    this._reconnectionOptions = (_a18 = opts === null || opts === void 0 ? void 0 : opts.reconnectionOptions) !== null && _a18 !== void 0 ? _a18 : DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
  }
  async _authThenStart() {
    var _a18;
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });
    } catch (error42) {
      (_a18 = this.onerror) === null || _a18 === void 0 ? void 0 : _a18.call(this, error42);
      throw error42;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuthSse({ resumptionToken: void 0 });
  }
  async _commonHeaders() {
    var _a18;
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._sessionId) {
      headers["mcp-session-id"] = this._sessionId;
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    const extraHeaders = this._normalizeHeaders((_a18 = this._requestInit) === null || _a18 === void 0 ? void 0 : _a18.headers);
    return new Headers({
      ...headers,
      ...extraHeaders
    });
  }
  async _startOrAuthSse(options) {
    var _a18, _b, _c;
    const { resumptionToken } = options;
    try {
      const headers = await this._commonHeaders();
      headers.set("Accept", "text/event-stream");
      if (resumptionToken) {
        headers.set("last-event-id", resumptionToken);
      }
      const response = await ((_a18 = this._fetch) !== null && _a18 !== void 0 ? _a18 : fetch)(this._url, {
        method: "GET",
        headers,
        signal: (_b = this._abortController) === null || _b === void 0 ? void 0 : _b.signal
      });
      if (!response.ok) {
        if (response.status === 401 && this._authProvider) {
          return await this._authThenStart();
        }
        if (response.status === 405) {
          return;
        }
        throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
      }
      this._handleSseStream(response.body, options, true);
    } catch (error42) {
      (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error42);
      throw error42;
    }
  }
  /**
   * Calculates the next reconnection delay using  backoff algorithm
   *
   * @param attempt Current reconnection attempt count for the specific stream
   * @returns Time to wait in milliseconds before next reconnection attempt
   */
  _getNextReconnectionDelay(attempt) {
    const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
    const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
    const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
    return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
  }
  _normalizeHeaders(headers) {
    if (!headers)
      return {};
    if (headers instanceof Headers) {
      return Object.fromEntries(headers.entries());
    }
    if (Array.isArray(headers)) {
      return Object.fromEntries(headers);
    }
    return { ...headers };
  }
  /**
   * Schedule a reconnection attempt with exponential backoff
   *
   * @param lastEventId The ID of the last received event for resumability
   * @param attemptCount Current reconnection attempt count for this specific stream
   */
  _scheduleReconnection(options, attemptCount = 0) {
    var _a18;
    const maxRetries = this._reconnectionOptions.maxRetries;
    if (maxRetries > 0 && attemptCount >= maxRetries) {
      (_a18 = this.onerror) === null || _a18 === void 0 ? void 0 : _a18.call(this, new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
      return;
    }
    const delay = this._getNextReconnectionDelay(attemptCount);
    setTimeout(() => {
      this._startOrAuthSse(options).catch((error42) => {
        var _a19;
        (_a19 = this.onerror) === null || _a19 === void 0 ? void 0 : _a19.call(this, new Error(`Failed to reconnect SSE stream: ${error42 instanceof Error ? error42.message : String(error42)}`));
        this._scheduleReconnection(options, attemptCount + 1);
      });
    }, delay);
  }
  _handleSseStream(stream, options, isReconnectable) {
    if (!stream) {
      return;
    }
    const { onresumptiontoken, replayMessageId } = options;
    let lastEventId;
    const processStream = /* @__PURE__ */ __name(async () => {
      var _a18, _b, _c, _d;
      try {
        const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).getReader();
        while (true) {
          const { value: event, done } = await reader.read();
          if (done) {
            break;
          }
          if (event.id) {
            lastEventId = event.id;
            onresumptiontoken === null || onresumptiontoken === void 0 ? void 0 : onresumptiontoken(event.id);
          }
          if (!event.event || event.event === "message") {
            try {
              const message = JSONRPCMessageSchema2.parse(JSON.parse(event.data));
              if (replayMessageId !== void 0 && isJSONRPCResponse(message)) {
                message.id = replayMessageId;
              }
              (_a18 = this.onmessage) === null || _a18 === void 0 ? void 0 : _a18.call(this, message);
            } catch (error42) {
              (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error42);
            }
          }
        }
      } catch (error42) {
        (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, new Error(`SSE stream disconnected: ${error42}`));
        if (isReconnectable && this._abortController && !this._abortController.signal.aborted) {
          try {
            this._scheduleReconnection({
              resumptionToken: lastEventId,
              onresumptiontoken,
              replayMessageId
            }, 0);
          } catch (error43) {
            (_d = this.onerror) === null || _d === void 0 ? void 0 : _d.call(this, new Error(`Failed to reconnect: ${error43 instanceof Error ? error43.message : String(error43)}`));
          }
        }
      }
    }, "processStream");
    processStream();
  }
  async start() {
    if (this._abortController) {
      throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    this._abortController = new AbortController();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, { serverUrl: this._url, authorizationCode, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    var _a18, _b;
    (_a18 = this._abortController) === null || _a18 === void 0 ? void 0 : _a18.abort();
    (_b = this.onclose) === null || _b === void 0 ? void 0 : _b.call(this);
  }
  async send(message, options) {
    var _a18, _b, _c, _d;
    try {
      const { resumptionToken, onresumptiontoken } = options || {};
      if (resumptionToken) {
        this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : void 0 }).catch((err) => {
          var _a19;
          return (_a19 = this.onerror) === null || _a19 === void 0 ? void 0 : _a19.call(this, err);
        });
        return;
      }
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      headers.set("accept", "application/json, text/event-stream");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: (_a18 = this._abortController) === null || _a18 === void 0 ? void 0 : _a18.signal
      };
      const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._url, init);
      const sessionId = response.headers.get("mcp-session-id");
      if (sessionId) {
        this._sessionId = sessionId;
      }
      if (!response.ok) {
        if (response.status === 401 && this._authProvider) {
          this._resourceMetadataUrl = extractResourceMetadataUrl(response);
          const result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          return this.send(message);
        }
        const text2 = await response.text().catch(() => null);
        throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text2}`);
      }
      if (response.status === 202) {
        if (isInitializedNotification(message)) {
          this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => {
            var _a19;
            return (_a19 = this.onerror) === null || _a19 === void 0 ? void 0 : _a19.call(this, err);
          });
        }
        return;
      }
      const messages = Array.isArray(message) ? message : [message];
      const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
      const contentType2 = response.headers.get("content-type");
      if (hasRequests) {
        if (contentType2 === null || contentType2 === void 0 ? void 0 : contentType2.includes("text/event-stream")) {
          this._handleSseStream(response.body, { onresumptiontoken }, false);
        } else if (contentType2 === null || contentType2 === void 0 ? void 0 : contentType2.includes("application/json")) {
          const data = await response.json();
          const responseMessages = Array.isArray(data) ? data.map((msg) => JSONRPCMessageSchema2.parse(msg)) : [JSONRPCMessageSchema2.parse(data)];
          for (const msg of responseMessages) {
            (_c = this.onmessage) === null || _c === void 0 ? void 0 : _c.call(this, msg);
          }
        } else {
          throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType2}`);
        }
      }
    } catch (error42) {
      (_d = this.onerror) === null || _d === void 0 ? void 0 : _d.call(this, error42);
      throw error42;
    }
  }
  get sessionId() {
    return this._sessionId;
  }
  /**
   * Terminates the current session by sending a DELETE request to the server.
   *
   * Clients that no longer need a particular session
   * (e.g., because the user is leaving the client application) SHOULD send an
   * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
   * terminate the session.
   *
   * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
   * the server does not allow clients to terminate sessions.
   */
  async terminateSession() {
    var _a18, _b, _c;
    if (!this._sessionId) {
      return;
    }
    try {
      const headers = await this._commonHeaders();
      const init = {
        ...this._requestInit,
        method: "DELETE",
        headers,
        signal: (_a18 = this._abortController) === null || _a18 === void 0 ? void 0 : _a18.signal
      };
      const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._url, init);
      if (!response.ok && response.status !== 405) {
        throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
      }
      this._sessionId = void 0;
    } catch (error42) {
      (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error42);
      throw error42;
    }
  }
  setProtocolVersion(version3) {
    this._protocolVersion = version3;
  }
  get protocolVersion() {
    return this._protocolVersion;
  }
};

// node_modules/agents/dist/chunk-MH46VMM4.js
var SSEEdgeClientTransport = class extends SSEClientTransport {
  static {
    __name(this, "SSEEdgeClientTransport");
  }
  /**
   * Creates a new EdgeSSEClientTransport, which overrides fetch to be compatible with the CF workers environment
   */
  constructor(url2, options) {
    const fetchOverride = /* @__PURE__ */ __name(async (fetchUrl, fetchInit = {}) => {
      const headers = await this.authHeaders();
      const workerOptions = {
        ...fetchInit,
        headers: {
          ...options.requestInit?.headers,
          ...fetchInit?.headers,
          ...headers
        }
      };
      delete workerOptions.mode;
      return options.eventSourceInit?.fetch?.(
        fetchUrl,
        // @ts-expect-error Expects FetchLikeInit from EventSource but is compatible with RequestInit
        workerOptions
      ) || fetch(fetchUrl, workerOptions);
    }, "fetchOverride");
    super(url2, {
      ...options,
      eventSourceInit: {
        ...options.eventSourceInit,
        fetch: fetchOverride
      }
    });
    this.authProvider = options.authProvider;
  }
  async authHeaders() {
    if (this.authProvider) {
      const tokens = await this.authProvider.tokens();
      if (tokens) {
        return {
          Authorization: `Bearer ${tokens.access_token}`
        };
      }
    }
  }
};
var StreamableHTTPEdgeClientTransport = class extends StreamableHTTPClientTransport {
  static {
    __name(this, "StreamableHTTPEdgeClientTransport");
  }
  /**
   * Creates a new StreamableHTTPEdgeClientTransport, which overrides fetch to be compatible with the CF workers environment
   */
  constructor(url2, options) {
    const fetchOverride = /* @__PURE__ */ __name(async (fetchUrl, fetchInit = {}) => {
      const headers = await this.authHeaders();
      const workerOptions = {
        ...fetchInit,
        headers: {
          ...options.requestInit?.headers,
          ...fetchInit?.headers,
          ...headers
        }
      };
      delete workerOptions.mode;
      return (
        // @ts-expect-error Custom fetch function for Cloudflare Workers compatibility
        options.requestInit?.fetch?.(
          fetchUrl,
          workerOptions
        ) || fetch(fetchUrl, workerOptions)
      );
    }, "fetchOverride");
    super(url2, {
      ...options,
      requestInit: {
        ...options.requestInit,
        // @ts-expect-error Custom fetch override for Cloudflare Workers
        fetch: fetchOverride
      }
    });
    this.authProvider = options.authProvider;
  }
  async authHeaders() {
    if (this.authProvider) {
      const tokens = await this.authProvider.tokens();
      if (tokens) {
        return {
          Authorization: `Bearer ${tokens.access_token}`
        };
      }
    }
  }
};
var MCPClientConnection = class {
  static {
    __name(this, "MCPClientConnection");
  }
  constructor(url2, info3, options = { client: {}, transport: {} }) {
    this.url = url2;
    this.options = options;
    this.connectionState = "connecting";
    this.tools = [];
    this.prompts = [];
    this.resources = [];
    this.resourceTemplates = [];
    const clientOptions = {
      ...options.client,
      capabilities: {
        ...options.client?.capabilities,
        elicitation: {}
      }
    };
    this.client = new Client(info3, clientOptions);
  }
  /**
   * Initialize a client connection
   *
   * @param code Optional OAuth code to initialize the connection with if auth hasn't been initialized
   * @returns
   */
  async init(code) {
    try {
      const transportType = this.options.transport.type || "streamable-http";
      await this.tryConnect(transportType, code);
    } catch (e) {
      if (e.toString().includes("Unauthorized")) {
        this.connectionState = "authenticating";
        return;
      }
      this.connectionState = "failed";
      throw e;
    }
    this.connectionState = "discovering";
    this.serverCapabilities = await this.client.getServerCapabilities();
    if (!this.serverCapabilities) {
      throw new Error("The MCP Server failed to return server capabilities");
    }
    const [
      instructionsResult,
      toolsResult,
      resourcesResult,
      promptsResult,
      resourceTemplatesResult
    ] = await Promise.allSettled([
      this.client.getInstructions(),
      this.registerTools(),
      this.registerResources(),
      this.registerPrompts(),
      this.registerResourceTemplates()
    ]);
    const operations = [
      { name: "instructions", result: instructionsResult },
      { name: "tools", result: toolsResult },
      { name: "resources", result: resourcesResult },
      { name: "prompts", result: promptsResult },
      { name: "resource templates", result: resourceTemplatesResult }
    ];
    for (const { name: name17, result } of operations) {
      if (result.status === "rejected") {
        console.error(`Failed to initialize ${name17}:`, result.reason);
      }
    }
    this.instructions = instructionsResult.status === "fulfilled" ? instructionsResult.value : void 0;
    this.tools = toolsResult.status === "fulfilled" ? toolsResult.value : [];
    this.resources = resourcesResult.status === "fulfilled" ? resourcesResult.value : [];
    this.prompts = promptsResult.status === "fulfilled" ? promptsResult.value : [];
    this.resourceTemplates = resourceTemplatesResult.status === "fulfilled" ? resourceTemplatesResult.value : [];
    this.connectionState = "ready";
  }
  /**
   * Notification handler registration
   */
  async registerTools() {
    if (!this.serverCapabilities || !this.serverCapabilities.tools) {
      return [];
    }
    if (this.serverCapabilities.tools.listChanged) {
      this.client.setNotificationHandler(
        ToolListChangedNotificationSchema,
        async (_notification) => {
          this.tools = await this.fetchTools();
        }
      );
    }
    return this.fetchTools();
  }
  async registerResources() {
    if (!this.serverCapabilities || !this.serverCapabilities.resources) {
      return [];
    }
    if (this.serverCapabilities.resources.listChanged) {
      this.client.setNotificationHandler(
        ResourceListChangedNotificationSchema,
        async (_notification) => {
          this.resources = await this.fetchResources();
        }
      );
    }
    return this.fetchResources();
  }
  async registerPrompts() {
    if (!this.serverCapabilities || !this.serverCapabilities.prompts) {
      return [];
    }
    if (this.serverCapabilities.prompts.listChanged) {
      this.client.setNotificationHandler(
        PromptListChangedNotificationSchema,
        async (_notification) => {
          this.prompts = await this.fetchPrompts();
        }
      );
    }
    return this.fetchPrompts();
  }
  async registerResourceTemplates() {
    if (!this.serverCapabilities || !this.serverCapabilities.resources) {
      return [];
    }
    return this.fetchResourceTemplates();
  }
  async fetchTools() {
    let toolsAgg = [];
    let toolsResult = { tools: [] };
    do {
      toolsResult = await this.client.listTools({
        cursor: toolsResult.nextCursor
      }).catch(capabilityErrorHandler({ tools: [] }, "tools/list"));
      toolsAgg = toolsAgg.concat(toolsResult.tools);
    } while (toolsResult.nextCursor);
    return toolsAgg;
  }
  async fetchResources() {
    let resourcesAgg = [];
    let resourcesResult = { resources: [] };
    do {
      resourcesResult = await this.client.listResources({
        cursor: resourcesResult.nextCursor
      }).catch(capabilityErrorHandler({ resources: [] }, "resources/list"));
      resourcesAgg = resourcesAgg.concat(resourcesResult.resources);
    } while (resourcesResult.nextCursor);
    return resourcesAgg;
  }
  async fetchPrompts() {
    let promptsAgg = [];
    let promptsResult = { prompts: [] };
    do {
      promptsResult = await this.client.listPrompts({
        cursor: promptsResult.nextCursor
      }).catch(capabilityErrorHandler({ prompts: [] }, "prompts/list"));
      promptsAgg = promptsAgg.concat(promptsResult.prompts);
    } while (promptsResult.nextCursor);
    return promptsAgg;
  }
  async fetchResourceTemplates() {
    let templatesAgg = [];
    let templatesResult = {
      resourceTemplates: []
    };
    do {
      templatesResult = await this.client.listResourceTemplates({
        cursor: templatesResult.nextCursor
      }).catch(
        capabilityErrorHandler(
          { resourceTemplates: [] },
          "resources/templates/list"
        )
      );
      templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);
    } while (templatesResult.nextCursor);
    return templatesAgg;
  }
  /**
   * Handle elicitation request from server
   * Automatically uses the Agent's built-in elicitation handling if available
   */
  async handleElicitationRequest(_request) {
    throw new Error(
      "Elicitation handler must be implemented for your platform. Override handleElicitationRequest method."
    );
  }
  /**
   * Get the transport for the client
   * @param transportType - The transport type to get
   * @returns The transport for the client
   */
  getTransport(transportType) {
    switch (transportType) {
      case "streamable-http":
        return new StreamableHTTPEdgeClientTransport(
          this.url,
          this.options.transport
        );
      case "sse":
        return new SSEEdgeClientTransport(
          this.url,
          this.options.transport
        );
      default:
        throw new Error(`Unsupported transport type: ${transportType}`);
    }
  }
  async tryConnect(transportType, code) {
    const transports = transportType === "auto" ? ["streamable-http", "sse"] : [transportType];
    for (const currentTransportType of transports) {
      const isLastTransport = currentTransportType === transports[transports.length - 1];
      const hasFallback = transportType === "auto" && currentTransportType === "streamable-http" && !isLastTransport;
      const transport = await this.getTransport(currentTransportType);
      if (code) {
        await transport.finishAuth(code);
      }
      try {
        await this.client.connect(transport);
        break;
      } catch (e) {
        const error42 = e instanceof Error ? e : new Error(String(e));
        if (hasFallback && (error42.message.includes("404") || error42.message.includes("405"))) {
          continue;
        }
        throw e;
      }
    }
    this.client.setRequestHandler(
      ElicitRequestSchema,
      async (request) => {
        return await this.handleElicitationRequest(request);
      }
    );
  }
};
function capabilityErrorHandler(empty, method) {
  return (e) => {
    if (e.code === -32601) {
      console.error(
        `The server advertised support for the capability ${method.split("/")[0]}, but returned "Method not found" for '${method}'.`
      );
      return empty;
    }
    throw e;
  };
}
__name(capabilityErrorHandler, "capabilityErrorHandler");
var MCPClientManager = class {
  static {
    __name(this, "MCPClientManager");
  }
  /**
   * @param _name Name of the MCP client
   * @param _version Version of the MCP Client
   * @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider
   */
  constructor(_name, _version) {
    this._name = _name;
    this._version = _version;
    this.mcpConnections = {};
    this._callbackUrls = [];
    this._didWarnAboutUnstableGetAITools = false;
  }
  /**
   * Connect to and register an MCP server
   *
   * @param transportConfig Transport config
   * @param clientConfig Client config
   * @param capabilities Client capabilities (i.e. if the client supports roots/sampling)
   */
  async connect(url2, options = {}) {
    const id = options.reconnect?.id ?? nanoid3(8);
    if (!options.transport?.authProvider) {
      console.warn(
        "No authProvider provided in the transport options. This client will only support unauthenticated remote MCP Servers"
      );
    } else {
      options.transport.authProvider.serverId = id;
      if (options.reconnect?.oauthClientId) {
        options.transport.authProvider.clientId = options.reconnect?.oauthClientId;
      }
    }
    this.mcpConnections[id] = new MCPClientConnection(
      new URL(url2),
      {
        name: this._name,
        version: this._version
      },
      {
        client: options.client ?? {},
        transport: options.transport ?? {}
      }
    );
    await this.mcpConnections[id].init(options.reconnect?.oauthCode);
    const authUrl = options.transport?.authProvider?.authUrl;
    if (authUrl && options.transport?.authProvider?.redirectUrl) {
      this._callbackUrls.push(
        options.transport.authProvider.redirectUrl.toString()
      );
      return {
        authUrl,
        clientId: options.transport?.authProvider?.clientId,
        id
      };
    }
    return {
      id
    };
  }
  isCallbackRequest(req) {
    return req.method === "GET" && !!this._callbackUrls.find((url2) => {
      return req.url.startsWith(url2);
    });
  }
  async handleCallbackRequest(req) {
    const url2 = new URL(req.url);
    const urlMatch = this._callbackUrls.find((url22) => {
      return req.url.startsWith(url22);
    });
    if (!urlMatch) {
      throw new Error(
        `No callback URI match found for the request url: ${req.url}. Was the request matched with \`isCallbackRequest()\`?`
      );
    }
    const code = url2.searchParams.get("code");
    const clientId = url2.searchParams.get("state");
    const urlParams = urlMatch.split("/");
    const serverId = urlParams[urlParams.length - 1];
    if (!code) {
      throw new Error("Unauthorized: no code provided");
    }
    if (!clientId) {
      throw new Error("Unauthorized: no state provided");
    }
    if (this.mcpConnections[serverId] === void 0) {
      throw new Error(`Could not find serverId: ${serverId}`);
    }
    if (this.mcpConnections[serverId].connectionState !== "authenticating") {
      throw new Error(
        "Failed to authenticate: the client isn't in the `authenticating` state"
      );
    }
    const conn = this.mcpConnections[serverId];
    if (!conn.options.transport.authProvider) {
      throw new Error(
        "Trying to finalize authentication for a server connection without an authProvider"
      );
    }
    conn.options.transport.authProvider.clientId = clientId;
    conn.options.transport.authProvider.serverId = serverId;
    const serverUrl = conn.url.toString();
    await this.connect(serverUrl, {
      reconnect: {
        id: serverId,
        oauthClientId: clientId,
        oauthCode: code
      },
      ...conn.options
    });
    if (this.mcpConnections[serverId].connectionState === "authenticating") {
      throw new Error("Failed to authenticate: client failed to initialize");
    }
    return { serverId };
  }
  /**
   * @returns namespaced list of tools
   */
  listTools() {
    return getNamespacedData(this.mcpConnections, "tools");
  }
  /**
   * @returns a set of tools that you can use with the AI SDK
   */
  getAITools() {
    return Object.fromEntries(
      getNamespacedData(this.mcpConnections, "tools").map((tool2) => {
        return [
          `tool_${tool2.serverId}_${tool2.name}`,
          {
            description: tool2.description,
            execute: /* @__PURE__ */ __name(async (args) => {
              const result = await this.callTool({
                arguments: args,
                name: tool2.name,
                serverId: tool2.serverId
              });
              if (result.isError) {
                throw new Error(result.content[0].text);
              }
              return result;
            }, "execute"),
            inputSchema: jsonSchema(tool2.inputSchema)
          }
        ];
      })
    );
  }
  /**
   * @deprecated this has been renamed to getAITools(), and unstable_getAITools will be removed in the next major version
   * @returns a set of tools that you can use with the AI SDK
   */
  unstable_getAITools() {
    if (!this._didWarnAboutUnstableGetAITools) {
      this._didWarnAboutUnstableGetAITools = true;
      console.warn(
        "unstable_getAITools is deprecated, use getAITools instead. unstable_getAITools will be removed in the next major version."
      );
    }
    return this.getAITools();
  }
  /**
   * Closes all connections to MCP servers
   */
  async closeAllConnections() {
    return Promise.all(
      Object.values(this.mcpConnections).map(async (connection) => {
        await connection.client.close();
      })
    );
  }
  /**
   * Closes a connection to an MCP server
   * @param id The id of the connection to close
   */
  async closeConnection(id) {
    if (!this.mcpConnections[id]) {
      throw new Error(`Connection with id "${id}" does not exist.`);
    }
    await this.mcpConnections[id].client.close();
    delete this.mcpConnections[id];
  }
  /**
   * @returns namespaced list of prompts
   */
  listPrompts() {
    return getNamespacedData(this.mcpConnections, "prompts");
  }
  /**
   * @returns namespaced list of tools
   */
  listResources() {
    return getNamespacedData(this.mcpConnections, "resources");
  }
  /**
   * @returns namespaced list of resource templates
   */
  listResourceTemplates() {
    return getNamespacedData(this.mcpConnections, "resourceTemplates");
  }
  /**
   * Namespaced version of callTool
   */
  callTool(params, resultSchema, options) {
    const unqualifiedName = params.name.replace(`${params.serverId}.`, "");
    return this.mcpConnections[params.serverId].client.callTool(
      {
        ...params,
        name: unqualifiedName
      },
      resultSchema,
      options
    );
  }
  /**
   * Namespaced version of readResource
   */
  readResource(params, options) {
    return this.mcpConnections[params.serverId].client.readResource(
      params,
      options
    );
  }
  /**
   * Namespaced version of getPrompt
   */
  getPrompt(params, options) {
    return this.mcpConnections[params.serverId].client.getPrompt(
      params,
      options
    );
  }
};
function getNamespacedData(mcpClients, type) {
  const sets = Object.entries(mcpClients).map(([name17, conn]) => {
    return { data: conn[type], name: name17 };
  });
  const namespacedData = sets.flatMap(({ name: serverId, data }) => {
    return data.map((item) => {
      return {
        ...item,
        // we add a serverId so we can easily pull it out and send the tool call to the right server
        serverId
      };
    });
  });
  return namespacedData;
}
__name(getNamespacedData, "getNamespacedData");

// node_modules/agents/dist/chunk-LL2AFX7V.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DurableObjectOAuthClientProvider = class {
  static {
    __name(this, "DurableObjectOAuthClientProvider");
  }
  constructor(storage, clientName, baseRedirectUrl) {
    this.storage = storage;
    this.clientName = clientName;
    this.baseRedirectUrl = baseRedirectUrl;
  }
  get clientMetadata() {
    return {
      client_name: this.clientName,
      client_uri: this.clientUri,
      grant_types: ["authorization_code", "refresh_token"],
      redirect_uris: [this.redirectUrl],
      response_types: ["code"],
      token_endpoint_auth_method: "none"
    };
  }
  get clientUri() {
    return new URL(this.redirectUrl).origin;
  }
  get redirectUrl() {
    return `${this.baseRedirectUrl}/${this.serverId}`;
  }
  get clientId() {
    if (!this._clientId_) {
      throw new Error("Trying to access clientId before it was set");
    }
    return this._clientId_;
  }
  set clientId(clientId_) {
    this._clientId_ = clientId_;
  }
  get serverId() {
    if (!this._serverId_) {
      throw new Error("Trying to access serverId before it was set");
    }
    return this._serverId_;
  }
  set serverId(serverId_) {
    this._serverId_ = serverId_;
  }
  keyPrefix(clientId) {
    return `/${this.clientName}/${this.serverId}/${clientId}`;
  }
  clientInfoKey(clientId) {
    return `${this.keyPrefix(clientId)}/client_info/`;
  }
  async clientInformation() {
    if (!this._clientId_) {
      return void 0;
    }
    return await this.storage.get(
      this.clientInfoKey(this.clientId)
    ) ?? void 0;
  }
  async saveClientInformation(clientInformation) {
    await this.storage.put(
      this.clientInfoKey(clientInformation.client_id),
      clientInformation
    );
    this.clientId = clientInformation.client_id;
  }
  tokenKey(clientId) {
    return `${this.keyPrefix(clientId)}/token`;
  }
  async tokens() {
    if (!this._clientId_) {
      return void 0;
    }
    return await this.storage.get(this.tokenKey(this.clientId)) ?? void 0;
  }
  async saveTokens(tokens) {
    await this.storage.put(this.tokenKey(this.clientId), tokens);
  }
  get authUrl() {
    return this._authUrl_;
  }
  /**
   * Because this operates on the server side (but we need browser auth), we send this url back to the user
   * and require user interact to initiate the redirect flow
   */
  async redirectToAuthorization(authUrl) {
    const client_id = authUrl.searchParams.get("client_id");
    if (client_id) {
      authUrl.searchParams.append("state", client_id);
    }
    this._authUrl_ = authUrl.toString();
  }
  codeVerifierKey(clientId) {
    return `${this.keyPrefix(clientId)}/code_verifier`;
  }
  async saveCodeVerifier(verifier) {
    await this.storage.put(this.codeVerifierKey(this.clientId), verifier);
  }
  async codeVerifier() {
    const codeVerifier = await this.storage.get(
      this.codeVerifierKey(this.clientId)
    );
    if (!codeVerifier) {
      throw new Error("No code verifier found");
    }
    return codeVerifier;
  }
};

// node_modules/agents/dist/chunk-QEVM4BVL.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/partysocket/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/partysocket/dist/chunk-NLWAO4PP.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/partysocket/dist/chunk-ZCZZNAX5.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
if (!globalThis.EventTarget || !globalThis.Event) {
  console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
}
var _a17;
var isNode = typeof process !== "undefined" && typeof ((_a17 = process.versions) == null ? void 0 : _a17.node) !== "undefined" && typeof document === "undefined";
var DEFAULT = {
  maxReconnectionDelay: 1e4,
  minReconnectionDelay: 1e3 + Math.random() * 4e3,
  minUptime: 5e3,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4e3,
  maxRetries: Number.POSITIVE_INFINITY,
  maxEnqueuedMessages: Number.POSITIVE_INFINITY,
  startClosed: false,
  debug: false
};

// node_modules/agents/dist/chunk-QEVM4BVL.js
function camelCaseToKebabCase(str) {
  if (str === str.toUpperCase() && str !== str.toLowerCase()) {
    return str.toLowerCase().replace(/_/g, "-");
  }
  let kebabified = str.replace(
    /[A-Z]/g,
    (letter) => `-${letter.toLowerCase()}`
  );
  kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
  return kebabified.replace(/_/g, "-").replace(/-$/, "");
}
__name(camelCaseToKebabCase, "camelCaseToKebabCase");

// node_modules/agents/dist/chunk-YDUDMOL6.js
import { AsyncLocalStorage } from "async_hooks";

// node_modules/cron-schedule/dist/cron-parser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/cron-schedule/dist/cron.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/cron-schedule/dist/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function extractDateElements(date5) {
  return {
    second: date5.getSeconds(),
    minute: date5.getMinutes(),
    hour: date5.getHours(),
    day: date5.getDate(),
    month: date5.getMonth(),
    weekday: date5.getDay(),
    year: date5.getFullYear()
  };
}
__name(extractDateElements, "extractDateElements");
function getDaysInMonth(year, month) {
  return new Date(year, month + 1, 0).getDate();
}
__name(getDaysInMonth, "getDaysInMonth");
function getDaysBetweenWeekdays(weekday1, weekday2) {
  if (weekday1 <= weekday2) {
    return weekday2 - weekday1;
  }
  return 6 - weekday1 + weekday2 + 1;
}
__name(getDaysBetweenWeekdays, "getDaysBetweenWeekdays");

// node_modules/cron-schedule/dist/cron.js
var Cron = class {
  static {
    __name(this, "Cron");
  }
  constructor({ seconds, minutes, hours, days, months, weekdays }) {
    if (!seconds || seconds.size === 0)
      throw new Error("There must be at least one allowed second.");
    if (!minutes || minutes.size === 0)
      throw new Error("There must be at least one allowed minute.");
    if (!hours || hours.size === 0)
      throw new Error("There must be at least one allowed hour.");
    if (!months || months.size === 0)
      throw new Error("There must be at least one allowed month.");
    if ((!weekdays || weekdays.size === 0) && (!days || days.size === 0))
      throw new Error("There must be at least one allowed day or weekday.");
    this.seconds = Array.from(seconds).sort((a2, b) => a2 - b);
    this.minutes = Array.from(minutes).sort((a2, b) => a2 - b);
    this.hours = Array.from(hours).sort((a2, b) => a2 - b);
    this.days = Array.from(days).sort((a2, b) => a2 - b);
    this.months = Array.from(months).sort((a2, b) => a2 - b);
    this.weekdays = Array.from(weekdays).sort((a2, b) => a2 - b);
    const validateData = /* @__PURE__ */ __name((name17, data, constraint) => {
      if (data.some((x) => typeof x !== "number" || x % 1 !== 0 || x < constraint.min || x > constraint.max)) {
        throw new Error(`${name17} must only consist of integers which are within the range of ${constraint.min} and ${constraint.max}`);
      }
    }, "validateData");
    validateData("seconds", this.seconds, { min: 0, max: 59 });
    validateData("minutes", this.minutes, { min: 0, max: 59 });
    validateData("hours", this.hours, { min: 0, max: 23 });
    validateData("days", this.days, { min: 1, max: 31 });
    validateData("months", this.months, { min: 0, max: 11 });
    validateData("weekdays", this.weekdays, { min: 0, max: 6 });
    this.reversed = {
      seconds: this.seconds.map((x) => x).reverse(),
      minutes: this.minutes.map((x) => x).reverse(),
      hours: this.hours.map((x) => x).reverse(),
      days: this.days.map((x) => x).reverse(),
      months: this.months.map((x) => x).reverse(),
      weekdays: this.weekdays.map((x) => x).reverse()
    };
  }
  /**
   * Find the next or previous hour, starting from the given start hour that matches the hour constraint.
   * startHour itself might also be allowed.
   */
  findAllowedHour(dir3, startHour) {
    return dir3 === "next" ? this.hours.find((x) => x >= startHour) : this.reversed.hours.find((x) => x <= startHour);
  }
  /**
   * Find the next or previous minute, starting from the given start minute that matches the minute constraint.
   * startMinute itself might also be allowed.
   */
  findAllowedMinute(dir3, startMinute) {
    return dir3 === "next" ? this.minutes.find((x) => x >= startMinute) : this.reversed.minutes.find((x) => x <= startMinute);
  }
  /**
   * Find the next or previous second, starting from the given start second that matches the second constraint.
   * startSecond itself IS NOT allowed.
   */
  findAllowedSecond(dir3, startSecond) {
    return dir3 === "next" ? this.seconds.find((x) => x > startSecond) : this.reversed.seconds.find((x) => x < startSecond);
  }
  /**
   * Find the next or previous time, starting from the given start time that matches the hour, minute
   * and second constraints. startTime itself might also be allowed.
   */
  findAllowedTime(dir3, startTime) {
    let hour = this.findAllowedHour(dir3, startTime.hour);
    if (hour !== void 0) {
      if (hour === startTime.hour) {
        let minute = this.findAllowedMinute(dir3, startTime.minute);
        if (minute !== void 0) {
          if (minute === startTime.minute) {
            const second = this.findAllowedSecond(dir3, startTime.second);
            if (second !== void 0) {
              return { hour, minute, second };
            }
            minute = this.findAllowedMinute(dir3, dir3 === "next" ? startTime.minute + 1 : startTime.minute - 1);
            if (minute !== void 0) {
              return {
                hour,
                minute,
                second: dir3 === "next" ? this.seconds[0] : this.reversed.seconds[0]
              };
            }
          } else {
            return {
              hour,
              minute,
              second: dir3 === "next" ? this.seconds[0] : this.reversed.seconds[0]
            };
          }
        }
        hour = this.findAllowedHour(dir3, dir3 === "next" ? startTime.hour + 1 : startTime.hour - 1);
        if (hour !== void 0) {
          return {
            hour,
            minute: dir3 === "next" ? this.minutes[0] : this.reversed.minutes[0],
            second: dir3 === "next" ? this.seconds[0] : this.reversed.seconds[0]
          };
        }
      } else {
        return {
          hour,
          minute: dir3 === "next" ? this.minutes[0] : this.reversed.minutes[0],
          second: dir3 === "next" ? this.seconds[0] : this.reversed.seconds[0]
        };
      }
    }
    return void 0;
  }
  /**
   * Find the next or previous day in the given month, starting from the given startDay
   * that matches either the day or the weekday constraint. startDay itself might also be allowed.
   */
  findAllowedDayInMonth(dir3, year, month, startDay) {
    var _a18, _b;
    if (startDay < 1)
      throw new Error("startDay must not be smaller than 1.");
    const daysInMonth = getDaysInMonth(year, month);
    const daysRestricted = this.days.length !== 31;
    const weekdaysRestricted = this.weekdays.length !== 7;
    if (!daysRestricted && !weekdaysRestricted) {
      if (startDay > daysInMonth) {
        return dir3 === "next" ? void 0 : daysInMonth;
      }
      return startDay;
    }
    let allowedDayByDays;
    if (daysRestricted) {
      allowedDayByDays = dir3 === "next" ? this.days.find((x) => x >= startDay) : this.reversed.days.find((x) => x <= startDay);
      if (allowedDayByDays !== void 0 && allowedDayByDays > daysInMonth) {
        allowedDayByDays = void 0;
      }
    }
    let allowedDayByWeekdays;
    if (weekdaysRestricted) {
      const startWeekday = new Date(year, month, startDay).getDay();
      const nearestAllowedWeekday = dir3 === "next" ? (_a18 = this.weekdays.find((x) => x >= startWeekday)) !== null && _a18 !== void 0 ? _a18 : this.weekdays[0] : (_b = this.reversed.weekdays.find((x) => x <= startWeekday)) !== null && _b !== void 0 ? _b : this.reversed.weekdays[0];
      if (nearestAllowedWeekday !== void 0) {
        const daysBetweenWeekdays = dir3 === "next" ? getDaysBetweenWeekdays(startWeekday, nearestAllowedWeekday) : getDaysBetweenWeekdays(nearestAllowedWeekday, startWeekday);
        allowedDayByWeekdays = dir3 === "next" ? startDay + daysBetweenWeekdays : startDay - daysBetweenWeekdays;
        if (allowedDayByWeekdays > daysInMonth || allowedDayByWeekdays < 1) {
          allowedDayByWeekdays = void 0;
        }
      }
    }
    if (allowedDayByDays !== void 0 && allowedDayByWeekdays !== void 0) {
      return dir3 === "next" ? Math.min(allowedDayByDays, allowedDayByWeekdays) : Math.max(allowedDayByDays, allowedDayByWeekdays);
    }
    if (allowedDayByDays !== void 0) {
      return allowedDayByDays;
    }
    if (allowedDayByWeekdays !== void 0) {
      return allowedDayByWeekdays;
    }
    return void 0;
  }
  /** Gets the next date starting from the given start date or now. */
  getNextDate(startDate = /* @__PURE__ */ new Date()) {
    const startDateElements = extractDateElements(startDate);
    let minYear = startDateElements.year;
    let startIndexMonth = this.months.findIndex((x) => x >= startDateElements.month);
    if (startIndexMonth === -1) {
      startIndexMonth = 0;
      minYear++;
    }
    const maxIterations = this.months.length * 5;
    for (let i2 = 0; i2 < maxIterations; i2++) {
      const year = minYear + Math.floor((startIndexMonth + i2) / this.months.length);
      const month = this.months[(startIndexMonth + i2) % this.months.length];
      const isStartMonth = year === startDateElements.year && month === startDateElements.month;
      let day = this.findAllowedDayInMonth("next", year, month, isStartMonth ? startDateElements.day : 1);
      let isStartDay = isStartMonth && day === startDateElements.day;
      if (day !== void 0 && isStartDay) {
        const nextTime = this.findAllowedTime("next", startDateElements);
        if (nextTime !== void 0) {
          return new Date(year, month, day, nextTime.hour, nextTime.minute, nextTime.second);
        }
        day = this.findAllowedDayInMonth("next", year, month, day + 1);
        isStartDay = false;
      }
      if (day !== void 0 && !isStartDay) {
        return new Date(year, month, day, this.hours[0], this.minutes[0], this.seconds[0]);
      }
    }
    throw new Error("No valid next date was found.");
  }
  /** Gets the specified amount of future dates starting from the given start date or now. */
  getNextDates(amount, startDate) {
    const dates = [];
    let nextDate;
    for (let i2 = 0; i2 < amount; i2++) {
      nextDate = this.getNextDate(nextDate !== null && nextDate !== void 0 ? nextDate : startDate);
      dates.push(nextDate);
    }
    return dates;
  }
  /**
   * Get an ES6 compatible iterator which iterates over the next dates starting from startDate or now.
   * The iterator runs until the optional endDate is reached or forever.
   */
  *getNextDatesIterator(startDate, endDate) {
    let nextDate;
    while (true) {
      nextDate = this.getNextDate(nextDate !== null && nextDate !== void 0 ? nextDate : startDate);
      if (endDate && endDate.getTime() < nextDate.getTime()) {
        return;
      }
      yield nextDate;
    }
  }
  /** Gets the previous date starting from the given start date or now. */
  getPrevDate(startDate = /* @__PURE__ */ new Date()) {
    const startDateElements = extractDateElements(startDate);
    let maxYear = startDateElements.year;
    let startIndexMonth = this.reversed.months.findIndex((x) => x <= startDateElements.month);
    if (startIndexMonth === -1) {
      startIndexMonth = 0;
      maxYear--;
    }
    const maxIterations = this.reversed.months.length * 5;
    for (let i2 = 0; i2 < maxIterations; i2++) {
      const year = maxYear - Math.floor((startIndexMonth + i2) / this.reversed.months.length);
      const month = this.reversed.months[(startIndexMonth + i2) % this.reversed.months.length];
      const isStartMonth = year === startDateElements.year && month === startDateElements.month;
      let day = this.findAllowedDayInMonth("prev", year, month, isStartMonth ? startDateElements.day : (
        // Start searching from the last day of the month.
        getDaysInMonth(year, month)
      ));
      let isStartDay = isStartMonth && day === startDateElements.day;
      if (day !== void 0 && isStartDay) {
        const prevTime = this.findAllowedTime("prev", startDateElements);
        if (prevTime !== void 0) {
          return new Date(year, month, day, prevTime.hour, prevTime.minute, prevTime.second);
        }
        if (day > 1) {
          day = this.findAllowedDayInMonth("prev", year, month, day - 1);
          isStartDay = false;
        }
      }
      if (day !== void 0 && !isStartDay) {
        return new Date(year, month, day, this.reversed.hours[0], this.reversed.minutes[0], this.reversed.seconds[0]);
      }
    }
    throw new Error("No valid previous date was found.");
  }
  /** Gets the specified amount of previous dates starting from the given start date or now. */
  getPrevDates(amount, startDate) {
    const dates = [];
    let prevDate;
    for (let i2 = 0; i2 < amount; i2++) {
      prevDate = this.getPrevDate(prevDate !== null && prevDate !== void 0 ? prevDate : startDate);
      dates.push(prevDate);
    }
    return dates;
  }
  /**
   * Get an ES6 compatible iterator which iterates over the previous dates starting from startDate or now.
   * The iterator runs until the optional endDate is reached or forever.
   */
  *getPrevDatesIterator(startDate, endDate) {
    let prevDate;
    while (true) {
      prevDate = this.getPrevDate(prevDate !== null && prevDate !== void 0 ? prevDate : startDate);
      if (endDate && endDate.getTime() > prevDate.getTime()) {
        return;
      }
      yield prevDate;
    }
  }
  /** Returns true when there is a cron date at the given date. */
  matchDate(date5) {
    const { second, minute, hour, day, month, weekday } = extractDateElements(date5);
    if (this.seconds.indexOf(second) === -1 || this.minutes.indexOf(minute) === -1 || this.hours.indexOf(hour) === -1 || this.months.indexOf(month) === -1) {
      return false;
    }
    if (this.days.length !== 31 && this.weekdays.length !== 7) {
      return this.days.indexOf(day) !== -1 || this.weekdays.indexOf(weekday) !== -1;
    }
    return this.days.indexOf(day) !== -1 && this.weekdays.indexOf(weekday) !== -1;
  }
};

// node_modules/cron-schedule/dist/cron-parser.js
var secondConstraint = {
  min: 0,
  max: 59
};
var minuteConstraint = {
  min: 0,
  max: 59
};
var hourConstraint = {
  min: 0,
  max: 23
};
var dayConstraint = {
  min: 1,
  max: 31
};
var monthConstraint = {
  min: 1,
  max: 12,
  aliases: {
    jan: "1",
    feb: "2",
    mar: "3",
    apr: "4",
    may: "5",
    jun: "6",
    jul: "7",
    aug: "8",
    sep: "9",
    oct: "10",
    nov: "11",
    dec: "12"
  }
};
var weekdayConstraint = {
  min: 0,
  max: 7,
  aliases: {
    mon: "1",
    tue: "2",
    wed: "3",
    thu: "4",
    fri: "5",
    sat: "6",
    sun: "7"
  }
};
var timeNicknames = {
  "@yearly": "0 0 1 1 *",
  "@annually": "0 0 1 1 *",
  "@monthly": "0 0 1 * *",
  "@weekly": "0 0 * * 0",
  "@daily": "0 0 * * *",
  "@hourly": "0 * * * *",
  "@minutely": "* * * * *"
};
function parseElement(element, constraint) {
  const result = /* @__PURE__ */ new Set();
  if (element === "*") {
    for (let i2 = constraint.min; i2 <= constraint.max; i2 = i2 + 1) {
      result.add(i2);
    }
    return result;
  }
  const listElements = element.split(",");
  if (listElements.length > 1) {
    for (const listElement of listElements) {
      const parsedListElement = parseElement(listElement, constraint);
      for (const x of parsedListElement) {
        result.add(x);
      }
    }
    return result;
  }
  const parseSingleElement = /* @__PURE__ */ __name((singleElement) => {
    var _a18, _b;
    singleElement = (_b = (_a18 = constraint.aliases) === null || _a18 === void 0 ? void 0 : _a18[singleElement.toLowerCase()]) !== null && _b !== void 0 ? _b : singleElement;
    const parsedElement = Number.parseInt(singleElement, 10);
    if (Number.isNaN(parsedElement)) {
      throw new Error(`Failed to parse ${element}: ${singleElement} is NaN.`);
    }
    if (parsedElement < constraint.min || parsedElement > constraint.max) {
      throw new Error(`Failed to parse ${element}: ${singleElement} is outside of constraint range of ${constraint.min} - ${constraint.max}.`);
    }
    return parsedElement;
  }, "parseSingleElement");
  const rangeSegments = /^(([0-9a-zA-Z]+)-([0-9a-zA-Z]+)|\*)(\/([0-9]+))?$/.exec(element);
  if (rangeSegments === null) {
    result.add(parseSingleElement(element));
    return result;
  }
  let parsedStart = rangeSegments[1] === "*" ? constraint.min : parseSingleElement(rangeSegments[2]);
  const parsedEnd = rangeSegments[1] === "*" ? constraint.max : parseSingleElement(rangeSegments[3]);
  if (constraint === weekdayConstraint && parsedStart === 7 && // this check ensures that sun-sun is not incorrectly parsed as [0,1,2,3,4,5,6]
  parsedEnd !== 7) {
    parsedStart = 0;
  }
  if (parsedStart > parsedEnd) {
    throw new Error(`Failed to parse ${element}: Invalid range (start: ${parsedStart}, end: ${parsedEnd}).`);
  }
  const step = rangeSegments[5];
  let parsedStep = 1;
  if (step !== void 0) {
    parsedStep = Number.parseInt(step, 10);
    if (Number.isNaN(parsedStep)) {
      throw new Error(`Failed to parse step: ${step} is NaN.`);
    }
    if (parsedStep < 1) {
      throw new Error(`Failed to parse step: Expected ${step} to be greater than 0.`);
    }
  }
  for (let i2 = parsedStart; i2 <= parsedEnd; i2 = i2 + parsedStep) {
    result.add(i2);
  }
  return result;
}
__name(parseElement, "parseElement");
function parseCronExpression(cronExpression) {
  var _a18;
  if (typeof cronExpression !== "string") {
    throw new TypeError("Invalid cron expression: must be of type string.");
  }
  cronExpression = (_a18 = timeNicknames[cronExpression.toLowerCase()]) !== null && _a18 !== void 0 ? _a18 : cronExpression;
  const elements = cronExpression.split(" ").filter((elem) => elem.length > 0);
  if (elements.length < 5 || elements.length > 6) {
    throw new Error("Invalid cron expression: expected 5 or 6 elements.");
  }
  const rawSeconds = elements.length === 6 ? elements[0] : "0";
  const rawMinutes = elements.length === 6 ? elements[1] : elements[0];
  const rawHours = elements.length === 6 ? elements[2] : elements[1];
  const rawDays = elements.length === 6 ? elements[3] : elements[2];
  const rawMonths = elements.length === 6 ? elements[4] : elements[3];
  const rawWeekdays = elements.length === 6 ? elements[5] : elements[4];
  return new Cron({
    seconds: parseElement(rawSeconds, secondConstraint),
    minutes: parseElement(rawMinutes, minuteConstraint),
    hours: parseElement(rawHours, hourConstraint),
    days: parseElement(rawDays, dayConstraint),
    // months in cron are indexed by 1, but Cron expects indexes by 0, so we need to reduce all set values by one.
    months: new Set(Array.from(parseElement(rawMonths, monthConstraint)).map((x) => x - 1)),
    weekdays: new Set(Array.from(parseElement(rawWeekdays, weekdayConstraint)).map((x) => x % 7))
  });
}
__name(parseCronExpression, "parseCronExpression");

// node_modules/agents/dist/chunk-YDUDMOL6.js
import { EmailMessage } from "cloudflare:email";

// node_modules/partyserver/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { DurableObject } from "cloudflare:workers";
if (!("OPEN" in WebSocket)) {
  const WebSocketStatus = {
    // @ts-expect-error
    CONNECTING: WebSocket.READY_STATE_CONNECTING,
    // @ts-expect-error
    OPEN: WebSocket.READY_STATE_OPEN,
    // @ts-expect-error
    CLOSING: WebSocket.READY_STATE_CLOSING,
    // @ts-expect-error
    CLOSED: WebSocket.READY_STATE_CLOSED
  };
  Object.assign(WebSocket, WebSocketStatus);
  Object.assign(WebSocket.prototype, WebSocketStatus);
}
var AttachmentCache = class {
  static {
    __name(this, "AttachmentCache");
  }
  #cache = /* @__PURE__ */ new WeakMap();
  get(ws) {
    let attachment = this.#cache.get(ws);
    if (!attachment) {
      attachment = WebSocket.prototype.deserializeAttachment.call(
        ws
      );
      if (attachment !== void 0) {
        this.#cache.set(ws, attachment);
      } else {
        throw new Error(
          "Missing websocket attachment. This is most likely an issue in PartyServer, please open an issue at https://github.com/threepointone/partyserver/issues"
        );
      }
    }
    return attachment;
  }
  set(ws, attachment) {
    this.#cache.set(ws, attachment);
    WebSocket.prototype.serializeAttachment.call(ws, attachment);
  }
};
var attachments = new AttachmentCache();
var connections = /* @__PURE__ */ new WeakSet();
var isWrapped = /* @__PURE__ */ __name((ws) => {
  return connections.has(ws);
}, "isWrapped");
var createLazyConnection = /* @__PURE__ */ __name((ws) => {
  if (isWrapped(ws)) {
    return ws;
  }
  let initialState = void 0;
  if ("state" in ws) {
    initialState = ws.state;
    delete ws.state;
  }
  const connection = Object.defineProperties(ws, {
    id: {
      get() {
        return attachments.get(ws).__pk.id;
      }
    },
    server: {
      get() {
        return attachments.get(ws).__pk.server;
      }
    },
    socket: {
      get() {
        return ws;
      }
    },
    state: {
      get() {
        return ws.deserializeAttachment();
      }
    },
    setState: {
      value: /* @__PURE__ */ __name(function setState(setState) {
        let state;
        if (setState instanceof Function) {
          state = setState(this.state);
        } else {
          state = setState;
        }
        ws.serializeAttachment(state);
        return state;
      }, "setState")
    },
    deserializeAttachment: {
      value: /* @__PURE__ */ __name(function deserializeAttachment() {
        const attachment = attachments.get(ws);
        return attachment.__user ?? null;
      }, "deserializeAttachment")
    },
    serializeAttachment: {
      value: /* @__PURE__ */ __name(function serializeAttachment(attachment) {
        const setting = {
          ...attachments.get(ws),
          __user: attachment ?? null
        };
        attachments.set(ws, setting);
      }, "serializeAttachment")
    }
  });
  if (initialState) {
    connection.setState(initialState);
  }
  connections.add(connection);
  return connection;
}, "createLazyConnection");
var HibernatingConnectionIterator = class {
  static {
    __name(this, "HibernatingConnectionIterator");
  }
  constructor(state, tag) {
    this.state = state;
    this.tag = tag;
  }
  index = 0;
  sockets;
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const sockets = (
      // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
      this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag))
    );
    let socket;
    while (socket = sockets[this.index++]) {
      if (socket.readyState === WebSocket.READY_STATE_OPEN) {
        const value = createLazyConnection(socket);
        return { done: false, value };
      }
    }
    return { done: true, value: void 0 };
  }
};
var InMemoryConnectionManager = class {
  static {
    __name(this, "InMemoryConnectionManager");
  }
  #connections = /* @__PURE__ */ new Map();
  tags = /* @__PURE__ */ new WeakMap();
  getCount() {
    return this.#connections.size;
  }
  getConnection(id) {
    return this.#connections.get(id);
  }
  *getConnections(tag) {
    if (!tag) {
      yield* this.#connections.values().filter(
        (c) => c.readyState === WebSocket.READY_STATE_OPEN
      );
      return;
    }
    for (const connection of this.#connections.values()) {
      const connectionTags = this.tags.get(connection) ?? [];
      if (connectionTags.includes(tag)) {
        yield connection;
      }
    }
  }
  accept(connection, options) {
    connection.accept();
    this.#connections.set(connection.id, connection);
    this.tags.set(connection, [
      // make sure we have id tag
      connection.id,
      ...options.tags.filter((t2) => t2 !== connection.id)
    ]);
    const removeConnection = /* @__PURE__ */ __name(() => {
      this.#connections.delete(connection.id);
      connection.removeEventListener("close", removeConnection);
      connection.removeEventListener("error", removeConnection);
    }, "removeConnection");
    connection.addEventListener("close", removeConnection);
    connection.addEventListener("error", removeConnection);
    return connection;
  }
};
var HibernatingConnectionManager = class {
  static {
    __name(this, "HibernatingConnectionManager");
  }
  constructor(controller) {
    this.controller = controller;
  }
  getCount() {
    return Number(this.controller.getWebSockets().length);
  }
  getConnection(id) {
    const sockets = this.controller.getWebSockets(id);
    if (sockets.length === 0) return void 0;
    if (sockets.length === 1)
      return createLazyConnection(sockets[0]);
    throw new Error(
      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`
    );
  }
  getConnections(tag) {
    return new HibernatingConnectionIterator(this.controller, tag);
  }
  accept(connection, options) {
    const tags = [
      connection.id,
      ...options.tags.filter((t2) => t2 !== connection.id)
    ];
    if (tags.length > 10) {
      throw new Error(
        "A connection can only have 10 tags, including the default id tag."
      );
    }
    for (const tag of tags) {
      if (typeof tag !== "string") {
        throw new Error(`A connection tag must be a string. Received: ${tag}`);
      }
      if (tag === "") {
        throw new Error("A connection tag must not be an empty string.");
      }
      if (tag.length > 256) {
        throw new Error("A connection tag must not exceed 256 characters");
      }
    }
    this.controller.acceptWebSocket(connection, tags);
    connection.serializeAttachment({
      __pk: {
        id: connection.id,
        server: options.server
      },
      __user: null
    });
    return createLazyConnection(connection);
  }
};
async function getServerByName(serverNamespace, name17, options) {
  if (options?.jurisdiction) {
    serverNamespace = serverNamespace.jurisdiction(options.jurisdiction);
  }
  const id = serverNamespace.idFromName(name17);
  const stub = serverNamespace.get(id, options);
  const req = new Request(
    "http://dummy-example.cloudflare.com/cdn-cgi/partyserver/set-name/"
  );
  req.headers.set("x-partykit-room", name17);
  if (options?.props) {
    req.headers.set("x-partykit-props", JSON.stringify(options?.props));
  }
  await stub.fetch(req).catch((e) => {
    console.error("Could not set server name:", e);
  });
  return stub;
}
__name(getServerByName, "getServerByName");
var Server = class extends DurableObject {
  static {
    __name(this, "Server");
  }
  static options = {
    hibernate: false
  };
  #status = "zero";
  #ParentClass = Object.getPrototypeOf(this).constructor;
  #connectionManager = this.#ParentClass.options.hibernate ? new HibernatingConnectionManager(this.ctx) : new InMemoryConnectionManager();
  /**
   * Execute SQL queries against the Server's database
   * @template T Type of the returned rows
   * @param strings SQL query template strings
   * @param values Values to be inserted into the query
   * @returns Array of query results
   */
  sql(strings, ...values) {
    let query = "";
    try {
      query = strings.reduce(
        (acc, str, i2) => acc + str + (i2 < values.length ? "?" : ""),
        ""
      );
      return [...this.ctx.storage.sql.exec(query, ...values)];
    } catch (e) {
      console.error(`failed to execute sql query: ${query}`, e);
      throw this.onException(e);
    }
  }
  // biome-ignore lint/complexity/noUselessConstructor: <explanation>
  constructor(ctx, env2) {
    super(ctx, env2);
  }
  /**
   * Handle incoming requests to the server.
   */
  async fetch(request) {
    const props = request.headers.get("x-partykit-props");
    if (props) {
      try {
        this.#_props = JSON.parse(props);
      } catch {
        console.error("Internal error parsing context props.");
      }
    }
    if (!this.#_name) {
      const room = request.headers.get("x-partykit-room");
      if (
        // !namespace ||
        !room
      ) {
        throw new Error(`Missing namespace or room headers when connecting to ${this.#ParentClass.name}.
Did you try connecting directly to this Durable Object? Try using getServerByName(namespace, id) instead.`);
      }
      await this.setName(room);
    }
    try {
      const url2 = new URL(request.url);
      if (url2.pathname === "/cdn-cgi/partyserver/set-name/") {
        return Response.json({ ok: true });
      }
      if (request.headers.get("Upgrade")?.toLowerCase() !== "websocket") {
        return await this.onRequest(request);
      } else {
        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();
        let connectionId = url2.searchParams.get("_pk");
        if (!connectionId) {
          connectionId = nanoid3();
        }
        let connection = Object.assign(serverWebSocket, {
          id: connectionId,
          server: this.name,
          state: null,
          setState(setState) {
            let state;
            if (setState instanceof Function) {
              state = setState(this.state);
            } else {
              state = setState;
            }
            this.state = state;
            return this.state;
          }
        });
        const ctx = { request };
        const tags = await this.getConnectionTags(connection, ctx);
        connection = this.#connectionManager.accept(connection, {
          tags,
          server: this.name
        });
        if (!this.#ParentClass.options.hibernate) {
          this.#attachSocketEventHandlers(connection);
        }
        await this.onConnect(connection, ctx);
        return new Response(null, { status: 101, webSocket: clientWebSocket });
      }
    } catch (err) {
      console.error(
        `Error in ${this.#ParentClass.name}:${this.name} fetch:`,
        err
      );
      if (!(err instanceof Error)) throw err;
      if (request.headers.get("Upgrade") === "websocket") {
        const pair = new WebSocketPair();
        pair[1].accept();
        pair[1].send(JSON.stringify({ error: err.stack }));
        pair[1].close(1011, "Uncaught exception during session setup");
        return new Response(null, { status: 101, webSocket: pair[0] });
      } else {
        return new Response(err.stack, { status: 500 });
      }
    }
  }
  async webSocketMessage(ws, message) {
    const connection = createLazyConnection(ws);
    await this.setName(connection.server);
    if (this.#status !== "started") {
      await this.#initialize();
    }
    return this.onMessage(connection, message);
  }
  async webSocketClose(ws, code, reason, wasClean) {
    const connection = createLazyConnection(ws);
    await this.setName(connection.server);
    if (this.#status !== "started") {
      await this.#initialize();
    }
    return this.onClose(connection, code, reason, wasClean);
  }
  async webSocketError(ws, error42) {
    const connection = createLazyConnection(ws);
    await this.setName(connection.server);
    if (this.#status !== "started") {
      await this.#initialize();
    }
    return this.onError(connection, error42);
  }
  async #initialize() {
    await this.ctx.blockConcurrencyWhile(async () => {
      this.#status = "starting";
      await this.onStart(this.#_props);
      this.#status = "started";
    });
  }
  #attachSocketEventHandlers(connection) {
    const handleMessageFromClient = /* @__PURE__ */ __name((event) => {
      this.onMessage(connection, event.data)?.catch((e) => {
        console.error("onMessage error:", e);
      });
    }, "handleMessageFromClient");
    const handleCloseFromClient = /* @__PURE__ */ __name((event) => {
      connection.removeEventListener("message", handleMessageFromClient);
      connection.removeEventListener("close", handleCloseFromClient);
      this.onClose(connection, event.code, event.reason, event.wasClean)?.catch(
        (e) => {
          console.error("onClose error:", e);
        }
      );
    }, "handleCloseFromClient");
    const handleErrorFromClient = /* @__PURE__ */ __name((e) => {
      connection.removeEventListener("message", handleMessageFromClient);
      connection.removeEventListener("error", handleErrorFromClient);
      this.onError(connection, e.error)?.catch((e2) => {
        console.error("onError error:", e2);
      });
    }, "handleErrorFromClient");
    connection.addEventListener("close", handleCloseFromClient);
    connection.addEventListener("error", handleErrorFromClient);
    connection.addEventListener("message", handleMessageFromClient);
  }
  // Public API
  #_name;
  #_longErrorAboutNameThrown = false;
  /**
   * The name for this server. Write-once-only.
   */
  get name() {
    if (!this.#_name) {
      if (!this.#_longErrorAboutNameThrown) {
        this.#_longErrorAboutNameThrown = true;
        throw new Error(
          `Attempting to read .name on ${this.#ParentClass.name} before it was set. The name can be set by explicitly calling .setName(name) on the stub, or by using routePartyKitRequest(). This is a known issue and will be fixed soon. Follow https://github.com/cloudflare/workerd/issues/2240 for more updates.`
        );
      } else {
        throw new Error(
          `Attempting to read .name on ${this.#ParentClass.name} before it was set.`
        );
      }
    }
    return this.#_name;
  }
  // We won't have an await inside this function
  // but it will be called remotely,
  // so we need to mark it as async
  async setName(name17) {
    if (!name17) {
      throw new Error("A name is required.");
    }
    if (this.#_name && this.#_name !== name17) {
      throw new Error("This server already has a name.");
    }
    this.#_name = name17;
    if (this.#status !== "started") {
      await this.ctx.blockConcurrencyWhile(async () => {
        await this.#initialize();
      });
    }
  }
  #sendMessageToConnection(connection, message) {
    try {
      connection.send(message);
    } catch (_e) {
      connection.close(1011, "Unexpected error");
    }
  }
  /** Send a message to all connected clients, except connection ids listed in `without` */
  broadcast(msg, without) {
    for (const connection of this.#connectionManager.getConnections()) {
      if (!without || !without.includes(connection.id)) {
        this.#sendMessageToConnection(connection, msg);
      }
    }
  }
  /** Get a connection by connection id */
  getConnection(id) {
    return this.#connectionManager.getConnection(id);
  }
  /**
   * Get all connections. Optionally, you can provide a tag to filter returned connections.
   * Use `Server#getConnectionTags` to tag the connection on connect.
   */
  getConnections(tag) {
    return this.#connectionManager.getConnections(tag);
  }
  /**
   * You can tag a connection to filter them in Server#getConnections.
   * Each connection supports up to 9 tags, each tag max length is 256 characters.
   */
  getConnectionTags(connection, context2) {
    return [];
  }
  #_props;
  // Implemented by the user
  /**
   * Called when the server is started for the first time.
   */
  onStart(props) {
  }
  /**
   * Called when a new connection is made to the server.
   */
  onConnect(connection, ctx) {
    console.log(
      `Connection ${connection.id} connected to ${this.#ParentClass.name}:${this.name}`
    );
  }
  /**
   * Called when a message is received from a connection.
   */
  onMessage(connection, message) {
    console.log(
      `Received message on connection ${this.#ParentClass.name}:${connection.id}`
    );
    console.info(
      `Implement onMessage on ${this.#ParentClass.name} to handle this message.`
    );
  }
  /**
   * Called when a connection is closed.
   */
  onClose(connection, code, reason, wasClean) {
  }
  /**
   * Called when an error occurs on a connection.
   */
  onError(connection, error42) {
    console.error(
      `Error on connection ${connection.id} in ${this.#ParentClass.name}:${this.name}:`,
      error42
    );
    console.info(
      `Implement onError on ${this.#ParentClass.name} to handle this error.`
    );
  }
  /**
   * Called when a request is made to the server.
   */
  onRequest(request) {
    console.warn(
      `onRequest hasn't been implemented on ${this.#ParentClass.name}:${this.name} responding to ${request.url}`
    );
    return new Response("Not implemented", { status: 404 });
  }
  /**
   * Called when an exception occurs.
   * @param error - The error that occurred.
   */
  onException(error42) {
    console.error(
      `Exception in ${this.#ParentClass.name}:${this.name}:`,
      error42
    );
    console.info(
      `Implement onException on ${this.#ParentClass.name} to handle this error.`
    );
  }
  onAlarm() {
    console.log(
      `Implement onAlarm on ${this.#ParentClass.name} to handle alarms.`
    );
  }
  async alarm() {
    if (this.#status !== "started") {
      await this.#initialize();
    }
    await this.onAlarm();
  }
};

// node_modules/agents/dist/chunk-YDUDMOL6.js
function isRPCRequest(msg) {
  return typeof msg === "object" && msg !== null && "type" in msg && msg.type === "rpc" && "id" in msg && typeof msg.id === "string" && "method" in msg && typeof msg.method === "string" && "args" in msg && Array.isArray(msg.args);
}
__name(isRPCRequest, "isRPCRequest");
function isStateUpdateMessage(msg) {
  return typeof msg === "object" && msg !== null && "type" in msg && msg.type === "cf_agent_state" && "state" in msg;
}
__name(isStateUpdateMessage, "isStateUpdateMessage");
var callableMetadata = /* @__PURE__ */ new Map();
function getNextCronTime(cron) {
  const interval = parseCronExpression(cron);
  return interval.getNextDate();
}
__name(getNextCronTime, "getNextCronTime");
var STATE_ROW_ID = "cf_state_row_id";
var STATE_WAS_CHANGED = "cf_state_was_changed";
var DEFAULT_STATE = {};
var agentContext = new AsyncLocalStorage();
function getCurrentAgent() {
  const store = agentContext.getStore();
  if (!store) {
    return {
      agent: void 0,
      connection: void 0,
      request: void 0,
      email: void 0
    };
  }
  return store;
}
__name(getCurrentAgent, "getCurrentAgent");
function withAgentContext(method) {
  return function(...args) {
    const { connection, request, email: email3, agent } = getCurrentAgent();
    if (agent === this) {
      return method.apply(this, args);
    }
    return agentContext.run({ agent: this, connection, request, email: email3 }, () => {
      return method.apply(this, args);
    });
  };
}
__name(withAgentContext, "withAgentContext");
var _Agent = class _Agent2 extends Server {
  static {
    __name(this, "_Agent");
  }
  constructor(ctx, env2) {
    super(ctx, env2);
    this._state = DEFAULT_STATE;
    this._ParentClass = Object.getPrototypeOf(this).constructor;
    this.mcp = new MCPClientManager(this._ParentClass.name, "0.0.1");
    this.initialState = DEFAULT_STATE;
    this.observability = genericObservability;
    this._flushingQueue = false;
    this.alarm = async () => {
      const now = Math.floor(Date.now() / 1e3);
      const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE time <= ${now}
    `;
      if (result && Array.isArray(result)) {
        for (const row of result) {
          const callback = this[row.callback];
          if (!callback) {
            console.error(`callback ${row.callback} not found`);
            continue;
          }
          await agentContext.run(
            {
              agent: this,
              connection: void 0,
              request: void 0,
              email: void 0
            },
            async () => {
              try {
                this.observability?.emit(
                  {
                    displayMessage: `Schedule ${row.id} executed`,
                    id: nanoid3(),
                    payload: {
                      callback: row.callback,
                      id: row.id
                    },
                    timestamp: Date.now(),
                    type: "schedule:execute"
                  },
                  this.ctx
                );
                await callback.bind(this)(JSON.parse(row.payload), row);
              } catch (e) {
                console.error(`error executing callback "${row.callback}"`, e);
              }
            }
          );
          if (row.type === "cron") {
            const nextExecutionTime = getNextCronTime(row.cron);
            const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
            this.sql`
          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}
        `;
          } else {
            this.sql`
          DELETE FROM cf_agents_schedules WHERE id = ${row.id}
        `;
          }
        }
      }
      await this._scheduleNextAlarm();
    };
    this._autoWrapCustomMethods();
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_state (
        id TEXT PRIMARY KEY NOT NULL,
        state TEXT
      )
    `;
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_queues (
        id TEXT PRIMARY KEY NOT NULL,
        payload TEXT,
        callback TEXT,
        created_at INTEGER DEFAULT (unixepoch())
      )
    `;
    void this.ctx.blockConcurrencyWhile(async () => {
      return this._tryCatch(async () => {
        this.sql`
        CREATE TABLE IF NOT EXISTS cf_agents_schedules (
          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),
          callback TEXT,
          payload TEXT,
          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),
          time INTEGER,
          delayInSeconds INTEGER,
          cron TEXT,
          created_at INTEGER DEFAULT (unixepoch())
        )
      `;
        await this.alarm();
      });
    });
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (
        id TEXT PRIMARY KEY NOT NULL,
        name TEXT NOT NULL,
        server_url TEXT NOT NULL,
        callback_url TEXT NOT NULL,
        client_id TEXT,
        auth_url TEXT,
        server_options TEXT
      )
    `;
    const _onRequest = this.onRequest.bind(this);
    this.onRequest = (request) => {
      return agentContext.run(
        { agent: this, connection: void 0, request, email: void 0 },
        async () => {
          if (this.mcp.isCallbackRequest(request)) {
            await this.mcp.handleCallbackRequest(request);
            this.broadcast(
              JSON.stringify({
                mcp: this.getMcpServers(),
                type: "cf_agent_mcp_servers"
                /* CF_AGENT_MCP_SERVERS */
              })
            );
            return new Response("<script>window.close();<\/script>", {
              headers: { "content-type": "text/html" },
              status: 200
            });
          }
          return this._tryCatch(() => _onRequest(request));
        }
      );
    };
    const _onMessage2 = this.onMessage.bind(this);
    this.onMessage = async (connection, message) => {
      return agentContext.run(
        { agent: this, connection, request: void 0, email: void 0 },
        async () => {
          if (typeof message !== "string") {
            return this._tryCatch(() => _onMessage2(connection, message));
          }
          let parsed;
          try {
            parsed = JSON.parse(message);
          } catch (_e) {
            return this._tryCatch(() => _onMessage2(connection, message));
          }
          if (isStateUpdateMessage(parsed)) {
            this._setStateInternal(parsed.state, connection);
            return;
          }
          if (isRPCRequest(parsed)) {
            try {
              const { id, method, args } = parsed;
              const methodFn = this[method];
              if (typeof methodFn !== "function") {
                throw new Error(`Method ${method} does not exist`);
              }
              if (!this._isCallable(method)) {
                throw new Error(`Method ${method} is not callable`);
              }
              const metadata = callableMetadata.get(methodFn);
              if (metadata?.streaming) {
                const stream = new StreamingResponse(connection, id);
                await methodFn.apply(this, [stream, ...args]);
                return;
              }
              const result = await methodFn.apply(this, args);
              this.observability?.emit(
                {
                  displayMessage: `RPC call to ${method}`,
                  id: nanoid3(),
                  payload: {
                    method,
                    streaming: metadata?.streaming
                  },
                  timestamp: Date.now(),
                  type: "rpc"
                },
                this.ctx
              );
              const response = {
                done: true,
                id,
                result,
                success: true,
                type: "rpc"
                /* RPC */
              };
              connection.send(JSON.stringify(response));
            } catch (e) {
              const response = {
                error: e instanceof Error ? e.message : "Unknown error occurred",
                id: parsed.id,
                success: false,
                type: "rpc"
                /* RPC */
              };
              connection.send(JSON.stringify(response));
              console.error("RPC error:", e);
            }
            return;
          }
          return this._tryCatch(() => _onMessage2(connection, message));
        }
      );
    };
    const _onConnect = this.onConnect.bind(this);
    this.onConnect = (connection, ctx2) => {
      return agentContext.run(
        { agent: this, connection, request: ctx2.request, email: void 0 },
        () => {
          if (this.state) {
            connection.send(
              JSON.stringify({
                state: this.state,
                type: "cf_agent_state"
                /* CF_AGENT_STATE */
              })
            );
          }
          connection.send(
            JSON.stringify({
              mcp: this.getMcpServers(),
              type: "cf_agent_mcp_servers"
              /* CF_AGENT_MCP_SERVERS */
            })
          );
          this.observability?.emit(
            {
              displayMessage: "Connection established",
              id: nanoid3(),
              payload: {
                connectionId: connection.id
              },
              timestamp: Date.now(),
              type: "connect"
            },
            this.ctx
          );
          return this._tryCatch(() => _onConnect(connection, ctx2));
        }
      );
    };
    const _onStart = this.onStart.bind(this);
    this.onStart = async (props) => {
      return agentContext.run(
        {
          agent: this,
          connection: void 0,
          request: void 0,
          email: void 0
        },
        async () => {
          await this._tryCatch(() => {
            const servers = this.sql`
            SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;
          `;
            this.broadcast(
              JSON.stringify({
                mcp: this.getMcpServers(),
                type: "cf_agent_mcp_servers"
                /* CF_AGENT_MCP_SERVERS */
              })
            );
            if (servers && Array.isArray(servers) && servers.length > 0) {
              servers.forEach((server) => {
                this._connectToMcpServerInternal(
                  server.name,
                  server.server_url,
                  server.callback_url,
                  server.server_options ? JSON.parse(server.server_options) : void 0,
                  {
                    id: server.id,
                    oauthClientId: server.client_id ?? void 0
                  }
                ).then(() => {
                  this.broadcast(
                    JSON.stringify({
                      mcp: this.getMcpServers(),
                      type: "cf_agent_mcp_servers"
                      /* CF_AGENT_MCP_SERVERS */
                    })
                  );
                }).catch((error42) => {
                  console.error(
                    `Error connecting to MCP server: ${server.name} (${server.server_url})`,
                    error42
                  );
                  this.broadcast(
                    JSON.stringify({
                      mcp: this.getMcpServers(),
                      type: "cf_agent_mcp_servers"
                      /* CF_AGENT_MCP_SERVERS */
                    })
                  );
                });
              });
            }
            return _onStart(props);
          });
        }
      );
    };
  }
  /**
   * Current state of the Agent
   */
  get state() {
    if (this._state !== DEFAULT_STATE) {
      return this._state;
    }
    const wasChanged = this.sql`
        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}
      `;
    const result = this.sql`
      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}
    `;
    if (wasChanged[0]?.state === "true" || // we do this check for people who updated their code before we shipped wasChanged
    result[0]?.state) {
      const state = result[0]?.state;
      this._state = JSON.parse(state);
      return this._state;
    }
    if (this.initialState === DEFAULT_STATE) {
      return void 0;
    }
    this.setState(this.initialState);
    return this.initialState;
  }
  /**
   * Execute SQL queries against the Agent's database
   * @template T Type of the returned rows
   * @param strings SQL query template strings
   * @param values Values to be inserted into the query
   * @returns Array of query results
   */
  sql(strings, ...values) {
    let query = "";
    try {
      query = strings.reduce(
        (acc, str, i2) => acc + str + (i2 < values.length ? "?" : ""),
        ""
      );
      return [...this.ctx.storage.sql.exec(query, ...values)];
    } catch (e) {
      console.error(`failed to execute sql query: ${query}`, e);
      throw this.onError(e);
    }
  }
  _setStateInternal(state, source = "server") {
    this._state = state;
    this.sql`
    INSERT OR REPLACE INTO cf_agents_state (id, state)
    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})
  `;
    this.sql`
    INSERT OR REPLACE INTO cf_agents_state (id, state)
    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})
  `;
    this.broadcast(
      JSON.stringify({
        state,
        type: "cf_agent_state"
        /* CF_AGENT_STATE */
      }),
      source !== "server" ? [source.id] : []
    );
    return this._tryCatch(() => {
      const { connection, request, email: email3 } = agentContext.getStore() || {};
      return agentContext.run(
        { agent: this, connection, request, email: email3 },
        async () => {
          this.observability?.emit(
            {
              displayMessage: "State updated",
              id: nanoid3(),
              payload: {},
              timestamp: Date.now(),
              type: "state:update"
            },
            this.ctx
          );
          return this.onStateUpdate(state, source);
        }
      );
    });
  }
  /**
   * Update the Agent's state
   * @param state New state to set
   */
  setState(state) {
    this._setStateInternal(state, "server");
  }
  /**
   * Called when the Agent's state is updated
   * @param state Updated state
   * @param source Source of the state update ("server" or a client connection)
   */
  // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later
  onStateUpdate(state, source) {
  }
  /**
   * Called when the Agent receives an email via routeAgentEmail()
   * Override this method to handle incoming emails
   * @param email Email message to process
   */
  async _onEmail(email3) {
    return agentContext.run(
      { agent: this, connection: void 0, request: void 0, email: email3 },
      async () => {
        if ("onEmail" in this && typeof this.onEmail === "function") {
          return this._tryCatch(
            () => this.onEmail(email3)
          );
        } else {
          console.log("Received email from:", email3.from, "to:", email3.to);
          console.log("Subject:", email3.headers.get("subject"));
          console.log(
            "Implement onEmail(email: AgentEmail): Promise<void> in your agent to process emails"
          );
        }
      }
    );
  }
  /**
   * Reply to an email
   * @param email The email to reply to
   * @param options Options for the reply
   * @returns void
   */
  async replyToEmail(email3, options) {
    return this._tryCatch(async () => {
      const agentName = camelCaseToKebabCase(this._ParentClass.name);
      const agentId = this.name;
      const { createMimeMessage } = await Promise.resolve().then(() => (init_mimetext_node_es(), mimetext_node_es_exports));
      const msg = createMimeMessage();
      msg.setSender({ addr: email3.to, name: options.fromName });
      msg.setRecipient(email3.from);
      msg.setSubject(
        options.subject || `Re: ${email3.headers.get("subject")}` || "No subject"
      );
      msg.addMessage({
        contentType: options.contentType || "text/plain",
        data: options.body
      });
      const domain3 = email3.from.split("@")[1];
      const messageId = `<${agentId}@${domain3}>`;
      msg.setHeader("In-Reply-To", email3.headers.get("Message-ID"));
      msg.setHeader("Message-ID", messageId);
      msg.setHeader("X-Agent-Name", agentName);
      msg.setHeader("X-Agent-ID", agentId);
      if (options.headers) {
        for (const [key, value] of Object.entries(options.headers)) {
          msg.setHeader(key, value);
        }
      }
      await email3.reply({
        from: email3.to,
        raw: msg.asRaw(),
        to: email3.from
      });
    });
  }
  async _tryCatch(fn) {
    try {
      return await fn();
    } catch (e) {
      throw this.onError(e);
    }
  }
  /**
   * Automatically wrap custom methods with agent context
   * This ensures getCurrentAgent() works in all custom methods without decorators
   */
  _autoWrapCustomMethods() {
    const basePrototypes = [_Agent2.prototype, Server.prototype];
    const baseMethods = /* @__PURE__ */ new Set();
    for (const baseProto of basePrototypes) {
      let proto2 = baseProto;
      while (proto2 && proto2 !== Object.prototype) {
        const methodNames = Object.getOwnPropertyNames(proto2);
        for (const methodName of methodNames) {
          baseMethods.add(methodName);
        }
        proto2 = Object.getPrototypeOf(proto2);
      }
    }
    let proto = Object.getPrototypeOf(this);
    let depth = 0;
    while (proto && proto !== Object.prototype && depth < 10) {
      const methodNames = Object.getOwnPropertyNames(proto);
      for (const methodName of methodNames) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
        if (baseMethods.has(methodName) || methodName.startsWith("_") || !descriptor || !!descriptor.get || typeof descriptor.value !== "function") {
          continue;
        }
        const wrappedFunction = withAgentContext(
          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript
          this[methodName]
          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript
        );
        if (this._isCallable(methodName)) {
          callableMetadata.set(
            wrappedFunction,
            callableMetadata.get(this[methodName])
          );
        }
        this.constructor.prototype[methodName] = wrappedFunction;
      }
      proto = Object.getPrototypeOf(proto);
      depth++;
    }
  }
  onError(connectionOrError, error42) {
    let theError;
    if (connectionOrError && error42) {
      theError = error42;
      console.error(
        "Error on websocket connection:",
        connectionOrError.id,
        theError
      );
      console.error(
        "Override onError(connection, error) to handle websocket connection errors"
      );
    } else {
      theError = connectionOrError;
      console.error("Error on server:", theError);
      console.error("Override onError(error) to handle server errors");
    }
    throw theError;
  }
  /**
   * Render content (not implemented in base class)
   */
  render() {
    throw new Error("Not implemented");
  }
  /**
   * Queue a task to be executed in the future
   * @param payload Payload to pass to the callback
   * @param callback Name of the method to call
   * @returns The ID of the queued task
   */
  async queue(callback, payload) {
    const id = nanoid3(9);
    if (typeof callback !== "string") {
      throw new Error("Callback must be a string");
    }
    if (typeof this[callback] !== "function") {
      throw new Error(`this.${callback} is not a function`);
    }
    this.sql`
      INSERT OR REPLACE INTO cf_agents_queues (id, payload, callback)
      VALUES (${id}, ${JSON.stringify(payload)}, ${callback})
    `;
    void this._flushQueue().catch((e) => {
      console.error("Error flushing queue:", e);
    });
    return id;
  }
  async _flushQueue() {
    if (this._flushingQueue) {
      return;
    }
    this._flushingQueue = true;
    while (true) {
      const result = this.sql`
      SELECT * FROM cf_agents_queues
      ORDER BY created_at ASC
    `;
      if (!result || result.length === 0) {
        break;
      }
      for (const row of result || []) {
        const callback = this[row.callback];
        if (!callback) {
          console.error(`callback ${row.callback} not found`);
          continue;
        }
        const { connection, request, email: email3 } = agentContext.getStore() || {};
        await agentContext.run(
          {
            agent: this,
            connection,
            request,
            email: email3
          },
          async () => {
            await callback.bind(this)(JSON.parse(row.payload), row);
            await this.dequeue(row.id);
          }
        );
      }
    }
    this._flushingQueue = false;
  }
  /**
   * Dequeue a task by ID
   * @param id ID of the task to dequeue
   */
  async dequeue(id) {
    this.sql`DELETE FROM cf_agents_queues WHERE id = ${id}`;
  }
  /**
   * Dequeue all tasks
   */
  async dequeueAll() {
    this.sql`DELETE FROM cf_agents_queues`;
  }
  /**
   * Dequeue all tasks by callback
   * @param callback Name of the callback to dequeue
   */
  async dequeueAllByCallback(callback) {
    this.sql`DELETE FROM cf_agents_queues WHERE callback = ${callback}`;
  }
  /**
   * Get a queued task by ID
   * @param id ID of the task to get
   * @returns The task or undefined if not found
   */
  async getQueue(id) {
    const result = this.sql`
      SELECT * FROM cf_agents_queues WHERE id = ${id}
    `;
    return result ? { ...result[0], payload: JSON.parse(result[0].payload) } : void 0;
  }
  /**
   * Get all queues by key and value
   * @param key Key to filter by
   * @param value Value to filter by
   * @returns Array of matching QueueItem objects
   */
  async getQueues(key, value) {
    const result = this.sql`
      SELECT * FROM cf_agents_queues
    `;
    return result.filter((row) => JSON.parse(row.payload)[key] === value);
  }
  /**
   * Schedule a task to be executed in the future
   * @template T Type of the payload data
   * @param when When to execute the task (Date, seconds delay, or cron expression)
   * @param callback Name of the method to call
   * @param payload Data to pass to the callback
   * @returns Schedule object representing the scheduled task
   */
  async schedule(when, callback, payload) {
    const id = nanoid3(9);
    const emitScheduleCreate = /* @__PURE__ */ __name((schedule) => this.observability?.emit(
      {
        displayMessage: `Schedule ${schedule.id} created`,
        id: nanoid3(),
        payload: {
          callback,
          id
        },
        timestamp: Date.now(),
        type: "schedule:create"
      },
      this.ctx
    ), "emitScheduleCreate");
    if (typeof callback !== "string") {
      throw new Error("Callback must be a string");
    }
    if (typeof this[callback] !== "function") {
      throw new Error(`this.${callback} is not a function`);
    }
    if (when instanceof Date) {
      const timestamp = Math.floor(when.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'scheduled', ${timestamp})
      `;
      await this._scheduleNextAlarm();
      const schedule = {
        callback,
        id,
        payload,
        time: timestamp,
        type: "scheduled"
      };
      emitScheduleCreate(schedule);
      return schedule;
    }
    if (typeof when === "number") {
      const time5 = new Date(Date.now() + when * 1e3);
      const timestamp = Math.floor(time5.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'delayed', ${when}, ${timestamp})
      `;
      await this._scheduleNextAlarm();
      const schedule = {
        callback,
        delayInSeconds: when,
        id,
        payload,
        time: timestamp,
        type: "delayed"
      };
      emitScheduleCreate(schedule);
      return schedule;
    }
    if (typeof when === "string") {
      const nextExecutionTime = getNextCronTime(when);
      const timestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'cron', ${when}, ${timestamp})
      `;
      await this._scheduleNextAlarm();
      const schedule = {
        callback,
        cron: when,
        id,
        payload,
        time: timestamp,
        type: "cron"
      };
      emitScheduleCreate(schedule);
      return schedule;
    }
    throw new Error("Invalid schedule type");
  }
  /**
   * Get a scheduled task by ID
   * @template T Type of the payload data
   * @param id ID of the scheduled task
   * @returns The Schedule object or undefined if not found
   */
  async getSchedule(id) {
    const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE id = ${id}
    `;
    if (!result) {
      console.error(`schedule ${id} not found`);
      return void 0;
    }
    return { ...result[0], payload: JSON.parse(result[0].payload) };
  }
  /**
   * Get scheduled tasks matching the given criteria
   * @template T Type of the payload data
   * @param criteria Criteria to filter schedules
   * @returns Array of matching Schedule objects
   */
  getSchedules(criteria = {}) {
    let query = "SELECT * FROM cf_agents_schedules WHERE 1=1";
    const params = [];
    if (criteria.id) {
      query += " AND id = ?";
      params.push(criteria.id);
    }
    if (criteria.type) {
      query += " AND type = ?";
      params.push(criteria.type);
    }
    if (criteria.timeRange) {
      query += " AND time >= ? AND time <= ?";
      const start = criteria.timeRange.start || /* @__PURE__ */ new Date(0);
      const end = criteria.timeRange.end || /* @__PURE__ */ new Date(999999999999999);
      params.push(
        Math.floor(start.getTime() / 1e3),
        Math.floor(end.getTime() / 1e3)
      );
    }
    const result = this.ctx.storage.sql.exec(query, ...params).toArray().map((row) => ({
      ...row,
      payload: JSON.parse(row.payload)
    }));
    return result;
  }
  /**
   * Cancel a scheduled task
   * @param id ID of the task to cancel
   * @returns true if the task was cancelled, false otherwise
   */
  async cancelSchedule(id) {
    const schedule = await this.getSchedule(id);
    if (schedule) {
      this.observability?.emit(
        {
          displayMessage: `Schedule ${id} cancelled`,
          id: nanoid3(),
          payload: {
            callback: schedule.callback,
            id: schedule.id
          },
          timestamp: Date.now(),
          type: "schedule:cancel"
        },
        this.ctx
      );
    }
    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;
    await this._scheduleNextAlarm();
    return true;
  }
  async _scheduleNextAlarm() {
    const result = this.sql`
      SELECT time FROM cf_agents_schedules
      WHERE time > ${Math.floor(Date.now() / 1e3)}
      ORDER BY time ASC
      LIMIT 1
    `;
    if (!result) return;
    if (result.length > 0 && "time" in result[0]) {
      const nextTime = result[0].time * 1e3;
      await this.ctx.storage.setAlarm(nextTime);
    }
  }
  /**
   * Destroy the Agent, removing all state and scheduled tasks
   */
  async destroy() {
    this.sql`DROP TABLE IF EXISTS cf_agents_state`;
    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;
    this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;
    this.sql`DROP TABLE IF EXISTS cf_agents_queues`;
    await this.ctx.storage.deleteAlarm();
    await this.ctx.storage.deleteAll();
    this.ctx.abort("destroyed");
    this.observability?.emit(
      {
        displayMessage: "Agent destroyed",
        id: nanoid3(),
        payload: {},
        timestamp: Date.now(),
        type: "destroy"
      },
      this.ctx
    );
  }
  /**
   * Get all methods marked as callable on this Agent
   * @returns A map of method names to their metadata
   */
  _isCallable(method) {
    return callableMetadata.has(this[method]);
  }
  /**
   * Connect to a new MCP Server
   *
   * @param url MCP Server SSE URL
   * @param callbackHost Base host for the agent, used for the redirect URI.
   * @param agentsPrefix agents routing prefix if not using `agents`
   * @param options MCP client and transport (header) options
   * @returns authUrl
   */
  async addMcpServer(serverName, url2, callbackHost, agentsPrefix = "agents", options) {
    const callbackUrl = `${callbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this._ParentClass.name)}/${this.name}/callback`;
    const result = await this._connectToMcpServerInternal(
      serverName,
      url2,
      callbackUrl,
      options
    );
    this.sql`
        INSERT
        OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)
      VALUES (
        ${result.id},
        ${serverName},
        ${url2},
        ${result.clientId ?? null},
        ${result.authUrl ?? null},
        ${callbackUrl},
        ${options ? JSON.stringify(options) : null}
        );
    `;
    this.broadcast(
      JSON.stringify({
        mcp: this.getMcpServers(),
        type: "cf_agent_mcp_servers"
        /* CF_AGENT_MCP_SERVERS */
      })
    );
    return result;
  }
  async _connectToMcpServerInternal(_serverName, url2, callbackUrl, options, reconnect) {
    const authProvider = new DurableObjectOAuthClientProvider(
      this.ctx.storage,
      this.name,
      callbackUrl
    );
    if (reconnect) {
      authProvider.serverId = reconnect.id;
      if (reconnect.oauthClientId) {
        authProvider.clientId = reconnect.oauthClientId;
      }
    }
    let headerTransportOpts = {};
    if (options?.transport?.headers) {
      headerTransportOpts = {
        eventSourceInit: {
          fetch: /* @__PURE__ */ __name((url22, init) => fetch(url22, {
            ...init,
            headers: options?.transport?.headers
          }), "fetch")
        },
        requestInit: {
          headers: options?.transport?.headers
        }
      };
    }
    const { id, authUrl, clientId } = await this.mcp.connect(url2, {
      client: options?.client,
      reconnect,
      transport: {
        ...headerTransportOpts,
        authProvider
      }
    });
    return {
      authUrl,
      clientId,
      id
    };
  }
  async removeMcpServer(id) {
    this.mcp.closeConnection(id);
    this.sql`
      DELETE FROM cf_agents_mcp_servers WHERE id = ${id};
    `;
    this.broadcast(
      JSON.stringify({
        mcp: this.getMcpServers(),
        type: "cf_agent_mcp_servers"
        /* CF_AGENT_MCP_SERVERS */
      })
    );
  }
  getMcpServers() {
    const mcpState = {
      prompts: this.mcp.listPrompts(),
      resources: this.mcp.listResources(),
      servers: {},
      tools: this.mcp.listTools()
    };
    const servers = this.sql`
      SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;
    `;
    if (servers && Array.isArray(servers) && servers.length > 0) {
      for (const server of servers) {
        const serverConn = this.mcp.mcpConnections[server.id];
        mcpState.servers[server.id] = {
          auth_url: server.auth_url,
          capabilities: serverConn?.serverCapabilities ?? null,
          instructions: serverConn?.instructions ?? null,
          name: server.name,
          server_url: server.server_url,
          // mark as "authenticating" because the server isn't automatically connected, so it's pending authenticating
          state: serverConn?.connectionState ?? "authenticating"
        };
      }
    }
    return mcpState;
  }
};
_Agent.options = {
  /** Whether the Agent should hibernate when inactive */
  hibernate: true
  // default to hibernate
};
var Agent = _Agent;
async function getAgentByName(namespace, name17, options) {
  return getServerByName(namespace, name17, options);
}
__name(getAgentByName, "getAgentByName");
var StreamingResponse = class {
  static {
    __name(this, "StreamingResponse");
  }
  constructor(connection, id) {
    this._closed = false;
    this._connection = connection;
    this._id = id;
  }
  /**
   * Send a chunk of data to the client
   * @param chunk The data to send
   */
  send(chunk) {
    if (this._closed) {
      throw new Error("StreamingResponse is already closed");
    }
    const response = {
      done: false,
      id: this._id,
      result: chunk,
      success: true,
      type: "rpc"
      /* RPC */
    };
    this._connection.send(JSON.stringify(response));
  }
  /**
   * End the stream and send the final chunk (if any)
   * @param finalChunk Optional final chunk of data to send
   */
  end(finalChunk) {
    if (this._closed) {
      throw new Error("StreamingResponse is already closed");
    }
    this._closed = true;
    const response = {
      done: true,
      id: this._id,
      result: finalChunk,
      success: true,
      type: "rpc"
      /* RPC */
    };
    this._connection.send(JSON.stringify(response));
  }
};
var genericObservability = {
  emit(event) {
    if (isLocalMode()) {
      console.log(event.displayMessage);
      return;
    }
    console.log(event);
  }
};
var localMode = false;
function isLocalMode() {
  if (localMode) {
    return true;
  }
  const { request } = getCurrentAgent();
  if (!request) {
    return false;
  }
  const url2 = new URL(request.url);
  localMode = url2.hostname === "localhost";
  return localMode;
}
__name(isLocalMode, "isLocalMode");

// node_modules/agents/dist/chunk-AVYJQSLW.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/agents/dist/mcp/index.js
var STANDALONE_SSE_MARKER = "standalone-sse";
var STANDALONE_SSE_METHOD = "cf/standalone_sse/attach";
var MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024;
var createStreamingHttpHandler = /* @__PURE__ */ __name((basePath, namespace, corsOptions) => {
  let pathname = basePath;
  if (basePath === "/") pathname = "/*";
  const basePattern = new URLPattern({ pathname });
  return async (request, ctx) => {
    const url2 = new URL(request.url);
    if (basePattern.test(url2)) {
      if (request.method === "POST") {
        const acceptHeader = request.headers.get("accept");
        if (!acceptHeader?.includes("application/json") || !acceptHeader.includes("text/event-stream")) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: "Not Acceptable: Client must accept both application/json and text/event-stream"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 406 });
        }
        const ct = request.headers.get("content-type");
        if (!ct || !ct.includes("application/json")) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: "Unsupported Media Type: Content-Type must be application/json"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 415 });
        }
        const contentLength = Number.parseInt(
          request.headers.get("content-length") ?? "0",
          10
        );
        if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 413 });
        }
        let sessionId = request.headers.get("mcp-session-id");
        let rawMessage;
        try {
          rawMessage = await request.json();
        } catch (_error) {
          const body2 = JSON.stringify({
            error: {
              code: -32700,
              message: "Parse error: Invalid JSON"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        let arrayMessage;
        if (Array.isArray(rawMessage)) {
          arrayMessage = rawMessage;
        } else {
          arrayMessage = [rawMessage];
        }
        let messages = [];
        for (const msg of arrayMessage) {
          if (!JSONRPCMessageSchema2.safeParse(msg).success) {
            const body2 = JSON.stringify({
              error: {
                code: -32700,
                message: "Parse error: Invalid JSON-RPC message"
              },
              id: null,
              jsonrpc: "2.0"
            });
            return new Response(body2, { status: 400 });
          }
        }
        messages = arrayMessage.map((msg) => JSONRPCMessageSchema2.parse(msg));
        const isInitializationRequest = messages.some(
          (msg) => InitializeRequestSchema.safeParse(msg).success
        );
        if (isInitializationRequest && sessionId) {
          const body2 = JSON.stringify({
            error: {
              code: -32600,
              message: "Invalid Request: Initialization requests must not include a sessionId"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        if (isInitializationRequest && messages.length > 1) {
          const body2 = JSON.stringify({
            error: {
              code: -32600,
              message: "Invalid Request: Only one initialization request is allowed"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        if (!isInitializationRequest && !sessionId) {
          const body2 = JSON.stringify({
            error: {
              code: -32e3,
              message: "Bad Request: Mcp-Session-Id header is required"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 400 });
        }
        sessionId = sessionId ?? namespace.newUniqueId().toString();
        const agent = await getAgentByName(
          namespace,
          `streamable-http:${sessionId}`,
          { props: ctx.props }
        );
        const isInitialized = await agent.isInitialized();
        if (isInitializationRequest) {
          await agent.setInitialized();
        } else if (!isInitialized) {
          const body2 = JSON.stringify({
            error: {
              code: -32001,
              message: "Session not found"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 404 });
        }
        const { readable, writable } = new TransformStream();
        const writer = writable.getWriter();
        const encoder = new TextEncoder();
        const existingHeaders = {};
        request.headers.forEach((value, key) => {
          existingHeaders[key] = value;
        });
        const req = new Request(request.url, {
          headers: {
            ...existingHeaders,
            Upgrade: "websocket"
          }
        });
        if (ctx.props) agent.updateProps(ctx.props);
        const response = await agent.fetch(req);
        const ws = response.webSocket;
        if (!ws) {
          console.error("Failed to establish WebSocket connection");
          await writer.close();
          const body2 = JSON.stringify({
            error: {
              code: -32001,
              message: "Failed to establish WebSocket connection"
            },
            id: null,
            jsonrpc: "2.0"
          });
          return new Response(body2, { status: 500 });
        }
        const requestIds = /* @__PURE__ */ new Set();
        ws.accept();
        ws.addEventListener("message", (event) => {
          async function onMessage(event2) {
            try {
              const data = typeof event2.data === "string" ? event2.data : new TextDecoder().decode(event2.data);
              const message = JSON.parse(data);
              const result = JSONRPCMessageSchema2.safeParse(message);
              if (!result.success) {
                return;
              }
              if (isJSONRPCResponse(result.data) || isJSONRPCError(result.data)) {
                requestIds.delete(result.data.id);
              }
              const messageText = `event: message
data: ${JSON.stringify(result.data)}

`;
              await writer.write(encoder.encode(messageText));
              if (requestIds.size === 0) {
                ws?.close();
                await writer.close();
              }
            } catch (error42) {
              console.error("Error forwarding message to SSE:", error42);
            }
          }
          __name(onMessage, "onMessage");
          onMessage(event).catch(console.error);
        });
        ws.addEventListener("error", (error42) => {
          async function onError(_error) {
            try {
              await writer.close();
            } catch (_e) {
            }
          }
          __name(onError, "onError");
          onError(error42).catch(console.error);
        });
        ws.addEventListener("close", () => {
          async function onClose() {
            try {
              await writer.close();
            } catch (error42) {
              console.error("Error closing SSE connection:", error42);
            }
          }
          __name(onClose, "onClose");
          onClose().catch(console.error);
        });
        const hasOnlyNotificationsOrResponses = messages.every(
          (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)
        );
        if (hasOnlyNotificationsOrResponses) {
          for (const message of messages) {
            ws.send(JSON.stringify(message));
          }
          ws.close();
          return new Response(null, {
            headers: corsHeaders(request, corsOptions),
            status: 202
          });
        }
        for (const message of messages) {
          if (isJSONRPCRequest(message)) {
            requestIds.add(message.id);
          }
          ws.send(JSON.stringify(message));
        }
        return new Response(readable, {
          headers: {
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Content-Type": "text/event-stream",
            "mcp-session-id": sessionId,
            ...corsHeaders(request, corsOptions)
          },
          status: 200
        });
      } else if (request.method === "GET") {
        const acceptHeader = request.headers.get("accept");
        if (!acceptHeader?.includes("text/event-stream")) {
          const body2 = JSON.stringify({
            jsonrpc: "2.0",
            error: {
              code: -32e3,
              message: "Not Acceptable: Client must accept text/event-stream"
            },
            id: null
          });
          return new Response(body2, { status: 406 });
        }
        const sessionId = url2.searchParams.get("sessionId");
        if (!sessionId)
          return new Response("Missing sessionId", { status: 400 });
        const { readable, writable } = new TransformStream();
        const writer = writable.getWriter();
        const encoder = new TextEncoder();
        const agent = await getAgentByName(
          namespace,
          `streamable-http:${sessionId}`,
          { props: ctx.props }
        );
        const isInitialized = await agent.isInitialized();
        if (!isInitialized) {
          return new Response(
            JSON.stringify({
              jsonrpc: "2.0",
              error: { code: -32001, message: "Session not found" },
              id: null
            }),
            { status: 404 }
          );
        }
        const existingHeaders = {};
        request.headers.forEach((v, k) => {
          existingHeaders[k] = v;
        });
        if (ctx.props) agent.updateProps(ctx.props);
        const response = await agent.fetch(
          new Request(request.url, {
            headers: {
              ...existingHeaders,
              Upgrade: "websocket"
            }
          })
        );
        const ws = response.webSocket;
        if (!ws) {
          await writer.close();
          return new Response("Failed to establish WS to DO", {
            status: 500
          });
        }
        ws.accept();
        ws.send(
          JSON.stringify({
            jsonrpc: "2.0",
            method: STANDALONE_SSE_METHOD,
            params: {}
          })
        );
        ws.addEventListener("message", (event) => {
          try {
            async function onMessage(ev) {
              const data = typeof ev.data === "string" ? ev.data : new TextDecoder().decode(ev.data);
              const parsed = JSONRPCMessageSchema2.safeParse(JSON.parse(data));
              if (!parsed.success) return;
              const frame = `event: message
data: ${JSON.stringify(parsed.data)}

`;
              await writer.write(encoder.encode(frame));
            }
            __name(onMessage, "onMessage");
            onMessage(event).catch(console.error);
          } catch (e) {
            console.error("Error forwarding message to SSE:", e);
          }
        });
        ws.addEventListener("error", () => {
          writer.close().catch(() => {
          });
        });
        ws.addEventListener("close", () => {
          writer.close().catch(() => {
          });
        });
        return new Response(readable, {
          headers: {
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Content-Type": "text/event-stream",
            "mcp-session-id": sessionId,
            ...corsHeaders(request, corsOptions)
          },
          status: 200
        });
      } else if (request.method === "DELETE") {
        const sessionId = request.headers.get("mcp-session-id");
        if (!sessionId) {
          return new Response(
            JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: "Bad Request: Mcp-Session-Id header is required"
              },
              id: null
            }),
            { status: 400, headers: corsHeaders(request, corsOptions) }
          );
        }
        const agent = await getAgentByName(
          namespace,
          `streamable-http:${sessionId}`
        );
        const isInitialized = await agent.isInitialized();
        if (!isInitialized) {
          return new Response(
            JSON.stringify({
              jsonrpc: "2.0",
              error: { code: -32001, message: "Session not found" },
              id: null
            }),
            { status: 404, headers: corsHeaders(request, corsOptions) }
          );
        }
        ctx.waitUntil(
          agent.destroy().catch(() => {
          })
        );
        return new Response(null, {
          status: 204,
          headers: corsHeaders(request, corsOptions)
        });
      }
    }
    const body = JSON.stringify({
      error: {
        code: -32e3,
        message: "Not found"
      },
      id: null,
      jsonrpc: "2.0"
    });
    return new Response(body, { status: 404 });
  };
}, "createStreamingHttpHandler");
var createLegacySseHandler = /* @__PURE__ */ __name((basePath, namespace, corsOptions) => {
  let pathname = basePath;
  if (basePath === "/") pathname = "/*";
  const basePattern = new URLPattern({ pathname });
  const messagePattern = new URLPattern({ pathname: `${basePath}/message` });
  return async (request, ctx) => {
    const url2 = new URL(request.url);
    if (request.method === "GET" && basePattern.test(url2)) {
      const sessionId = url2.searchParams.get("sessionId") || namespace.newUniqueId().toString();
      const { readable, writable } = new TransformStream();
      const writer = writable.getWriter();
      const encoder = new TextEncoder();
      const endpointUrl = new URL(request.url);
      endpointUrl.pathname = encodeURI(`${basePath}/message`);
      endpointUrl.searchParams.set("sessionId", sessionId);
      const relativeUrlWithSession = endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;
      const endpointMessage = `event: endpoint
data: ${relativeUrlWithSession}

`;
      writer.write(encoder.encode(endpointMessage));
      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {
        props: ctx.props
      });
      const existingHeaders = {};
      request.headers.forEach((value, key) => {
        existingHeaders[key] = value;
      });
      if (ctx.props) agent.updateProps(ctx.props);
      const response = await agent.fetch(
        new Request(request.url, {
          headers: {
            ...existingHeaders,
            Upgrade: "websocket"
          }
        })
      );
      const ws = response.webSocket;
      if (!ws) {
        console.error("Failed to establish WebSocket connection");
        await writer.close();
        return new Response("Failed to establish WebSocket connection", {
          status: 500
        });
      }
      ws.accept();
      ws.addEventListener("message", (event) => {
        async function onMessage(event2) {
          try {
            const message = JSON.parse(event2.data);
            const result = JSONRPCMessageSchema2.safeParse(message);
            if (!result.success) {
              return;
            }
            const messageText = `event: message
data: ${JSON.stringify(result.data)}

`;
            await writer.write(encoder.encode(messageText));
          } catch (error42) {
            console.error("Error forwarding message to SSE:", error42);
          }
        }
        __name(onMessage, "onMessage");
        onMessage(event).catch(console.error);
      });
      ws.addEventListener("error", (error42) => {
        async function onError(_error) {
          try {
            await writer.close();
          } catch (_e) {
          }
        }
        __name(onError, "onError");
        onError(error42).catch(console.error);
      });
      ws.addEventListener("close", () => {
        async function onClose() {
          try {
            await writer.close();
          } catch (error42) {
            console.error("Error closing SSE connection:", error42);
          }
        }
        __name(onClose, "onClose");
        onClose().catch(console.error);
      });
      return new Response(readable, {
        headers: {
          "Cache-Control": "no-cache",
          Connection: "keep-alive",
          "Content-Type": "text/event-stream",
          ...corsHeaders(request, corsOptions)
        }
      });
    }
    if (request.method === "POST" && messagePattern.test(url2)) {
      const sessionId = url2.searchParams.get("sessionId");
      if (!sessionId) {
        return new Response(
          `Missing sessionId. Expected POST to ${basePath} to initiate new one`,
          { status: 400 }
        );
      }
      const contentType2 = request.headers.get("content-type") || "";
      if (!contentType2.includes("application/json")) {
        return new Response(`Unsupported content-type: ${contentType2}`, {
          status: 400
        });
      }
      const contentLength = Number.parseInt(
        request.headers.get("content-length") || "0",
        10
      );
      if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
        return new Response(`Request body too large: ${contentLength} bytes`, {
          status: 400
        });
      }
      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {
        props: ctx.props
      });
      const messageBody = await request.json();
      const error42 = await agent.onSSEMcpMessage(sessionId, messageBody);
      if (error42) {
        return new Response(error42.message, {
          headers: {
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Content-Type": "text/event-stream",
            ...corsHeaders(request, corsOptions)
          },
          status: 400
        });
      }
      return new Response("Accepted", {
        headers: {
          "Cache-Control": "no-cache",
          Connection: "keep-alive",
          "Content-Type": "text/event-stream",
          ...corsHeaders(request, corsOptions)
        },
        status: 202
      });
    }
    return new Response("Not Found", { status: 404 });
  };
}, "createLegacySseHandler");
function corsHeaders(_request, corsOptions = {}) {
  const origin = "*";
  return {
    "Access-Control-Allow-Headers": corsOptions.headers || "Content-Type, Accept, mcp-session-id, mcp-protocol-version",
    "Access-Control-Allow-Methods": corsOptions.methods || "GET, POST, DELETE, OPTIONS",
    "Access-Control-Allow-Origin": corsOptions.origin || origin,
    "Access-Control-Expose-Headers": corsOptions.exposeHeaders || "mcp-session-id",
    "Access-Control-Max-Age": (corsOptions.maxAge || 86400).toString()
  };
}
__name(corsHeaders, "corsHeaders");
function handleCORS(request, corsOptions) {
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders(request, corsOptions) });
  }
  return null;
}
__name(handleCORS, "handleCORS");
function isDurableObjectNamespace(namespace) {
  return typeof namespace === "object" && namespace !== null && "newUniqueId" in namespace && typeof namespace.newUniqueId === "function" && "idFromName" in namespace && typeof namespace.idFromName === "function";
}
__name(isDurableObjectNamespace, "isDurableObjectNamespace");
var McpSSETransport = class {
  static {
    __name(this, "McpSSETransport");
  }
  constructor(getWebSocket) {
    this._started = false;
    this._getWebSocket = getWebSocket;
  }
  async start() {
    if (this._started) {
      throw new Error("Transport already started");
    }
    this._started = true;
  }
  async send(message) {
    if (!this._started) {
      throw new Error("Transport not started");
    }
    const websocket = this._getWebSocket();
    if (!websocket) {
      throw new Error("WebSocket not connected");
    }
    try {
      websocket.send(JSON.stringify(message));
    } catch (error42) {
      this.onerror?.(error42);
    }
  }
  async close() {
    this.onclose?.();
  }
};
var McpStreamableHttpTransport = class {
  static {
    __name(this, "McpStreamableHttpTransport");
  }
  constructor(getWebSocketForMessageID, notifyResponseIdSent, getWebSocketForStandaloneSse) {
    this._started = false;
    this._getWebSocketForMessageID = getWebSocketForMessageID;
    this._notifyResponseIdSent = notifyResponseIdSent;
    this._getWebSocketForStandaloneSse = getWebSocketForStandaloneSse;
  }
  async start() {
    if (this._started) {
      throw new Error("Transport already started");
    }
    this._started = true;
  }
  async send(message, options) {
    if (!this._started) {
      throw new Error("Transport not started");
    }
    let requestId = options?.relatedRequestId;
    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
      requestId = message.id;
    }
    if (requestId === void 0) {
      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
        throw new Error(
          "Cannot send a response on a standalone SSE stream unless resuming a previous client request"
        );
      }
      const standaloneSseSocket = this._getWebSocketForStandaloneSse();
      if (!standaloneSseSocket) {
        return;
      }
      try {
        standaloneSseSocket?.send(JSON.stringify(message));
      } catch (error42) {
        this.onerror?.(error42);
      }
      return;
    }
    const websocket = this._getWebSocketForMessageID(requestId.toString());
    if (!websocket) {
      throw new Error(`Could not find WebSocket for message id: ${requestId}`);
    }
    try {
      websocket?.send(JSON.stringify(message));
      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
        this._notifyResponseIdSent(message.id.toString());
      }
    } catch (error42) {
      this.onerror?.(error42);
    }
  }
  async close() {
    this.onclose?.();
  }
};
var McpAgent = class _McpAgent extends Agent {
  static {
    __name(this, "_McpAgent");
  }
  constructor(ctx, env2) {
    super(ctx, env2);
    this._requestIdToConnectionId = /* @__PURE__ */ new Map();
    for (const connection of this.getConnections()) {
      const meta = connection.state;
      if (meta?.role === STANDALONE_SSE_MARKER) {
        this._standaloneSseConnectionId = connection.id;
        return;
      }
    }
  }
  /*
   * Helpers
   */
  async setInitialized() {
    await this.ctx.storage.put("initialized", true);
  }
  async isInitialized() {
    return await this.ctx.storage.get("initialized") === true;
  }
  /** Read the transport type for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getTransportType() {
    const [t2, ..._] = this.name.split(":");
    switch (t2) {
      case "sse":
        return "sse";
      case "streamable-http":
        return "streamable-http";
      default:
        throw new Error(
          "Invalid transport type. McpAgent must be addressed with a valid protocol."
        );
    }
  }
  /** Get the WebSocket for the standalone SSE if any. Streamable HTTP only. */
  getWebSocketForStandaloneSse() {
    if (!this._standaloneSseConnectionId) return null;
    return this.getConnection(this._standaloneSseConnectionId) ?? null;
  }
  /** Get the unique WebSocket. SSE transport only. */
  getWebSocket() {
    const websockets = Array.from(this.getConnections());
    if (websockets.length === 0) {
      return null;
    }
    return websockets[0];
  }
  /** Get the corresponding WebSocket for a responseId. Streamable HTTP only. */
  getWebSocketForResponseID(id) {
    const connectionId = this._requestIdToConnectionId.get(id);
    if (connectionId === void 0) {
      return null;
    }
    return this.getConnection(connectionId) ?? null;
  }
  /** Returns a new transport matching the type of the Agent. */
  initTransport() {
    switch (this.getTransportType()) {
      case "sse": {
        return new McpSSETransport(() => this.getWebSocket());
      }
      case "streamable-http": {
        return new McpStreamableHttpTransport(
          (id) => this.getWebSocketForResponseID(id),
          (id) => this._requestIdToConnectionId.delete(id),
          () => this.getWebSocketForStandaloneSse()
        );
      }
    }
  }
  /** Update and store the props */
  async updateProps(props) {
    await this.ctx.storage.put("props", props ?? {});
    this.props = props;
  }
  /*
   * Base Agent / Parykit Server overrides
   */
  /** Sets up the MCP transport and server every time the Agent is started.*/
  async onStart(props) {
    if (props) await this.updateProps(props);
    this.props = await this.ctx.storage.get("props");
    await this.init();
    const server = await this.server;
    this._transport = this.initTransport();
    await server.connect(this._transport);
  }
  /** Validates new WebSocket connections. */
  async onConnect(conn, _) {
    switch (this.getTransportType()) {
      case "sse": {
        const websockets = Array.from(this.getConnections());
        if (websockets.length > 1) {
          conn.close(1008, "Websocket already connected");
          return;
        }
        break;
      }
      case "streamable-http":
        break;
    }
  }
  /** Handles MCP Messages for Streamable HTTP. */
  async onMessage(connection, event) {
    if (this.getTransportType() !== "streamable-http") {
      const err = new Error(
        "Internal Server Error: Expected streamable-http protocol"
      );
      this._transport?.onerror?.(err);
      return;
    }
    let message;
    try {
      const data = typeof event === "string" ? event : new TextDecoder().decode(event);
      message = JSONRPCMessageSchema2.parse(JSON.parse(data));
    } catch (error42) {
      this._transport?.onerror?.(error42);
      return;
    }
    if (isJSONRPCNotification(message) && message.method === STANDALONE_SSE_METHOD) {
      if (this._standaloneSseConnectionId && this._standaloneSseConnectionId !== connection.id) {
        const standaloneSseSocket = this.getConnection(
          this._standaloneSseConnectionId
        );
        standaloneSseSocket?.close(1e3, "replaced");
      }
      connection.setState({
        role: STANDALONE_SSE_MARKER
      });
      this._standaloneSseConnectionId = connection.id;
      return;
    }
    if (await this._handleElicitationResponse(message)) {
      return;
    }
    if (isJSONRPCRequest(message)) {
      this._requestIdToConnectionId.set(message.id.toString(), connection.id);
    }
    this._transport?.onmessage?.(message);
  }
  /** Remove clients from our cache when they disconnect */
  async onClose(conn, _code, _reason, _wasClean) {
    for (const [reqId, connId] of this._requestIdToConnectionId) {
      if (connId === conn.id) this._requestIdToConnectionId.delete(reqId);
    }
    if (this._standaloneSseConnectionId === conn.id) {
      this._standaloneSseConnectionId = void 0;
    }
  }
  /*
   * Transport ingress and routing
   */
  /** Handles MCP Messages for the legacy SSE transport. */
  async onSSEMcpMessage(_sessionId, messageBody) {
    if (this.getTransportType() !== "sse") {
      return new Error("Internal Server Error: Expected SSE transport");
    }
    try {
      let parsedMessage;
      try {
        parsedMessage = JSONRPCMessageSchema2.parse(messageBody);
      } catch (error42) {
        this._transport?.onerror?.(error42);
        throw error42;
      }
      if (await this._handleElicitationResponse(parsedMessage)) {
        return null;
      }
      this._transport?.onmessage?.(parsedMessage);
      return null;
    } catch (error42) {
      console.error("Error forwarding message to SSE:", error42);
      this._transport?.onerror?.(error42);
      return error42;
    }
  }
  /** Elicit user input with a message and schema */
  async elicitInput(params) {
    const requestId = `elicit_${Math.random().toString(36).substring(2, 11)}`;
    await this.ctx.storage.put(`elicitation:${requestId}`, {
      message: params.message,
      requestedSchema: params.requestedSchema,
      timestamp: Date.now()
    });
    const elicitRequest = {
      jsonrpc: "2.0",
      id: requestId,
      method: "elicitation/create",
      params: {
        message: params.message,
        requestedSchema: params.requestedSchema
      }
    };
    if (this._transport) {
      await this._transport.send(elicitRequest);
    } else {
      const connections2 = this.getConnections();
      if (!connections2 || Array.from(connections2).length === 0) {
        await this.ctx.storage.delete(`elicitation:${requestId}`);
        throw new Error("No active connections available for elicitation");
      }
      const connectionList = Array.from(connections2);
      for (const connection of connectionList) {
        try {
          connection.send(JSON.stringify(elicitRequest));
        } catch (error42) {
          console.error("Failed to send elicitation request:", error42);
        }
      }
    }
    return this._waitForElicitationResponse(requestId);
  }
  /** Wait for elicitation response through storage polling */
  async _waitForElicitationResponse(requestId) {
    const startTime = Date.now();
    const timeout = 6e4;
    try {
      while (Date.now() - startTime < timeout) {
        const response = await this.ctx.storage.get(
          `elicitation:response:${requestId}`
        );
        if (response) {
          await this.ctx.storage.delete(`elicitation:${requestId}`);
          await this.ctx.storage.delete(`elicitation:response:${requestId}`);
          return response;
        }
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      throw new Error("Elicitation request timed out");
    } finally {
      await this.ctx.storage.delete(`elicitation:${requestId}`);
      await this.ctx.storage.delete(`elicitation:response:${requestId}`);
    }
  }
  /** Handle elicitation responses */
  async _handleElicitationResponse(message) {
    if (isJSONRPCResponse(message) && message.result) {
      const requestId = message.id?.toString();
      if (!requestId || !requestId.startsWith("elicit_")) return false;
      const pendingRequest = await this.ctx.storage.get(
        `elicitation:${requestId}`
      );
      if (!pendingRequest) return false;
      await this.ctx.storage.put(
        `elicitation:response:${requestId}`,
        message.result
      );
      return true;
    }
    if (isJSONRPCError(message)) {
      const requestId = message.id?.toString();
      if (!requestId || !requestId.startsWith("elicit_")) return false;
      const pendingRequest = await this.ctx.storage.get(
        `elicitation:${requestId}`
      );
      if (!pendingRequest) return false;
      const errorResult = {
        action: "cancel",
        content: {
          error: message.error.message || "Elicitation request failed"
        }
      };
      await this.ctx.storage.put(
        `elicitation:response:${requestId}`,
        errorResult
      );
      return true;
    }
    return false;
  }
  /** Return a handler for the given path for this MCP.
   * Defaults to Streamable HTTP transport.
   */
  static serve(path2, {
    binding: binding2 = "MCP_OBJECT",
    corsOptions,
    transport = "streamable-http"
  } = {}) {
    return {
      async fetch(request, env2, ctx) {
        const corsResponse = handleCORS(request, corsOptions);
        if (corsResponse) {
          return corsResponse;
        }
        const bindingValue = env2[binding2];
        if (bindingValue == null || typeof bindingValue !== "object") {
          throw new Error(
            `Could not find McpAgent binding for ${binding2}. Did you update your wrangler configuration?`
          );
        }
        if (!isDurableObjectNamespace(bindingValue)) {
          throw new Error(
            `Invalid McpAgent binding for ${binding2}. Make sure it's a Durable Object binding.`
          );
        }
        const namespace = bindingValue;
        switch (transport) {
          case "streamable-http": {
            const handleStreamableHttp = createStreamingHttpHandler(
              path2,
              namespace,
              corsOptions
            );
            return handleStreamableHttp(request, ctx);
          }
          case "sse": {
            const handleLegacySse = createLegacySseHandler(
              path2,
              namespace,
              corsOptions
            );
            return handleLegacySse(request, ctx);
          }
          default:
            return new Response(
              "Invalid MCP transport mode. Only `streamable-http` or `sse` are allowed.",
              { status: 500 }
            );
        }
      }
    };
  }
  /**
   * Legacy api
   **/
  static mount(path2, opts = {}) {
    return _McpAgent.serveSSE(path2, opts);
  }
  static serveSSE(path2, opts = {}) {
    return _McpAgent.serve(path2, { ...opts, transport: "sse" });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_ajv2 = __toESM(require_ajv(), 1);
var Server2 = class extends Protocol {
  static {
    __name(this, "Server");
  }
  /**
   * Initializes this server with the given name and version information.
   */
  constructor(_serverInfo, options) {
    var _a18;
    super(options);
    this._serverInfo = _serverInfo;
    this._loggingLevels = /* @__PURE__ */ new Map();
    this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index]));
    this.isMessageIgnored = (level, sessionId) => {
      const currentLevel = this._loggingLevels.get(sessionId);
      return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : false;
    };
    this._capabilities = (_a18 = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a18 !== void 0 ? _a18 : {};
    this._instructions = options === null || options === void 0 ? void 0 : options.instructions;
    this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
    this.setNotificationHandler(InitializedNotificationSchema, () => {
      var _a19;
      return (_a19 = this.oninitialized) === null || _a19 === void 0 ? void 0 : _a19.call(this);
    });
    if (this._capabilities.logging) {
      this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
        var _a19;
        const transportSessionId = extra.sessionId || ((_a19 = extra.requestInfo) === null || _a19 === void 0 ? void 0 : _a19.headers["mcp-session-id"]) || void 0;
        const { level } = request.params;
        const parseResult = LoggingLevelSchema.safeParse(level);
        if (parseResult.success) {
          this._loggingLevels.set(transportSessionId, parseResult.data);
        }
        return {};
      });
    }
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  assertCapabilityForMethod(method) {
    var _a18, _b, _c;
    switch (method) {
      case "sampling/createMessage":
        if (!((_a18 = this._clientCapabilities) === null || _a18 === void 0 ? void 0 : _a18.sampling)) {
          throw new Error(`Client does not support sampling (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!((_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation)) {
          throw new Error(`Client does not support elicitation (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!((_c = this._clientCapabilities) === null || _c === void 0 ? void 0 : _c.roots)) {
          throw new Error(`Client does not support listing roots (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        }
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        }
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        }
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Server does not support sampling (required for ${method})`);
        }
        break;
      case "logging/setLevel":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "ping":
      case "initialize":
        break;
    }
  }
  async _oninitialize(request) {
    const requestedVersion = request.params.protocolVersion;
    this._clientCapabilities = request.params.capabilities;
    this._clientVersion = request.params.clientInfo;
    const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;
    return {
      protocolVersion,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  /**
   * After initialization has completed, this will be populated with the client's reported capabilities.
   */
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the client's name and version.
   */
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  async createMessage(params, options) {
    return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  async elicitInput(params, options) {
    const result = await this.request({ method: "elicitation/create", params }, ElicitResultSchema, options);
    if (result.action === "accept" && result.content) {
      try {
        const ajv = new import_ajv2.default();
        const validate = ajv.compile(params.requestedSchema);
        const isValid2 = validate(result.content);
        if (!isValid2) {
          throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${ajv.errorsText(validate.errors)}`);
        }
      } catch (error42) {
        if (error42 instanceof McpError) {
          throw error42;
        }
        throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error42}`);
      }
    }
    return result;
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    if (this._capabilities.logging) {
      if (!this.isMessageIgnored(params.level, sessionId)) {
        return this.notification({ method: "notifications/message", params });
      }
    }
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
};

// node_modules/zod-to-json-schema/dist/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/Options.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ignoreOverride2 = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions2 = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
}, "getDefaultOptions");

// node_modules/zod-to-json-schema/dist/esm/Refs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getRefs2 = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions2(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name17, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name17],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
}, "getRefs");

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");

// node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getRelativePath2 = /* @__PURE__ */ __name((pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) {
    if (pathA[i2] !== pathB[i2])
      break;
  }
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
}, "getRelativePath");

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseAnyDef2(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath2(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
__name(parseAnyDef2, "parseAnyDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseArrayDef2(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef2(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef2, "parseArrayDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseBigintDef2(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef2, "parseBigintDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseBooleanDef2() {
  return {
    type: "boolean"
  };
}
__name(parseBooleanDef2, "parseBooleanDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
__name(parseBrandedDef2, "parseBrandedDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseCatchDef2 = /* @__PURE__ */ __name((def, refs) => {
  return parseDef2(def.innerType._def, refs);
}, "parseCatchDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef2(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def, refs);
  }
}
__name(parseDateDef2, "parseDateDef");
var integerDateParser2 = /* @__PURE__ */ __name((def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check2.value,
          // This is in milliseconds
          check2.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check2.value,
          // This is in milliseconds
          check2.message,
          refs
        );
        break;
    }
  }
  return res;
}, "integerDateParser");

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseDefaultDef2(_def, refs) {
  return {
    ...parseDef2(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
__name(parseDefaultDef2, "parseDefaultDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseEffectsDef2(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs) : parseAnyDef2(refs);
}
__name(parseEffectsDef2, "parseEffectsDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
__name(parseEnumDef2, "parseEnumDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isJsonSchema7AllOfType2 = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef2(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema115) => {
    if (isJsonSchema7AllOfType2(schema115)) {
      mergedAllOf.push(...schema115.allOf);
      if (schema115.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema115;
      if ("additionalProperties" in schema115 && schema115.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema115;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
__name(parseIntersectionDef2, "parseIntersectionDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseLiteralDef2(def, refs) {
  const parsedType4 = typeof def.value;
  if (parsedType4 !== "bigint" && parsedType4 !== "number" && parsedType4 !== "boolean" && parsedType4 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType4 === "bigint" ? "integer" : parsedType4,
      enum: [def.value]
    };
  }
  return {
    type: parsedType4 === "bigint" ? "integer" : parsedType4,
    const: def.value
  };
}
__name(parseLiteralDef2, "parseLiteralDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var emojiRegex3 = void 0;
var zodPatterns2 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: /* @__PURE__ */ __name(() => {
    if (emojiRegex3 === void 0) {
      emojiRegex3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex3;
  }, "emoji"),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef2(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern2(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern2(res, RegExp(`^${escapeLiteralCheckValue2(check2.value, refs)}`), check2.message, refs);
          break;
        case "endsWith":
          addPattern2(res, RegExp(`${escapeLiteralCheckValue2(check2.value, refs)}$`), check2.message, refs);
          break;
        case "datetime":
          addFormat2(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check2.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "includes": {
          addPattern2(res, RegExp(escapeLiteralCheckValue2(check2.value, refs)), check2.message, refs);
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat2(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat2(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern2(res, zodPatterns2.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern2(res, zodPatterns2.jwt, check2.message, refs);
          break;
        case "cidr": {
          if (check2.version !== "v6") {
            addPattern2(res, zodPatterns2.ipv4Cidr, check2.message, refs);
          }
          if (check2.version !== "v4") {
            addPattern2(res, zodPatterns2.ipv6Cidr, check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji(), check2.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check2.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check2);
      }
    }
  }
  return res;
}
__name(parseStringDef2, "parseStringDef");
function escapeLiteralCheckValue2(literal2, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal2) : literal2;
}
__name(escapeLiteralCheckValue2, "escapeLiteralCheckValue");
var ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric2(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC2.has(source[i2])) {
      result += "\\";
    }
    result += source[i2];
  }
  return result;
}
__name(escapeNonAlphaNumeric2, "escapeNonAlphaNumeric");
function addFormat2(schema115, value, message, refs) {
  if (schema115.format || schema115.anyOf?.some((x) => x.format)) {
    if (!schema115.anyOf) {
      schema115.anyOf = [];
    }
    if (schema115.format) {
      schema115.anyOf.push({
        format: schema115.format,
        ...schema115.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema115.errorMessage.format }
        }
      });
      delete schema115.format;
      if (schema115.errorMessage) {
        delete schema115.errorMessage.format;
        if (Object.keys(schema115.errorMessage).length === 0) {
          delete schema115.errorMessage;
        }
      }
    }
    schema115.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema115, "format", value, message, refs);
  }
}
__name(addFormat2, "addFormat");
function addPattern2(schema115, regex, message, refs) {
  if (schema115.pattern || schema115.allOf?.some((x) => x.pattern)) {
    if (!schema115.allOf) {
      schema115.allOf = [];
    }
    if (schema115.pattern) {
      schema115.allOf.push({
        pattern: schema115.pattern,
        ...schema115.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema115.errorMessage.pattern }
        }
      });
      delete schema115.pattern;
      if (schema115.errorMessage) {
        delete schema115.errorMessage.pattern;
        if (Object.keys(schema115.errorMessage).length === 0) {
          delete schema115.errorMessage;
        }
      }
    }
    schema115.allOf.push({
      pattern: stringifyRegExpWithFlags2(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema115, "pattern", stringifyRegExpWithFlags2(regex, refs), message, refs);
  }
}
__name(addPattern2, "addPattern");
function stringifyRegExpWithFlags2(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && source[i2 + 2]?.match(/[a-z]/)) {
            pattern += source[i2];
            inCharRange = true;
          } else {
            pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i2] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i2] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}
__name(stringifyRegExpWithFlags2, "stringifyRegExpWithFlags");

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef2(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef2(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef2(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema115 = {
    type: "object",
    additionalProperties: parseDef2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema115;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef2(def.keyType._def, refs);
    return {
      ...schema115,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema115,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef2(def.keyType._def, refs);
    return {
      ...schema115,
      propertyNames: keyType
    };
  }
  return schema115;
}
__name(parseRecordDef2, "parseRecordDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef2(def, refs);
  }
  const keys2 = parseDef2(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef2(refs);
  const values = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef2(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys2, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef2, "parseMapDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNativeEnumDef2(def) {
  const object4 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object4[object4[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object4[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
__name(parseNativeEnumDef2, "parseNativeEnumDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNeverDef2(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef2({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}
__name(parseNeverDef2, "parseNeverDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNullDef2(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef2, "parseNullDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var primitiveMappings2 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef2(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf2(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings2[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i2, a2) => a2.indexOf(x) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf2(def, refs);
}
__name(parseUnionDef2, "parseUnionDef");
var asAnyOf2 = /* @__PURE__ */ __name((def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef2(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i2}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
}, "asAnyOf");

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef2(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings2[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings2[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef2, "parseNullableDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNumberDef2(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check2.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef2, "parseNumberDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseObjectDef2(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required2 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional2(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef2(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required2.push(propName);
    }
  }
  if (required2.length) {
    result.required = required2;
  }
  const additionalProperties = decideAdditionalProperties2(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
__name(parseObjectDef2, "parseObjectDef");
function decideAdditionalProperties2(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
__name(decideAdditionalProperties2, "decideAdditionalProperties");
function safeIsOptional2(schema115) {
  try {
    return schema115.isOptional();
  } catch {
    return true;
  }
}
__name(safeIsOptional2, "safeIsOptional");

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseOptionalDef2 = /* @__PURE__ */ __name((def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef2(def.innerType._def, refs);
  }
  const innerSchema = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef2(refs)
      },
      innerSchema
    ]
  } : parseAnyDef2(refs);
}, "parseOptionalDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsePipelineDef2 = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef2(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef2(def.out._def, refs);
  }
  const a2 = parseDef2(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef2(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
  });
  return {
    allOf: [a2, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
__name(parsePromiseDef2, "parsePromiseDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema115 = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema115, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema115, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema115;
}
__name(parseSetDef2, "parseSetDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseTupleDef2(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i2) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef2(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i2) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
__name(parseTupleDef2, "parseTupleDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseUndefinedDef2(refs) {
  return {
    not: parseAnyDef2(refs)
  };
}
__name(parseUndefinedDef2, "parseUndefinedDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseUnknownDef2(refs) {
  return parseAnyDef2(refs);
}
__name(parseUnknownDef2, "parseUnknownDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseReadonlyDef2 = /* @__PURE__ */ __name((def, refs) => {
  return parseDef2(def.innerType._def, refs);
}, "parseReadonlyDef");

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser2 = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef2();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef2(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef2(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef2(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef2(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef2(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef2(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride2) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);
  const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema2) {
    addMeta2(def, refs, jsonSchema2);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    newItem.jsonSchema = jsonSchema2;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema2;
  return jsonSchema2;
}
__name(parseDef2, "parseDef");
var get$ref2 = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath2(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef2(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef2(refs) : void 0;
    }
  }
}, "get$ref");
var addMeta2 = /* @__PURE__ */ __name((def, refs, jsonSchema2) => {
  if (def.description) {
    jsonSchema2.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema2.markdownDescription = def.description;
    }
  }
  return jsonSchema2;
}, "addMeta");

// node_modules/zod-to-json-schema/dist/esm/parseTypes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var zodToJsonSchema2 = /* @__PURE__ */ __name((schema115, options) => {
  const refs = getRefs2(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name18, schema116]) => ({
    ...acc,
    [name18]: parseDef2(schema116._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name18]
    }, true) ?? parseAnyDef2(refs)
  }), {}) : void 0;
  const name17 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef2(schema115._def, name17 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name17]
  }, false) ?? parseAnyDef2(refs);
  const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title2 !== void 0) {
    main.title = title2;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name17 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name17
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name17]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
}, "zodToJsonSchema");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/completable.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var McpZodTypeKind;
(function(McpZodTypeKind2) {
  McpZodTypeKind2["Completable"] = "McpCompletable";
})(McpZodTypeKind || (McpZodTypeKind = {}));
var Completable = class extends ZodType2 {
  static {
    __name(this, "Completable");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
Completable.create = (type, params) => {
  return new Completable({
    type,
    typeName: McpZodTypeKind.Completable,
    complete: params.complete,
    ...processCreateParams2(params)
  });
};
function processCreateParams2(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a18, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a18 = message !== null && message !== void 0 ? message : required_error) !== null && _a18 !== void 0 ? _a18 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams2, "processCreateParams");

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/uriTemplate.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js
var McpServer = class {
  static {
    __name(this, "McpServer");
  }
  constructor(serverInfo, options) {
    this._registeredResources = {};
    this._registeredResourceTemplates = {};
    this._registeredTools = {};
    this._registeredPrompts = {};
    this._toolHandlersInitialized = false;
    this._completionHandlerInitialized = false;
    this._resourceHandlersInitialized = false;
    this._promptHandlersInitialized = false;
    this.server = new Server2(serverInfo, options);
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The `server` object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    return await this.server.connect(transport);
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this.server.close();
  }
  setToolRequestHandlers() {
    if (this._toolHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListToolsRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(CallToolRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      tools: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListToolsRequestSchema, () => ({
      tools: Object.entries(this._registeredTools).filter(([, tool2]) => tool2.enabled).map(([name17, tool2]) => {
        const toolDefinition = {
          name: name17,
          title: tool2.title,
          description: tool2.description,
          inputSchema: tool2.inputSchema ? zodToJsonSchema2(tool2.inputSchema, {
            strictUnions: true
          }) : EMPTY_OBJECT_JSON_SCHEMA,
          annotations: tool2.annotations,
          _meta: tool2._meta
        };
        if (tool2.outputSchema) {
          toolDefinition.outputSchema = zodToJsonSchema2(tool2.outputSchema, { strictUnions: true });
        }
        return toolDefinition;
      })
    }));
    this.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
      const tool2 = this._registeredTools[request.params.name];
      if (!tool2) {
        throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} not found`);
      }
      if (!tool2.enabled) {
        throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} disabled`);
      }
      let result;
      if (tool2.inputSchema) {
        const parseResult = await tool2.inputSchema.safeParseAsync(request.params.arguments);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`);
        }
        const args = parseResult.data;
        const cb = tool2.callback;
        try {
          result = await Promise.resolve(cb(args, extra));
        } catch (error42) {
          result = {
            content: [
              {
                type: "text",
                text: error42 instanceof Error ? error42.message : String(error42)
              }
            ],
            isError: true
          };
        }
      } else {
        const cb = tool2.callback;
        try {
          result = await Promise.resolve(cb(extra));
        } catch (error42) {
          result = {
            content: [
              {
                type: "text",
                text: error42 instanceof Error ? error42.message : String(error42)
              }
            ],
            isError: true
          };
        }
      }
      if (tool2.outputSchema && !result.isError) {
        if (!result.structuredContent) {
          throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} has an output schema but no structured content was provided`);
        }
        const parseResult = await tool2.outputSchema.safeParseAsync(result.structuredContent);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid structured content for tool ${request.params.name}: ${parseResult.error.message}`);
        }
      }
      return result;
    });
    this._toolHandlersInitialized = true;
  }
  setCompletionRequestHandler() {
    if (this._completionHandlerInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(CompleteRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      completions: {}
    });
    this.server.setRequestHandler(CompleteRequestSchema, async (request) => {
      switch (request.params.ref.type) {
        case "ref/prompt":
          return this.handlePromptCompletion(request, request.params.ref);
        case "ref/resource":
          return this.handleResourceCompletion(request, request.params.ref);
        default:
          throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request.params.ref}`);
      }
    });
    this._completionHandlerInitialized = true;
  }
  async handlePromptCompletion(request, ref) {
    const prompt = this._registeredPrompts[ref.name];
    if (!prompt) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} not found`);
    }
    if (!prompt.enabled) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} disabled`);
    }
    if (!prompt.argsSchema) {
      return EMPTY_COMPLETION_RESULT;
    }
    const field = prompt.argsSchema.shape[request.params.argument.name];
    if (!(field instanceof Completable)) {
      return EMPTY_COMPLETION_RESULT;
    }
    const def = field._def;
    const suggestions = await def.complete(request.params.argument.value, request.params.context);
    return createCompletionResult(suggestions);
  }
  async handleResourceCompletion(request, ref) {
    const template = Object.values(this._registeredResourceTemplates).find((t2) => t2.resourceTemplate.uriTemplate.toString() === ref.uri);
    if (!template) {
      if (this._registeredResources[ref.uri]) {
        return EMPTY_COMPLETION_RESULT;
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource template ${request.params.ref.uri} not found`);
    }
    const completer = template.resourceTemplate.completeCallback(request.params.argument.name);
    if (!completer) {
      return EMPTY_COMPLETION_RESULT;
    }
    const suggestions = await completer(request.params.argument.value, request.params.context);
    return createCompletionResult(suggestions);
  }
  setResourceRequestHandlers() {
    if (this._resourceHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListResourcesRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(ListResourceTemplatesRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(ReadResourceRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      resources: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListResourcesRequestSchema, async (request, extra) => {
      const resources = Object.entries(this._registeredResources).filter(([_, resource]) => resource.enabled).map(([uri, resource]) => ({
        uri,
        name: resource.name,
        ...resource.metadata
      }));
      const templateResources = [];
      for (const template of Object.values(this._registeredResourceTemplates)) {
        if (!template.resourceTemplate.listCallback) {
          continue;
        }
        const result = await template.resourceTemplate.listCallback(extra);
        for (const resource of result.resources) {
          templateResources.push({
            ...template.metadata,
            // the defined resource metadata should override the template metadata if present
            ...resource
          });
        }
      }
      return { resources: [...resources, ...templateResources] };
    });
    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
      const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name17, template]) => ({
        name: name17,
        uriTemplate: template.resourceTemplate.uriTemplate.toString(),
        ...template.metadata
      }));
      return { resourceTemplates };
    });
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {
      const uri = new URL(request.params.uri);
      const resource = this._registeredResources[uri.toString()];
      if (resource) {
        if (!resource.enabled) {
          throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} disabled`);
        }
        return resource.readCallback(uri, extra);
      }
      for (const template of Object.values(this._registeredResourceTemplates)) {
        const variables = template.resourceTemplate.uriTemplate.match(uri.toString());
        if (variables) {
          return template.readCallback(uri, variables, extra);
        }
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);
    });
    this.setCompletionRequestHandler();
    this._resourceHandlersInitialized = true;
  }
  setPromptRequestHandlers() {
    if (this._promptHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListPromptsRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(GetPromptRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      prompts: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListPromptsRequestSchema, () => ({
      prompts: Object.entries(this._registeredPrompts).filter(([, prompt]) => prompt.enabled).map(([name17, prompt]) => {
        return {
          name: name17,
          title: prompt.title,
          description: prompt.description,
          arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : void 0
        };
      })
    }));
    this.server.setRequestHandler(GetPromptRequestSchema, async (request, extra) => {
      const prompt = this._registeredPrompts[request.params.name];
      if (!prompt) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} not found`);
      }
      if (!prompt.enabled) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} disabled`);
      }
      if (prompt.argsSchema) {
        const parseResult = await prompt.argsSchema.safeParseAsync(request.params.arguments);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for prompt ${request.params.name}: ${parseResult.error.message}`);
        }
        const args = parseResult.data;
        const cb = prompt.callback;
        return await Promise.resolve(cb(args, extra));
      } else {
        const cb = prompt.callback;
        return await Promise.resolve(cb(extra));
      }
    });
    this.setCompletionRequestHandler();
    this._promptHandlersInitialized = true;
  }
  resource(name17, uriOrTemplate, ...rest) {
    let metadata;
    if (typeof rest[0] === "object") {
      metadata = rest.shift();
    }
    const readCallback = rest[0];
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      const registeredResource = this._createRegisteredResource(name17, void 0, uriOrTemplate, metadata, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResource;
    } else {
      if (this._registeredResourceTemplates[name17]) {
        throw new Error(`Resource template ${name17} is already registered`);
      }
      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name17, void 0, uriOrTemplate, metadata, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResourceTemplate;
    }
  }
  registerResource(name17, uriOrTemplate, config3, readCallback) {
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      const registeredResource = this._createRegisteredResource(name17, config3.title, uriOrTemplate, config3, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResource;
    } else {
      if (this._registeredResourceTemplates[name17]) {
        throw new Error(`Resource template ${name17} is already registered`);
      }
      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name17, config3.title, uriOrTemplate, config3, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResourceTemplate;
    }
  }
  _createRegisteredResource(name17, title2, uri, metadata, readCallback) {
    const registeredResource = {
      name: name17,
      title: title2,
      metadata,
      readCallback,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredResource.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredResource.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredResource.update({ uri: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.uri !== "undefined" && updates.uri !== uri) {
          delete this._registeredResources[uri];
          if (updates.uri)
            this._registeredResources[updates.uri] = registeredResource;
        }
        if (typeof updates.name !== "undefined")
          registeredResource.name = updates.name;
        if (typeof updates.title !== "undefined")
          registeredResource.title = updates.title;
        if (typeof updates.metadata !== "undefined")
          registeredResource.metadata = updates.metadata;
        if (typeof updates.callback !== "undefined")
          registeredResource.readCallback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredResource.enabled = updates.enabled;
        this.sendResourceListChanged();
      }, "update")
    };
    this._registeredResources[uri] = registeredResource;
    return registeredResource;
  }
  _createRegisteredResourceTemplate(name17, title2, template, metadata, readCallback) {
    const registeredResourceTemplate = {
      resourceTemplate: template,
      title: title2,
      metadata,
      readCallback,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredResourceTemplate.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredResourceTemplate.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredResourceTemplate.update({ name: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name17) {
          delete this._registeredResourceTemplates[name17];
          if (updates.name)
            this._registeredResourceTemplates[updates.name] = registeredResourceTemplate;
        }
        if (typeof updates.title !== "undefined")
          registeredResourceTemplate.title = updates.title;
        if (typeof updates.template !== "undefined")
          registeredResourceTemplate.resourceTemplate = updates.template;
        if (typeof updates.metadata !== "undefined")
          registeredResourceTemplate.metadata = updates.metadata;
        if (typeof updates.callback !== "undefined")
          registeredResourceTemplate.readCallback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredResourceTemplate.enabled = updates.enabled;
        this.sendResourceListChanged();
      }, "update")
    };
    this._registeredResourceTemplates[name17] = registeredResourceTemplate;
    return registeredResourceTemplate;
  }
  _createRegisteredPrompt(name17, title2, description, argsSchema, callback) {
    const registeredPrompt = {
      title: title2,
      description,
      argsSchema: argsSchema === void 0 ? void 0 : external_exports2.object(argsSchema),
      callback,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredPrompt.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredPrompt.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredPrompt.update({ name: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name17) {
          delete this._registeredPrompts[name17];
          if (updates.name)
            this._registeredPrompts[updates.name] = registeredPrompt;
        }
        if (typeof updates.title !== "undefined")
          registeredPrompt.title = updates.title;
        if (typeof updates.description !== "undefined")
          registeredPrompt.description = updates.description;
        if (typeof updates.argsSchema !== "undefined")
          registeredPrompt.argsSchema = external_exports2.object(updates.argsSchema);
        if (typeof updates.callback !== "undefined")
          registeredPrompt.callback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredPrompt.enabled = updates.enabled;
        this.sendPromptListChanged();
      }, "update")
    };
    this._registeredPrompts[name17] = registeredPrompt;
    return registeredPrompt;
  }
  _createRegisteredTool(name17, title2, description, inputSchema, outputSchema2, annotations, _meta, callback) {
    const registeredTool = {
      title: title2,
      description,
      inputSchema: inputSchema === void 0 ? void 0 : external_exports2.object(inputSchema),
      outputSchema: outputSchema2 === void 0 ? void 0 : external_exports2.object(outputSchema2),
      annotations,
      _meta,
      callback,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredTool.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredTool.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredTool.update({ name: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name17) {
          delete this._registeredTools[name17];
          if (updates.name)
            this._registeredTools[updates.name] = registeredTool;
        }
        if (typeof updates.title !== "undefined")
          registeredTool.title = updates.title;
        if (typeof updates.description !== "undefined")
          registeredTool.description = updates.description;
        if (typeof updates.paramsSchema !== "undefined")
          registeredTool.inputSchema = external_exports2.object(updates.paramsSchema);
        if (typeof updates.callback !== "undefined")
          registeredTool.callback = updates.callback;
        if (typeof updates.annotations !== "undefined")
          registeredTool.annotations = updates.annotations;
        if (typeof updates._meta !== "undefined")
          registeredTool._meta = updates._meta;
        if (typeof updates.enabled !== "undefined")
          registeredTool.enabled = updates.enabled;
        this.sendToolListChanged();
      }, "update")
    };
    this._registeredTools[name17] = registeredTool;
    this.setToolRequestHandlers();
    this.sendToolListChanged();
    return registeredTool;
  }
  /**
   * tool() implementation. Parses arguments passed to overrides defined above.
   */
  tool(name17, ...rest) {
    if (this._registeredTools[name17]) {
      throw new Error(`Tool ${name17} is already registered`);
    }
    let description;
    let inputSchema;
    let outputSchema2;
    let annotations;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    if (rest.length > 1) {
      const firstArg = rest[0];
      if (isZodRawShape(firstArg)) {
        inputSchema = rest.shift();
        if (rest.length > 1 && typeof rest[0] === "object" && rest[0] !== null && !isZodRawShape(rest[0])) {
          annotations = rest.shift();
        }
      } else if (typeof firstArg === "object" && firstArg !== null) {
        annotations = rest.shift();
      }
    }
    const callback = rest[0];
    return this._createRegisteredTool(name17, void 0, description, inputSchema, outputSchema2, annotations, void 0, callback);
  }
  /**
   * Registers a tool with a config object and callback.
   */
  registerTool(name17, config3, cb) {
    if (this._registeredTools[name17]) {
      throw new Error(`Tool ${name17} is already registered`);
    }
    const { title: title2, description, inputSchema, outputSchema: outputSchema2, annotations, _meta } = config3;
    return this._createRegisteredTool(name17, title2, description, inputSchema, outputSchema2, annotations, _meta, cb);
  }
  prompt(name17, ...rest) {
    if (this._registeredPrompts[name17]) {
      throw new Error(`Prompt ${name17} is already registered`);
    }
    let description;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    let argsSchema;
    if (rest.length > 1) {
      argsSchema = rest.shift();
    }
    const cb = rest[0];
    const registeredPrompt = this._createRegisteredPrompt(name17, void 0, description, argsSchema, cb);
    this.setPromptRequestHandlers();
    this.sendPromptListChanged();
    return registeredPrompt;
  }
  /**
   * Registers a prompt with a config object and callback.
   */
  registerPrompt(name17, config3, cb) {
    if (this._registeredPrompts[name17]) {
      throw new Error(`Prompt ${name17} is already registered`);
    }
    const { title: title2, description, argsSchema } = config3;
    const registeredPrompt = this._createRegisteredPrompt(name17, title2, description, argsSchema, cb);
    this.setPromptRequestHandlers();
    this.sendPromptListChanged();
    return registeredPrompt;
  }
  /**
   * Checks if the server is connected to a transport.
   * @returns True if the server is connected
   */
  isConnected() {
    return this.server.transport !== void 0;
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    return this.server.sendLoggingMessage(params, sessionId);
  }
  /**
   * Sends a resource list changed event to the client, if connected.
   */
  sendResourceListChanged() {
    if (this.isConnected()) {
      this.server.sendResourceListChanged();
    }
  }
  /**
   * Sends a tool list changed event to the client, if connected.
   */
  sendToolListChanged() {
    if (this.isConnected()) {
      this.server.sendToolListChanged();
    }
  }
  /**
   * Sends a prompt list changed event to the client, if connected.
   */
  sendPromptListChanged() {
    if (this.isConnected()) {
      this.server.sendPromptListChanged();
    }
  }
};
var EMPTY_OBJECT_JSON_SCHEMA = {
  type: "object",
  properties: {}
};
function isZodRawShape(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  const isEmptyObject = Object.keys(obj).length === 0;
  return isEmptyObject || Object.values(obj).some(isZodTypeLike);
}
__name(isZodRawShape, "isZodRawShape");
function isZodTypeLike(value) {
  return value !== null && typeof value === "object" && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
__name(isZodTypeLike, "isZodTypeLike");
function promptArgumentsFromSchema(schema115) {
  return Object.entries(schema115.shape).map(([name17, field]) => ({
    name: name17,
    description: field.description,
    required: !field.isOptional()
  }));
}
__name(promptArgumentsFromSchema, "promptArgumentsFromSchema");
function createCompletionResult(suggestions) {
  return {
    completion: {
      values: suggestions.slice(0, 100),
      total: suggestions.length,
      hasMore: suggestions.length > 100
    }
  };
}
__name(createCompletionResult, "createCompletionResult");
var EMPTY_COMPLETION_RESULT = {
  completion: {
    values: [],
    hasMore: false
  }
};

// node_modules/flowmcp/src/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/flowmcp/src/task/Interface.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/flowmcp/src/task/Validation.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Validation = class _Validation {
  static {
    __name(this, "Validation");
  }
  static getTypes() {
    const types = {
      "version": "1.2",
      "types": {
        "meta": [
          ["namespace", "string"],
          ["name", "string"],
          ["description", "string"],
          ["docs", "arrayOfStrings"],
          ["tags", "arrayOfStrings"],
          // [ 'version',              'string'              ],
          ["flowMCP", "string"],
          ["root", "string"],
          ["requiredServerParams", "arrayOfStrings"],
          ["headers", "objectKeyValues"],
          ["routes", "objectOfObjects"],
          ["handlers", "objectKeyFunctions"]
        ],
        "route": [
          ["requestMethod", "string"],
          ["description", "string"],
          ["route", "string"],
          ["parameters", "arrayOfObjects"],
          ["tests", "arrayOfObjects"],
          ["modifiers", "arrayOfObjects"]
        ],
        "parametes": [
          ["position", "arrayOfStrings"]
        ],
        "position": [
          ["key", "string"],
          ["value", "string"],
          ["location", "string"]
        ],
        "z": [
          ["primitive", "string"],
          ["options", "arrayOfStrings"]
        ],
        "tests": [
          ["_description", "string"]
        ],
        "modifiers": [
          ["phase", "string"],
          ["handlerName", "string"]
        ]
      },
      "enums": {
        "methods": ["GET", "POST"],
        "positions": ["body", "query", "insert"],
        // 'phases':    [ 'pre',  'post'             ],
        "phases": ["pre", "execute", "post"],
        "primitives": [
          ["string()", external_exports2.string()],
          ["number()", external_exports2.number()],
          ["boolean()", external_exports2.boolean()],
          ["object()", external_exports2.object()],
          ["enum(", null],
          ["array()", external_exports2.array(external_exports2.string())]
        ],
        "options": [
          ["min(", "min", "float"],
          ["max(", "max", "float"],
          ["length(", "length", "int"],
          // [ 'enum(',     'enum',     'string'  ],
          ["regex(", "regex", "string"],
          ["optional(", "optional", "empty"],
          ["default(", "default", "string"]
        ]
      },
      "regex": {
        "versionNumber": /:([a-zA-Z_][a-zA-Z0-9_]*)/g
      }
    };
    return types;
  }
  static prepareActivations({ arrayOfSchemas, envObject, activateTags, includeNamespaces, excludeNamespaces }) {
    const messages = [];
    if (!Array.isArray(arrayOfSchemas) || arrayOfSchemas.length === 0) {
      messages.push("Missing or invalid arrayOfSchemas");
    } else if (!arrayOfSchemas.every((path2) => typeof path2 === "object")) {
      messages.push("arrayOfSchemas must be an array of objects");
    }
    if (!envObject || typeof envObject !== "object") {
      messages.push("Missing or invalid envObject");
    }
    const n2 = [
      ["includeNamespaces", includeNamespaces],
      ["excludeNamespaces", excludeNamespaces],
      ["activateTags", activateTags]
    ].forEach(([name17, value]) => {
      if (value !== void 0) {
        messages.push(`${name17}: Is deprecated use filterArrayOfSchema instead.`);
      }
    });
    if (messages.length > 0) {
      _Validation.#error({ status: false, messages });
      return false;
    }
    return true;
  }
  static filterArrayOfSchemas({ arrayOfSchemas, includeNamespaces, excludeNamespaces, activateTags }) {
    const messages = [];
    if (!Array.isArray(arrayOfSchemas)) {
      messages.push("Missing or invalid arrayOfSchemas");
    } else if (arrayOfSchemas.length === 0) {
      messages.push("Missing or invalid arrayOfSchemas");
    } else if (!arrayOfSchemas.every((schema115) => typeof schema115 === "object" && schema115 !== null)) {
      messages.push("arrayOfSchemas must be an array of objects");
    }
    const n2 = [
      ["includeNamespaces", includeNamespaces],
      ["excludeNamespaces", excludeNamespaces],
      ["activateTags", activateTags]
    ].forEach(([name17, value]) => {
      if (!Array.isArray(value)) {
        messages.push(`${name17}: Must be an array`);
      } else if (value.map((a2) => typeof a2 === "string" && a2 !== "").some((a2) => !a2)) {
        messages.push(`${name17}: Must be an array of non-empty strings`);
      }
    });
    if (messages.length > 0) {
      _Validation.#error({ status: false, messages });
      return false;
    }
    return true;
  }
  static schema({ schema: schema115, strict = true }) {
    let id = "schema";
    const struct = {
      "status": false,
      "messages": []
    };
    const {
      version: flowMcpVersion,
      types: {
        meta: metaTypes
      }
    } = _Validation.getTypes();
    if (!schema115) {
      struct["messages"].push(`${id}: Missing schema`);
    } else if (typeof schema115 !== "object") {
      struct["messages"].push(`${id}: schema must be an object`);
    }
    struct["status"] = struct["messages"].length === 0;
    strict ? _Validation.#error(struct) : "";
    if (!struct["status"]) {
      return struct;
    }
    const { status: s1, messages: m1 } = _Validation.#testObject({ object: schema115, types: metaTypes, id });
    strict ? _Validation.#error({ status: s1, messages: m1 }) : "";
    if (!s1) {
      return { status: s1, messages: m1 };
    }
    const { namespace } = schema115;
    if (namespace == "") {
      struct["messages"].push(`${id}.namespace: Namespace is empty`);
    } else if (!/^[a-zA-Z][a-zA-Z0-9]*$/.test(namespace)) {
      struct["messages"].push(`${id}.namespace: Namespace "${namespace}" is not valid. Must start with a letter and contain only letters and numbers`);
    } else {
      id = `Schema.${namespace}`;
    }
    const isValidVersion = /* @__PURE__ */ __name((str) => /^\d+\.\d+\.\d+$/.test(str), "isValidVersion");
    const { flowMCP } = schema115;
    if (!isValidVersion(flowMCP)) {
      struct["messages"].push(`${id}.flowMCP: ${flowMCP} is not valid. Must be in the format x.x.x`);
    } else if (!flowMCP.startsWith(flowMcpVersion)) {
      struct["messages"].push(`${id}.flowMCP: ${flowMCP} is not compatible with ${flowMcpVersion}.`);
    }
    const { root } = schema115;
    const isValidUrl = /* @__PURE__ */ __name((str) => {
      try {
        new URL(str);
        return true;
      } catch {
        return false;
      }
    }, "isValidUrl");
    if (!isValidUrl(root)) {
      struct["messages"].push(`${id}.root: ${root} is not valid. Must be a valid URL`);
    }
    const { status: s2, messages: m2 } = Object.keys(schema115["routes"]).reduce((acc, routeName) => {
      const messages = _Validation.#route({ routeName, schema: schema115, id });
      acc["messages"].push(...messages);
      return acc;
    }, { "status": false, "messages": [] });
    struct["messages"].push(...m2);
    struct["status"] = struct["messages"].length === 0;
    strict ? _Validation.#error(struct) : "";
    if (!struct["status"]) {
      return struct;
    }
    const { tags } = schema115;
    tags.map((tag, index) => {
      if (typeof tag !== "string") {
        struct["messages"].push(`${id}.tags[${index}]: ${tag} is not valid. Must be a string`);
        return false;
      } else if (!/^[A-Za-z]+(\.(!)?[A-Za-z]+)?$/.test(tag)) {
        struct["messages"].push(`${id}.tags[${index}]: ${tag} is not valid. Must be a string with only letters and dots`);
        return false;
      }
      const [tagName, routeName] = tag.split(".");
      if (!routeName) {
        return true;
      }
      const routeNames = Object.keys(schema115["routes"]);
      if (routeNames.findIndex((a2) => a2 === routeName.replace("!", "")) === -1) {
        struct["messages"].push(`${id}.tags[${index}]: ${tag} is not valid. "${routeName}" is not a valid routeName. Choose from ${routeNames.join(", ")}`);
      }
    });
    const { requiredServerParams: schemaServerParams } = schema115;
    const { allowedServerParams } = _Validation.#getAllowedServerParams({ schema: schema115 });
    allowedServerParams.forEach((param) => {
      const test = schemaServerParams.findIndex((a2) => a2 === param);
      if (test === -1) {
        struct["messages"].push(`${id}.requiredServerParams: Required "${param}" serverParam is missing.`);
      }
    });
    schemaServerParams.forEach((param) => {
      const test = allowedServerParams.findIndex((a2) => a2 === param);
      if (test === -1) {
        struct["messages"].push(`${id}.requiredServerParams: Unknown "${param}" serverParam. Expected params are ${allowedServerParams.join(", ")}`);
      }
    });
    struct["status"] = struct["messages"].length === 0;
    strict ? _Validation.#error(struct) : "";
    if (!struct["status"]) {
      return struct;
    }
    return struct;
  }
  static routeName({ schema: schema115, routeName }) {
    const messages = [];
    const id = "routeName";
    if (!routeName) {
      messages.push(`${id}: Missing routeName`);
    } else if (typeof routeName !== "string") {
      messages.push(`${id}: routeName must be a string`);
    }
    if (messages.length > 0) {
      _Validation.#error({ status: false, messages });
      return false;
    }
    const { routes } = schema115;
    if (!Object.keys(routes).includes(routeName)) {
      messages.push(`${id}: Unknown routeName "${routeName}". Expected routeNames are ${Object.keys(routes).join(", ")}`);
    }
    if (messages.length > 0) {
      _Validation.#error({ status: false, messages });
      return false;
    }
    return true;
  }
  static serverParams({ schema: schema115, serverParams }) {
    const messages = [];
    const id = "serverParams";
    if (!serverParams) {
      messages.push(`${id}: Missing serverParams`);
    } else if (typeof serverParams !== "object") {
      messages.push(`${id}: serverParams must be an object`);
    }
    if (messages.length > 0) {
      _Validation.#error({ status: false, messages });
      return false;
    }
    const { allowedServerParams } = _Validation.#getAllowedServerParams({ schema: schema115 });
    const allKeys = Object.keys(serverParams);
    allowedServerParams.forEach((param) => {
      const test = allKeys.findIndex((a2) => a2 === param);
      if (test === -1) {
        messages.push(`${id}: Missing required serverParam "${param}"`);
      }
    });
    allKeys.forEach((param) => {
      const test = allowedServerParams.findIndex((a2) => a2 === param);
      if (test === -1) {
        messages.push(`${id}: Unknown serverParam "${param}". Expected params are ${allowedServerParams.join(", ")}`);
      }
    });
    Object.entries(serverParams).forEach(([key, value]) => {
      if (!value) {
        messages.push(`${id}: Value for ${key} is undefined`);
      }
    });
    if (messages.length > 0) {
      _Validation.#error({ status: false, messages });
      return false;
    }
    return true;
  }
  static userParams({ userParams, schema: schema115, routeName }) {
    const messages = [];
    const { requiredUserParams, optionalUserParams } = _Validation.#getAllowedUserParams({ schema: schema115, routeName });
    const id = "userParams";
    if (!userParams) {
      messages.push(`${id}: Missing userParams`);
    } else if (typeof userParams !== "object") {
      messages.push(`${id}: userParams must be an object`);
    }
    if (messages.length > 0) {
      _Validation.#error({ status: false, messages });
      return false;
    }
    const allKeys = Object.keys(userParams);
    requiredUserParams.forEach((param) => {
      const test = allKeys.findIndex((a2) => a2 === param);
      if (test === -1) {
        messages.push(`${id}: Missing required userParam "${param}"`);
      }
    });
    allKeys.forEach((param) => {
      const test = optionalUserParams.findIndex((a2) => a2 === param);
      if (test === -1) {
        messages.push(`${id}: Unknown userParam "${param}". Expected params are ${[...requiredUserParams, ...optionalUserParams].join(", ")}`);
      }
    });
    return true;
  }
  static #route({ routeName, schema: schema115, id = "" }) {
    const routeObj = schema115["routes"][routeName];
    id = `${id}.${routeName}`;
    const messages = [];
    const { types: { route: routeTypes } } = _Validation.getTypes();
    const { status: s2, messages: m2 } = _Validation.#testObject({ object: routeObj, types: routeTypes, id });
    messages.push(...m2);
    if (!s2) {
      return messages;
    }
    const { enums: { methods } } = _Validation.getTypes();
    if (!methods.includes(routeObj["requestMethod"])) {
      messages.push(`${id}.requestMethod: Unknown method (${routeObj["requestMethod"]}), choose from ${methods.join(", ")}.`);
    }
    const { parameters } = routeObj;
    parameters.forEach((item, index) => {
      const s3 = `${id}.parameters.[${index}]`;
      const { enums: { positions: positions2 } } = _Validation.getTypes();
      if (!positions2.includes(item["position"]["location"])) {
        messages.push(`${s3}.location: Unknown location (${item["position"]["location"]}), choose from ${positions2.join(", ")}.`);
      }
      if (item["position"]["value"] !== "{{USER_PARAM}}") {
        return messages;
      }
      if (!Object.hasOwn(item, "z")) {
        messages.push(`Missing z for parameter at index ${index}`);
        return messages;
      }
      const { types: { z: zTypes } } = _Validation.getTypes();
      const { status: s5, messages: m5 } = _Validation.#testObject({ object: item["z"], types: zTypes, id });
      messages.push(...m5);
      if (!s5) {
        return messages;
      }
      const { enums: { primitives, options } } = _Validation.getTypes();
      if (!primitives.map((a2) => item["z"]["primitive"].startsWith(a2[0])).some((a2) => a2)) {
        messages.push(`${s3}.z.primitive: ${item["z"]["primitive"]} is not known. Choose from ${primitives.map((a2) => a2[0]).join(", ")} instead.`);
      }
      const list = options.map((a2) => a2[1]);
      item["z"]["options"].forEach((option, rindex) => {
        const ss = `${s3}.z.options[${rindex}]`;
        if (!list.map((a2) => option.startsWith(a2)).some((a2) => a2)) {
          messages.push(`${ss}: The option "${option}" is unknown. Choose from ${list.join(", ")}`);
        }
        if (!list.map((a2) => a2[0])) {
          messages.push(`${ss}: ${option}`);
        }
      });
    });
    if (messages.length > 0) {
      return messages;
    }
    const { route } = routeObj;
    const { regex: { versionNumber } } = _Validation.getTypes();
    const findInserts = /* @__PURE__ */ __name((path2) => {
      const matches = path2.match(versionNumber);
      return matches ? matches.map((p) => p.slice(1)) : [];
    }, "findInserts");
    const { enums: { positions } } = _Validation.getTypes();
    const { requiredServerParams } = schema115;
    findInserts(route).forEach((name17, index) => {
      const s3 = `${id}.route.[${index}]`;
      const fromParameters = parameters.findIndex((a2) => {
        const one = a2["position"]["location"] === positions[2];
        const two = a2["position"]["key"] === name17;
        return one && two;
      });
      const fromServerParams = requiredServerParams.findIndex((a2) => a2 === name17);
      if (fromParameters === -1 && fromServerParams === -1) {
        messages.push(`${s3}: Missing parameter ${name17} in route`);
      }
    });
    const { modifiers } = routeObj;
    modifiers.forEach((item, index) => {
      const id2 = `${routeName}.modifiers.[${index}]`;
      const { types: { modifiers: modifierTypes } } = _Validation.getTypes();
      const { status: s3, messages: m3 } = _Validation.#testObject({ object: item, types: modifierTypes, id: id2, strict: true });
      messages.push(...m3);
      if (!s3) {
        return messages;
      }
      const { enums: { phases } } = _Validation.getTypes();
      if (!phases.includes(item["phase"])) {
        messages.push(`${id2}.phase: Unknown phase (${item["phase"]}), choose from ${phases.join(", ")}.`);
      }
      const { handlerName } = item;
      if (!Object.keys(schema115["handlers"]).includes(handlerName)) {
        messages.push(`${id2}.handler: Unknown handler (${handlerName}), choose from ${Object.keys(schema115["handlers"]).join(", ")}.`);
      }
    });
    const { tests } = routeObj;
    const { requiredUserParams, optionalUserParams } = _Validation.#getAllowedUserParams({ schema: schema115, routeName });
    tests.forEach((item, index) => {
      const id2 = `${routeName}.tests.[${index}]`;
      const userKeys = Object.keys(item).filter((key) => !key.startsWith("_"));
      const metaKeys = Object.keys(item).filter((key) => key.startsWith("_"));
      requiredUserParams.forEach((r2) => {
        if (!userKeys.includes(r2)) {
          messages.push(`${id2}: Missing required parameter ${r2}`);
        }
      });
      userKeys.forEach((key) => {
        const one = requiredUserParams.includes(key);
        const two = optionalUserParams.includes(key);
        if (!one && !two) {
          messages.push(`${id2}: Unknown parameter ${key}`);
        }
        if (item[key] === void 0 || item[key] === null) {
          messages.push(`${id2}: Missing value for ${key}. key "${key}" is value of "${item[key]}"`);
        }
      });
      const { types: { tests: _tests } } = _Validation.getTypes();
      const availableKeys = _tests.map((a2) => a2[0]);
      metaKeys.forEach((key) => {
        if (!availableKeys.includes(key)) {
          messages.push(`${id2}: Unknown test ${key}`);
        }
      });
    });
    return messages;
  }
  static #testObject({ object: object4, types, id = "", strict = true }) {
    const struct = {
      "status": false,
      "messages": []
    };
    const requiredKeys = types.map((a2) => a2[0]);
    requiredKeys.forEach(
      (key) => {
        if (!Object.hasOwn(object4, key)) {
          struct["messages"].push(`${id}: Missing required key: ${key}`);
        }
      }
    );
    if (struct["messages"].length > 0) {
      return struct;
    }
    Object.entries(object4).forEach(([key, value]) => {
      if (strict) {
        if (!requiredKeys.includes(key)) {
          struct["messages"].push(`${id}: Unknown key: ${key}`);
          return false;
        }
      }
      const typeIndex = types.findIndex(([k]) => k === key);
      if (typeIndex === -1) {
        struct["messages"].push(`${id}: Unknown key no type found: ${key}`);
        return false;
      }
      const expectedType = types[typeIndex][1];
      const { status, messages: m1 } = _Validation.#validateValue({ key, value, expectedType, id });
      struct["messages"].push(...m1);
    });
    struct["status"] = struct["messages"].length === 0;
    return struct;
  }
  static #validateValue({ key, value, expectedType, id }) {
    if (value === null || value === void 0) {
      return {
        status: false,
        messages: [`${id}: Value for ${key} is undefined`]
      };
    }
    const messages = [];
    switch (expectedType) {
      case "string":
        if (typeof value !== "string") {
          messages.push(`${id}: Expected ${key} to be a string`);
        }
        break;
      case "arrayOfStrings":
        if (!Array.isArray(value)) {
          messages.push(`${id}: Expected ${key} to be an array`);
        } else {
          value.forEach((v) => {
            if (typeof v !== "string") {
              messages.push(`${id}: Expected ${key} to be an array of strings`);
            }
          });
        }
        break;
      case "arrayOfObjects":
        if (!Array.isArray(value)) {
          messages.push(`${id}: Expected ${key} to be an array`);
        } else {
          value.forEach((v) => {
            if (typeof v !== "object" || Array.isArray(v)) {
              messages.push(`${id}: Expected ${key} to be an array of objects`);
            }
          });
        }
        break;
      case "arrayOfArray":
        if (!Array.isArray(value)) {
          messages.push(`${id}: Expected ${key} to be an array`);
        } else {
          value.forEach((v) => {
            if (!Array.isArray(v)) {
              messages.push(`${id}: Expected ${key} to be an array of arrays`);
            }
          });
        }
        break;
      case "objectKeyValues":
        if (typeof value !== "object" || Array.isArray(value)) {
          messages.push(`${id}: Expected ${key} to be an object`);
        }
        break;
      case "objectOfObjects":
        if (typeof value !== "object" || Array.isArray(value)) {
          messages.push(`${id}: Expected ${key} to be an object`);
        }
        break;
      case "objectKeyFunctions":
        if (typeof value !== "object" || Array.isArray(value)) {
          messages.push(`${id}: Expected ${key} to be an object`);
        }
        break;
      default:
        messages.push(`${id}: Unknown type: ${expectedType}`);
    }
    if (messages.length > 0) {
      return {
        status: false,
        messages
      };
    }
    return { status: true, messages };
  }
  static #getAllowedUserParams({ schema: schema115, routeName }) {
    const { parameters } = schema115["routes"][routeName];
    const { requiredUserParams, optionalUserParams } = parameters.reduce((acc, item) => {
      const { position: { key, value, location } } = item;
      if (value === "{{USER_PARAM}}") {
        const test = item["z"]["options"].map((a2) => a2.startsWith("optional")).some((a2) => a2);
        if (test) {
          acc["optionalUserParams"].push(key);
        } else {
          acc["requiredUserParams"].push(key);
        }
      }
      return acc;
    }, { "requiredUserParams": [], "optionalUserParams": [] });
    return { requiredUserParams, optionalUserParams };
  }
  static #getAllowedServerParams({ schema: schema115 }) {
    const { requiredFromParameters } = Object.entries(schema115["routes"]).reduce((acc, [key, value], index, arr) => {
      const t2 = value["parameters"].map((param) => param["position"]["value"]).filter((a2) => a2.startsWith("{{")).filter((a2) => a2 !== "{{USER_PARAM}}").map((a2) => {
        a2 = a2.replace("{{", "").replace("}}", "");
        return a2;
      }).forEach((param) => acc["requiredFromParameters"].add(param));
      return acc;
    }, { "requiredFromParameters": /* @__PURE__ */ new Set() });
    const { requiredFromHeaders } = Object.entries(schema115["headers"]).reduce((acc, [key, value], index, arr) => {
      if (typeof value !== "string") {
        return acc;
      }
      const matches2 = [...value.matchAll(/{{(.*?)}}/g)];
      const contents = matches2.map((m) => m[1]).forEach((param) => acc["requiredFromHeaders"].add(param));
      return acc;
    }, { "requiredFromHeaders": /* @__PURE__ */ new Set() });
    const { root } = schema115;
    const matches = [...root.matchAll(/{{(.*?)}}/g)];
    const { requiredFromUrl } = matches.reduce((acc, param) => {
      acc["requiredFromUrl"].add(param[1]);
      return acc;
    }, { "requiredFromUrl": /* @__PURE__ */ new Set() });
    const allowedServerParams = Array.from(/* @__PURE__ */ new Set([
      ...requiredFromParameters,
      ...requiredFromHeaders,
      ...requiredFromUrl
    ])).sort((a2, b) => a2.localeCompare(b));
    return { allowedServerParams };
  }
  static #error({ status, messages }) {
    if (!status) {
      const points = messages.map((m) => {
        return `- ${m}`;
      }).join(`
`);
      throw new Error(`
Validation Error(s):
${points}`);
    }
  }
};

// node_modules/flowmcp/src/task/Interface.mjs
var Interface = class _Interface {
  static {
    __name(this, "Interface");
  }
  static from({ schema: schema115 }) {
    const { routes } = schema115;
    const zodSchemas = Object.entries(routes).reduce((acc, [routeName, _]) => {
      acc[routeName] = _Interface.toServerTool({ schema: schema115, routeName });
      return acc;
    }, {});
    return zodSchemas;
  }
  static toServerTool({ schema: schema115, routeName }) {
    const { namespace } = schema115;
    const routeValue = schema115["routes"][routeName];
    const routeNameSnakeCase = routeName.replace(/([a-z0-9])([A-Z])/g, "$1_$2").toLowerCase();
    const suffixSnakeCase = namespace.replace(/([a-z0-9])([A-Z])/g, "$1_$2").toLowerCase();
    let toolName = `${routeNameSnakeCase}_${suffixSnakeCase}`;
    toolName = toolName.substring(0, 63).replaceAll(":", "").replaceAll("-", "_").replaceAll("/", "_");
    const { description } = routeValue;
    const zod = _Interface.getZodSchema({ route: routeValue, key: routeName });
    return { toolName, description, zod };
  }
  static getZodSchema({ route }) {
    const { parameters } = route;
    const zodSchema2 = parameters.filter((param) => {
      if (!Object.hasOwn(param, "z")) {
        return false;
      }
      if (param["z"].length === 0) {
        return false;
      }
      return true;
    }).reduce((acc, param) => {
      const { position: { key }, z: { primitive: primitive2, options } } = param;
      let _interface = _Interface.#insertPrimitive({ primitive: primitive2 });
      _interface = _Interface.#insertOptions({ _interface, options });
      acc[key] = _interface;
      return acc;
    }, {});
    return zodSchema2;
  }
  static #insertPrimitive({ primitive: primitive2 }) {
    function getContent({ str }) {
      const start = str.indexOf("(");
      const end = str.lastIndexOf(")");
      let content = null;
      if (start === -1 || end === -1 || end <= start) {
        return { content };
      }
      content = str.slice(start + 1, end);
      return { content };
    }
    __name(getContent, "getContent");
    let [primitiveName, zodPrimitive] = Validation.getTypes()["enums"]["primitives"].find(([type, _]) => primitive2.startsWith(type));
    if (primitiveName.startsWith("enum")) {
      const { content } = getContent({ str: primitive2 });
      if (content === null) {
        throw new Error(`Invalid enum type: ${primitiveName}`);
      }
      const values = content.split(",").map((item) => item.trim());
      zodPrimitive = external_exports2.enum(values);
    }
    return zodPrimitive;
  }
  static #insertOptions({ _interface, options }) {
    _interface = options.reduce((acc, option) => {
      _interface = _Interface.#insertOption({ _interface, option });
      return acc;
    }, _interface);
    return _interface;
  }
  static #insertOption({ _interface, option }) {
    const item = Validation.getTypes()["enums"]["options"].find(([prefix]) => option.startsWith(prefix));
    const [_, zType, primitives] = item;
    let value = null;
    switch (primitives) {
      case "float":
        value = parseFloat(option.slice(zType.length + 1, -1));
        break;
      case "integer":
      case "int":
        value = parseInt(option.slice(zType.length + 1, -1));
        break;
      case "string":
        value = option.slice(zType.length + 1, -1);
        break;
      case "boolean":
        value = option.slice(zType.length + 1, -1) === "true";
        break;
      case "array":
        value = option.slice(zType.length + 1, -1).split(",").map((item2) => item2.trim());
        break;
      case "empty":
        value = null;
        break;
      default:
        throw new Error(`Unsupported zod type: ${primitives}`);
    }
    switch (zType) {
      case "min":
        _interface = _interface.min(value);
        break;
      case "max":
        _interface = _interface.max(value);
        break;
      case "length":
        _interface = _interface.length(value);
        break;
      case "enum":
        console.log("_interface", _interface);
        _interface = _interface.enum(value);
        break;
      case "regex":
        _interface = _interface.regex(new RegExp(value));
        break;
      case "optional":
        _interface = _interface.optional();
        break;
      case "default":
        _interface = _interface.default(value);
        break;
      default:
        throw new Error(`Unsupported zod type: ${zType}`);
    }
    return _interface;
  }
};

// node_modules/flowmcp/src/task/Fetch.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/flatted/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { parse: $parse, stringify: $stringify } = JSON;
var { keys } = Object;
var Primitive = String;
var primitive = "string";
var object3 = "object";
var noop2 = /* @__PURE__ */ __name((_, value) => value, "noop");
var set2 = /* @__PURE__ */ __name((known, input, value) => {
  const index = Primitive(input.push(value) - 1);
  known.set(value, index);
  return index;
}, "set");
var stringify = /* @__PURE__ */ __name((value, replacer, space) => {
  const $ = replacer && typeof replacer === object3 ? (k, v) => k === "" || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop2;
  const known = /* @__PURE__ */ new Map();
  const input = [];
  const output = [];
  let i2 = +set2(known, input, $.call({ "": value }, "", value));
  let firstRun = !i2;
  while (i2 < input.length) {
    firstRun = true;
    output[i2] = $stringify(input[i2++], replace, space);
  }
  return "[" + output.join(",") + "]";
  function replace(key, value2) {
    if (firstRun) {
      firstRun = !firstRun;
      return value2;
    }
    const after = $.call(this, key, value2);
    switch (typeof after) {
      case object3:
        if (after === null) return after;
      case primitive:
        return known.get(after) || set2(known, input, after);
    }
    return after;
  }
  __name(replace, "replace");
}, "stringify");

// node_modules/flowmcp/src/task/Fetch.mjs
import util2 from "util";
var Fetch = class _Fetch {
  static {
    __name(this, "Fetch");
  }
  static async from({ schema: schema115, userParams, serverParams, routeName }) {
    let struct = {
      status: true,
      messages: [],
      data: null,
      dataAsString: null
    };
    const { requestMethod, url: url2, headers, body, modifiers, _allParams } = _Fetch.#prepare({ schema: schema115, userParams, serverParams, routeName });
    userParams = { ...userParams, _allParams };
    let payload = { requestMethod, url: url2, headers, body, modifiers };
    await Validation.getTypes()["enums"]["phases"].reduce((promise2, phaseType) => promise2.then(async () => {
      const relevantModifiers = modifiers.filter(({ phase }) => phase.includes(phaseType));
      if (phaseType === "execute" && relevantModifiers.length === 0) {
        struct = await _Fetch.#executeDefault({ struct, payload });
      } else if (relevantModifiers.length > 0) {
        const result = await _Fetch.#modifierLoop({ struct, payload, userParams, routeName, phaseType });
        struct = result.struct;
        payload = result.payload;
      }
    }), Promise.resolve());
    const { dataAsString } = _Fetch.stringifyResponseData({ data: struct["data"] });
    struct["dataAsString"] = dataAsString;
    return { struct, payload };
  }
  /*
      static async from1( { schema, userParams, serverParams, routeName } ) {
          let struct = {
              'status': true,
              'messages': [],
              'data': null,
              'dataAsString': null
          }
  
          const { requestMethod, url, headers, body, modifiers } = Fetch
              .#prepare( { schema, userParams, serverParams, routeName } )
          
          let payload = { requestMethod, url, headers, body, modifiers }
  
          const { struct: s1, payload: p1 } = await Fetch
              .#modifierLoop( { struct, payload, userParams, routeName, 'phaseType': 'pre' } )
          struct = { ...s1 }; payload = { ...p1 }
          if( struct['status'] === false ) { return { struct, payload } }
  
          if( modifiers.map( ( { phase } ) => !phase.includes( 'execute' ) ).some( a => a ) )  {
              struct = await Fetch
                  .#execute( { struct: { ...s1 }, payload: { ...p1 } } )
          } else {
              const { struct: s2, payload: p2 } = await Fetch
                  .#modifierLoop( { struct: { ...struct }, payload: { ...p1 }, userParams, routeName, 'phaseType': 'execute' } )
              struct = { ...s2 }; payload = { ...p2 }
          }
  
          const { struct: s3, payload: p3 } = await Fetch
              .#modifierLoop( { struct, payload, userParams, routeName, 'phaseType': 'post' } )
          struct = { ...s3 }; payload = { ...p3 }
          if( struct['status'] === false ) { return { struct, payload } }
  
          const { dataAsString } = Fetch
              .stringifyResponseData( { data: struct['data'] } )
          struct['dataAsString'] = dataAsString
  
          return { struct, payload }
      }
  */
  static #prepare({ schema: schema115, userParams, serverParams, routeName }) {
    const { root, headers: _headers, routes } = schema115;
    const route = routes[routeName];
    const { requestMethod, route: _route } = route;
    let { modifiers } = route;
    const headers = Object.entries(_headers).reduce((acc, [key, value]) => {
      acc[key] = _Fetch.#insertValue({
        userParams,
        serverParams,
        key,
        value
      });
      return acc;
    }, {});
    const parametersWithRequired = route["parameters"].map((param) => {
      if (!Object.hasOwn(param, "z")) {
        return { "required": true, ...param };
      }
      const { z } = param;
      const required2 = z["options"].includes("optional()") ? false : true;
      return { required: required2, ...param };
    });
    const body = parametersWithRequired.filter(({ position: { location } }) => location === "body").reduce((acc, { position: { key, value }, required: required2 }) => {
      const modValue = _Fetch.#insertValue({ userParams, serverParams, key, value, required: required2 });
      acc[key] = modValue;
      return acc;
    }, {});
    let url2 = parametersWithRequired.filter(({ position: { location } }) => location === "insert").reduce((acc, { position: { key, value }, required: required2 }) => {
      const to = _Fetch.#insertValue({ userParams, serverParams, key, value });
      acc = acc.replaceAll(`:${key}`, to).replaceAll(`{{${key}}}`, to);
      return acc;
    }, `${root}${_route}`);
    url2 = Object.entries(serverParams).reduce((acc, [key, value]) => {
      acc = acc.replaceAll(`{{${key}}}`, value);
      return acc;
    }, url2);
    const { iterate } = parametersWithRequired.filter(({ position: { location } }) => location === "query").reduce((acc, { position: { key, value }, required: required2 }, index, arr) => {
      const modValue = _Fetch.#insertValue({ userParams, serverParams, key, value, required: required2 });
      if (modValue === void 0) {
        return acc;
      }
      acc["iterate"][key] = modValue;
      return acc;
    }, { "iterate": {} });
    let query = "";
    query += new URLSearchParams(iterate).toString();
    query = query !== "" ? "?" + query : "";
    url2 += query;
    modifiers = modifiers.reduce((acc, { phase, handlerName }, index) => {
      const func = schema115["handlers"][handlerName];
      acc.push({ phase, handlerName, func });
      return acc;
    }, []);
    const _allParams = schema115["routes"][routeName]["parameters"].reduce((acc, { position: { key, value } }) => {
      const modValue = _Fetch.#insertValue({ userParams, serverParams, key, value });
      if (modValue === void 0) {
        return acc;
      }
      acc[key] = modValue;
      return acc;
    }, {});
    return { requestMethod, url: url2, headers, body, modifiers, _allParams };
  }
  static async #executeDefault({ struct, payload }) {
    return await _Fetch.#execute({ struct, payload });
  }
  static async #execute({ struct, payload }) {
    const { requestMethod, url: url2, headers, body, modifiers } = payload;
    struct["status"] = struct["messages"].length === 0;
    if (struct["status"] === false) {
      return struct;
    }
    switch (requestMethod.toUpperCase()) {
      case "GET":
        try {
          const response = await fetch(url2, {
            method: "GET",
            headers
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const data = await response.json();
          struct["data"] = data;
        } catch (error42) {
          struct["status"] = false;
          const messages = _Fetch.getErrorMessages({ error: error42 });
          struct["messages"].push(...messages);
        }
        break;
      case "POST":
        try {
          const response = await fetch(url2, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            body: JSON.stringify(body)
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const data = await response.json();
          struct["data"] = data;
        } catch (error42) {
          struct["status"] = false;
          const messages = _Fetch.getErrorMessages({ error: error42 });
          struct["messages"].push(...messages);
        }
        break;
      default:
        struct["status"] = false;
        struct["messages"].push("Unknown method:", requestMethod);
        console.warn("Unknown method:", requestMethod);
    }
    if (struct["status"] === false) {
      return struct;
    }
    return struct;
  }
  static async #modifierLoop({ struct, payload, userParams, routeName, phaseType }) {
    const { modifiers } = payload;
    for (const { phase, func } of modifiers) {
      if (phase !== phaseType) {
        continue;
      }
      try {
        const { struct: _struct, payload: _payload } = await func({ struct, payload, userParams, routeName, phaseType });
        struct = _struct;
        payload = _payload;
      } catch (e) {
        struct["status"] = false;
        struct["messages"].push(e.message);
      }
    }
    return { struct, payload };
  }
  static getErrorMessages({ error: error42 }) {
    let messages = [];
    if (error42.message && error42.message.includes("HTTP")) {
      messages.push(error42.message);
    } else if (error42.name === "TypeError" || error42.message.includes("fetch")) {
      messages.push("No response received from server.");
      messages.push("Network error:", error42.message);
    } else if (error42.name === "SyntaxError" && error42.message.includes("JSON")) {
      messages.push("Invalid JSON response from server.");
      messages.push("Parse error:", error42.message);
    } else {
      messages.push("Error in setting up the request:", error42.message);
    }
    return messages;
  }
  static #insertValue({ userParams, serverParams, key, value, required: required2 }) {
    let type = null;
    let params = null;
    let paramName = null;
    if (value.includes("{{USER_PARAM}}")) {
      params = userParams;
      type = "user";
    } else if (value.includes("{{")) {
      params = serverParams;
      type = "server";
    }
    if (!params) {
      return value;
    }
    if (type === "user") {
      paramName = key;
    } else if (type === "server") {
      const start = value.indexOf("{{");
      const end = value.indexOf("}}");
      if (start !== -1 && end !== -1) {
        paramName = value.slice(start + 2, end).trim();
      } else {
        throw new Error(`Invalid parameter format: ${value}`);
      }
    }
    if (type === "user") {
      if (userParams[key] === void 0) {
        return void 0;
      }
      value = value.replace("{{USER_PARAM}}", userParams[key]);
    } else if (type === "server") {
      value = value.replace("{{" + paramName + "}}", params[paramName]);
    } else {
      throw new Error(`Invalid parameter type: ${type}`);
    }
    return value;
  }
  static stringifyResponseData({ data }) {
    let dataAsString = null;
    try {
      dataAsString = JSON.stringify(data);
    } catch (jsonError) {
      try {
        dataAsString = stringify(data);
      } catch (flattedError) {
        dataAsString = util2.inspect(data, { "depth": null, "compact": false });
      }
    }
    return { dataAsString };
  }
};

// node_modules/flowmcp/src/task/Payload.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Payload = class _Payload {
  static {
    __name(this, "Payload");
  }
  static prepareActivations({
    arrayOfSchemas,
    envObject
  }) {
    const activationPayloads = arrayOfSchemas.map((schema115) => {
      const result = { "fileName": "", "path": "", schema: schema115, "messages": [] };
      return result;
    }).map((item) => {
      item["serverParams"] = null;
      if (item["messages"].length > 0) {
        return item;
      }
      const { schema: { requiredServerParams } } = item;
      const selection2 = requiredServerParams.map((param) => [param, param]);
      const { messages: messages2, result: serverParams } = _Payload.#parseEnvFileContent({ envObject, selection: selection2 });
      item["messages"] = [...item["messages"], ...messages2];
      item["serverParams"] = serverParams;
      return item;
    }).map(({ schema: schema115, serverParams, messages: messages2 }) => {
      return { schema: schema115, serverParams, messages: messages2 };
    });
    const messages = activationPayloads.reduce((acc, item, index) => {
      const { fileName, messages: messages2 } = item;
      const prefix = `${fileName} [${index}]`;
      messages2.forEach((message) => acc.push(`${prefix}: ${message}`));
      return acc;
    }, []);
    const status = messages.length === 0;
    return { status, messages, activationPayloads };
  }
  static #parseEnvFileContent({ envObject, selection: selection2 }) {
    const messages = [];
    const result = Object.entries(envObject).reduce((acc, [k, v]) => {
      const find = selection2.find(([key, value]) => value === k);
      if (find) {
        acc[find[0]] = v;
      }
      return acc;
    }, {});
    selection2.forEach((row) => {
      const [key, _] = row;
      if (!result[key]) {
        messages.push(`Missing ${key} in .env file`);
      }
      return true;
    });
    return { messages, result };
  }
};

// node_modules/flowmcp/src/task/Test.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Test = class {
  static {
    __name(this, "Test");
  }
  static all({ schema: schema115 }) {
    const { routes } = schema115;
    const results = Object.entries(routes).reduce((acc, [routeName, value]) => {
      const { tests } = value;
      tests.forEach((obj) => {
        const { description, userParams } = Object.entries(obj).reduce((abb, [key, value2]) => {
          if (key === "_description") {
            abb["description"] = value2;
          } else if (!key.startsWith("_")) {
            abb["userParams"][key] = value2;
          }
          return abb;
        }, { "description": "", "userParams": {} });
        const payload = { routeName, description, userParams };
        acc.push(payload);
        return true;
      });
      return acc;
    }, []);
    return results;
  }
};

// node_modules/flowmcp/src/task/ArrayOfSchemasFilter.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ArrayOfSchemasFilter = class {
  static {
    __name(this, "ArrayOfSchemasFilter");
  }
  static validateTags({ arrayOfSchemas, activateTags }) {
    const errors = [];
    const validatedTags = [];
    const validatedRoutes = {};
    const availableTagsSet = /* @__PURE__ */ new Set();
    const availableRoutesMap = {};
    arrayOfSchemas.forEach((schema115) => {
      const { namespace, tags, routes } = schema115;
      const namespaceKey = namespace.toLowerCase();
      tags.forEach((tag) => availableTagsSet.add(tag.toLowerCase()));
      if (!availableRoutesMap[namespaceKey]) {
        availableRoutesMap[namespaceKey] = /* @__PURE__ */ new Set();
      }
      Object.keys(routes).forEach((routeName) => {
        availableRoutesMap[namespaceKey].add(routeName.toLowerCase());
      });
    });
    activateTags.forEach((tag) => {
      if (typeof tag !== "string" || tag.trim() === "") {
        errors.push(`Invalid activateTags syntax: '${tag}'`);
        return;
      }
      const trimmedTag = tag.trim();
      if (!trimmedTag.includes(".")) {
        const tagLower = trimmedTag.toLowerCase();
        if (!availableTagsSet.has(tagLower)) {
          errors.push(`Tag '${trimmedTag}' not found in any schema`);
          return;
        }
        validatedTags.push(tagLower);
      } else {
        const parts = trimmedTag.split(".");
        if (parts.length !== 2 || parts[0] === "" || parts[1] === "") {
          errors.push(`Invalid activateTags syntax: '${trimmedTag}'`);
          return;
        }
        const [namespace, routeNameCmd] = parts;
        const namespaceKey = namespace.toLowerCase();
        const isExclude = routeNameCmd.startsWith("!");
        const routeName = isExclude ? routeNameCmd.substring(1).toLowerCase() : routeNameCmd.toLowerCase();
        if (!availableRoutesMap[namespaceKey]) {
          errors.push(`Namespace '${namespace}' not found in schemas`);
          return;
        }
        if (!availableRoutesMap[namespaceKey].has(routeName)) {
          errors.push(`Route '${routeName}' not found in namespace '${namespace}'`);
          return;
        }
        if (!validatedRoutes[namespaceKey]) {
          validatedRoutes[namespaceKey] = [];
        }
        validatedRoutes[namespaceKey].push(isExclude ? `!${routeName}` : routeName);
      }
    });
    if (errors.length > 0) {
      const uniqueErrors = [...new Set(errors)];
      const errorMessage = `Invalid activateTags found:
${uniqueErrors.map((err) => `- ${err}`).join("\n")}`;
      throw new Error(errorMessage);
    }
    return { validatedTags, validatedRoutes };
  }
  static filterByNamespaces({ arrayOfSchemas, includeNamespaces, excludeNamespaces }) {
    const filteredByNamespaces = arrayOfSchemas.filter((schema115) => {
      const { namespace } = schema115;
      if (includeNamespaces.length > 0) {
        return includeNamespaces.some((includeNs) => includeNs.toLowerCase() === namespace.toLowerCase());
      } else if (excludeNamespaces.length > 0) {
        return !excludeNamespaces.some((excludeNs) => excludeNs.toLowerCase() === namespace.toLowerCase());
      } else {
        return true;
      }
    });
    return { filteredByNamespaces };
  }
  static filterByTagsAndRoutes({ arrayOfSchemas, validatedTags, validatedRoutes, originalActivateTagsCount }) {
    const filteredSchemas = arrayOfSchemas.filter((schema115) => {
      const { tags } = schema115;
      const namespaceKey = schema115.namespace.toLowerCase();
      if (validatedTags.length === 0 && Object.keys(validatedRoutes).length === 0) {
        return originalActivateTagsCount === 0;
      }
      if (validatedTags.length === 0 && Object.keys(validatedRoutes).length > 0) {
        return Object.hasOwn(validatedRoutes, namespaceKey);
      }
      if (validatedTags.length > 0 && Object.keys(validatedRoutes).length === 0) {
        return validatedTags.some(
          (filterTag) => tags.some((schemaTag) => schemaTag.toLowerCase() === filterTag)
        );
      }
      const hasMatchingTag = validatedTags.some(
        (filterTag) => tags.some((schemaTag) => schemaTag.toLowerCase() === filterTag)
      );
      const hasRouteFilter = Object.hasOwn(validatedRoutes, namespaceKey);
      return hasMatchingTag || hasRouteFilter;
    }).map((schema115) => {
      const { namespace } = schema115;
      const newSchema = { ...schema115 };
      if (Object.keys(validatedRoutes).length === 0) {
        return newSchema;
      }
      const namespaceKey = namespace.toLowerCase();
      if (!Object.hasOwn(validatedRoutes, namespaceKey)) {
        return newSchema;
      }
      const routeFilters = validatedRoutes[namespaceKey];
      const hasIncludeRoutes = routeFilters.some((routeCmd) => !routeCmd.startsWith("!"));
      newSchema["routes"] = Object.entries(schema115["routes"]).filter(([routeName]) => {
        const routeNameLower = routeName.toLowerCase();
        const excludeTag = `!${routeNameLower}`;
        if (routeFilters.includes(excludeTag)) {
          return false;
        }
        if (hasIncludeRoutes) {
          return routeFilters.includes(routeNameLower);
        } else {
          return true;
        }
      }).reduce((acc, [routeName, route]) => {
        acc[routeName] = route;
        return acc;
      }, {});
      return newSchema;
    }).filter((schema115) => {
      return Object.keys(schema115.routes).length > 0;
    });
    return { filteredArrayOfSchemas: filteredSchemas };
  }
};

// node_modules/flowmcp/src/index.mjs
var FlowMCP = class _FlowMCP {
  static {
    __name(this, "FlowMCP");
  }
  static getArgvParameters({
    argv: argv2,
    includeNamespaces = [],
    excludeNamespaces = [],
    activateTags = []
  }) {
    const result = {
      "source": "unknown",
      includeNamespaces,
      excludeNamespaces,
      activateTags
    };
    const argMappings = {
      "--source": "source",
      "--includeNamespaces=": "includeNamespaces",
      "--excludeNamespaces=": "excludeNamespaces",
      "--activateTags=": "activateTags"
    };
    const args = process.argv.slice(2);
    args.forEach((arg) => {
      Object.entries(argMappings).forEach(([prefix, key]) => {
        if (arg.startsWith(prefix)) {
          const [_, value] = arg.split("=");
          result[key] = value.split(",").filter(Boolean);
        }
      });
    });
    if (Array.isArray(result["source"])) {
      result["source"] = result["source"][0];
    }
    return result;
  }
  static prepareActivations({
    arrayOfSchemas,
    envObject,
    activateTags,
    // deprecated use filterArrayOfSchemas instead
    includeNamespaces,
    // deprecated use filterArrayOfSchemas instead
    excludeNamespaces
    // deprecated use filterArrayOfSchemas instead
  }) {
    Validation.prepareActivations({ arrayOfSchemas, envObject, activateTags, includeNamespaces, excludeNamespaces });
    const { status, messages, activationPayloads } = Payload.prepareActivations({ arrayOfSchemas, envObject });
    if (!status) {
      throw new Error(`Activation preparation failed: ${messages.join(", ")}`);
    }
    return { activationPayloads };
  }
  static filterArrayOfSchemas({ arrayOfSchemas, includeNamespaces, excludeNamespaces, activateTags }) {
    Validation.filterArrayOfSchemas({ arrayOfSchemas, includeNamespaces, excludeNamespaces, activateTags });
    const { validatedTags, validatedRoutes } = ArrayOfSchemasFilter.validateTags({ arrayOfSchemas, activateTags });
    const { filteredByNamespaces } = ArrayOfSchemasFilter.filterByNamespaces({ arrayOfSchemas, includeNamespaces, excludeNamespaces });
    const { filteredArrayOfSchemas } = ArrayOfSchemasFilter.filterByTagsAndRoutes({
      arrayOfSchemas: filteredByNamespaces,
      validatedTags,
      validatedRoutes,
      originalActivateTagsCount: activateTags.length
    });
    return { filteredArrayOfSchemas };
  }
  static activateServerTools({ server, schema: schema115, serverParams, validate = true, silent = true }) {
    if (validate) {
      Validation.schema({ schema: schema115 });
      Validation.serverParams({ schema: schema115, serverParams });
    }
    const { routes } = schema115;
    let routeNames = Object.keys(routes);
    const mcpTools = routeNames.reduce((acc, routeName) => {
      const { toolName, mcpTool } = _FlowMCP.activateServerTool({ server, schema: schema115, serverParams, routeName, "validate": false });
      acc[toolName] = mcpTool;
      return acc;
    }, {});
    if (!silent && routeNames.length > 0) {
      const colWidths = [16, 3, 50];
      const id = schema115.namespace;
      const anzahl = routeNames.length;
      const routes2 = routeNames.join(", ");
      const formatCell = /* @__PURE__ */ __name((value, width) => {
        const str = String(value);
        if (str.length > width) {
          return str.substring(0, width - 3) + "...";
        }
        return str.padEnd(width);
      }, "formatCell");
      const row = [
        formatCell(id, colWidths[0]),
        formatCell(anzahl, colWidths[1]),
        formatCell(routes2, colWidths[2])
      ].join(" | ");
      console.warn(row);
    }
    return { mcpTools };
  }
  static activateServerTool({ server, schema: schema115, routeName, serverParams, validate = true }) {
    const { toolName, description, zod, func } = _FlowMCP.prepareServerTool({ schema: schema115, serverParams, routeName, validate });
    const mcpTool = server.tool(toolName, description, zod, func);
    return { toolName, mcpTool };
  }
  static prepareServerTool({ schema: schema115, serverParams, routeName, validate = true }) {
    if (validate) {
      Validation.schema({ schema: schema115 });
      Validation.serverParams({ schema: schema115, serverParams });
      Validation.routeName({ schema: schema115, routeName });
    }
    const { toolName, description, zod } = Interface.toServerTool({ schema: schema115, routeName });
    const result = {
      toolName,
      description,
      zod,
      "func": /* @__PURE__ */ __name(async (userParams) => {
        const { struct, payload } = await Fetch.from({ schema: schema115, userParams, serverParams, routeName });
        const { status, messages, dataAsString } = struct;
        if (!status) {
          return { content: [{ type: "text", text: `Error: ${messages.join(", ")}` }] };
        } else {
          return { content: [{ type: "text", text: `Result: ${dataAsString}` }] };
        }
      }, "func")
    };
    return result;
  }
  static getZodInterfaces({ schema: schema115 }) {
    Validation.schema({ schema: schema115, strict: false });
    const result = Interface.from({ schema: schema115 });
    return result;
  }
  static getAllTests({ schema: schema115 }) {
    Validation.schema({ schema: schema115 });
    const result = Test.all({ schema: schema115 });
    return result;
  }
  static validateSchema({ schema: schema115 }) {
    const result = Validation.schema({ schema: schema115, "strict": false });
    return result;
  }
  static async fetch({ schema: schema115, userParams, serverParams, routeName }) {
    Validation.schema({ schema: schema115 });
    Validation.serverParams({ schema: schema115, serverParams });
    Validation.routeName({ schema: schema115, routeName });
    Validation.userParams({ schema: schema115, userParams, routeName });
    const { struct, payload } = await Fetch.from({ schema: schema115, userParams, serverParams, routeName });
    return struct;
  }
};

// node_modules/schemaimporter/src/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/unenv/dist/runtime/node/fs.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/unenv/dist/runtime/node/fs/promises.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var access = /* @__PURE__ */ notImplemented("fs.access");
var copyFile = /* @__PURE__ */ notImplemented("fs.copyFile");
var cp = /* @__PURE__ */ notImplemented("fs.cp");
var open = /* @__PURE__ */ notImplemented("fs.open");
var opendir = /* @__PURE__ */ notImplemented("fs.opendir");
var rename = /* @__PURE__ */ notImplemented("fs.rename");
var truncate = /* @__PURE__ */ notImplemented("fs.truncate");
var rm = /* @__PURE__ */ notImplemented("fs.rm");
var rmdir = /* @__PURE__ */ notImplemented("fs.rmdir");
var mkdir = /* @__PURE__ */ notImplemented("fs.mkdir");
var readdir = /* @__PURE__ */ notImplemented("fs.readdir");
var readlink = /* @__PURE__ */ notImplemented("fs.readlink");
var symlink = /* @__PURE__ */ notImplemented("fs.symlink");
var lstat = /* @__PURE__ */ notImplemented("fs.lstat");
var stat = /* @__PURE__ */ notImplemented("fs.stat");
var link = /* @__PURE__ */ notImplemented("fs.link");
var unlink = /* @__PURE__ */ notImplemented("fs.unlink");
var chmod = /* @__PURE__ */ notImplemented("fs.chmod");
var lchmod = /* @__PURE__ */ notImplemented("fs.lchmod");
var lchown = /* @__PURE__ */ notImplemented("fs.lchown");
var chown = /* @__PURE__ */ notImplemented("fs.chown");
var utimes = /* @__PURE__ */ notImplemented("fs.utimes");
var lutimes = /* @__PURE__ */ notImplemented("fs.lutimes");
var realpath = /* @__PURE__ */ notImplemented("fs.realpath");
var mkdtemp = /* @__PURE__ */ notImplemented("fs.mkdtemp");
var writeFile = /* @__PURE__ */ notImplemented("fs.writeFile");
var appendFile = /* @__PURE__ */ notImplemented("fs.appendFile");
var readFile = /* @__PURE__ */ notImplemented("fs.readFile");
var watch = /* @__PURE__ */ notImplemented("fs.watch");
var statfs = /* @__PURE__ */ notImplemented("fs.statfs");
var glob = /* @__PURE__ */ notImplemented("fs.glob");

// node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs
var constants_exports = {};
__export(constants_exports, {
  COPYFILE_EXCL: () => COPYFILE_EXCL,
  COPYFILE_FICLONE: () => COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE,
  EXTENSIONLESS_FORMAT_JAVASCRIPT: () => EXTENSIONLESS_FORMAT_JAVASCRIPT,
  EXTENSIONLESS_FORMAT_WASM: () => EXTENSIONLESS_FORMAT_WASM,
  F_OK: () => F_OK,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECT: () => O_DIRECT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_DSYNC: () => O_DSYNC,
  O_EXCL: () => O_EXCL,
  O_NOATIME: () => O_NOATIME,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  R_OK: () => R_OK,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_DIRENT_BLOCK: () => UV_DIRENT_BLOCK,
  UV_DIRENT_CHAR: () => UV_DIRENT_CHAR,
  UV_DIRENT_DIR: () => UV_DIRENT_DIR,
  UV_DIRENT_FIFO: () => UV_DIRENT_FIFO,
  UV_DIRENT_FILE: () => UV_DIRENT_FILE,
  UV_DIRENT_LINK: () => UV_DIRENT_LINK,
  UV_DIRENT_SOCKET: () => UV_DIRENT_SOCKET,
  UV_DIRENT_UNKNOWN: () => UV_DIRENT_UNKNOWN,
  UV_FS_COPYFILE_EXCL: () => UV_FS_COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE: () => UV_FS_COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE: () => UV_FS_COPYFILE_FICLONE_FORCE,
  UV_FS_O_FILEMAP: () => UV_FS_O_FILEMAP,
  UV_FS_SYMLINK_DIR: () => UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION: () => UV_FS_SYMLINK_JUNCTION,
  W_OK: () => W_OK,
  X_OK: () => X_OK
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UV_FS_SYMLINK_DIR = 1;
var UV_FS_SYMLINK_JUNCTION = 2;
var O_RDONLY = 0;
var O_WRONLY = 1;
var O_RDWR = 2;
var UV_DIRENT_UNKNOWN = 0;
var UV_DIRENT_FILE = 1;
var UV_DIRENT_DIR = 2;
var UV_DIRENT_LINK = 3;
var UV_DIRENT_FIFO = 4;
var UV_DIRENT_SOCKET = 5;
var UV_DIRENT_CHAR = 6;
var UV_DIRENT_BLOCK = 7;
var EXTENSIONLESS_FORMAT_JAVASCRIPT = 0;
var EXTENSIONLESS_FORMAT_WASM = 1;
var S_IFMT = 61440;
var S_IFREG = 32768;
var S_IFDIR = 16384;
var S_IFCHR = 8192;
var S_IFBLK = 24576;
var S_IFIFO = 4096;
var S_IFLNK = 40960;
var S_IFSOCK = 49152;
var O_CREAT = 64;
var O_EXCL = 128;
var UV_FS_O_FILEMAP = 0;
var O_NOCTTY = 256;
var O_TRUNC = 512;
var O_APPEND = 1024;
var O_DIRECTORY = 65536;
var O_NOATIME = 262144;
var O_NOFOLLOW = 131072;
var O_SYNC = 1052672;
var O_DSYNC = 4096;
var O_DIRECT = 16384;
var O_NONBLOCK = 2048;
var S_IRWXU = 448;
var S_IRUSR = 256;
var S_IWUSR = 128;
var S_IXUSR = 64;
var S_IRWXG = 56;
var S_IRGRP = 32;
var S_IWGRP = 16;
var S_IXGRP = 8;
var S_IRWXO = 7;
var S_IROTH = 4;
var S_IWOTH = 2;
var S_IXOTH = 1;
var F_OK = 0;
var R_OK = 4;
var W_OK = 2;
var X_OK = 1;
var UV_FS_COPYFILE_EXCL = 1;
var COPYFILE_EXCL = 1;
var UV_FS_COPYFILE_FICLONE = 2;
var COPYFILE_FICLONE = 2;
var UV_FS_COPYFILE_FICLONE_FORCE = 4;
var COPYFILE_FICLONE_FORCE = 4;

// node_modules/unenv/dist/runtime/node/fs/promises.mjs
var promises_default = {
  constants: constants_exports,
  access,
  appendFile,
  chmod,
  chown,
  copyFile,
  cp,
  glob,
  lchmod,
  lchown,
  link,
  lstat,
  lutimes,
  mkdir,
  mkdtemp,
  open,
  opendir,
  readFile,
  readdir,
  readlink,
  realpath,
  rename,
  rm,
  rmdir,
  stat,
  statfs,
  symlink,
  truncate,
  unlink,
  utimes,
  watch,
  writeFile
};

// node_modules/unenv/dist/runtime/node/internal/fs/classes.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var Dir = /* @__PURE__ */ notImplementedClass("fs.Dir");
var Dirent = /* @__PURE__ */ notImplementedClass("fs.Dirent");
var Stats = /* @__PURE__ */ notImplementedClass("fs.Stats");
var ReadStream2 = /* @__PURE__ */ notImplementedClass("fs.ReadStream");
var WriteStream2 = /* @__PURE__ */ notImplementedClass("fs.WriteStream");
var FileReadStream = ReadStream2;
var FileWriteStream = WriteStream2;

// node_modules/unenv/dist/runtime/node/internal/fs/fs.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
function callbackify(fn) {
  const fnc = /* @__PURE__ */ __name(function(...args) {
    const cb = args.pop();
    fn().catch((error42) => cb(error42)).then((val) => cb(void 0, val));
  }, "fnc");
  fnc.__promisify__ = fn;
  fnc.native = fnc;
  return fnc;
}
__name(callbackify, "callbackify");
var access2 = callbackify(access);
var appendFile2 = callbackify(appendFile);
var chown2 = callbackify(chown);
var chmod2 = callbackify(chmod);
var copyFile2 = callbackify(copyFile);
var cp2 = callbackify(cp);
var lchown2 = callbackify(lchown);
var lchmod2 = callbackify(lchmod);
var link2 = callbackify(link);
var lstat2 = callbackify(lstat);
var lutimes2 = callbackify(lutimes);
var mkdir2 = callbackify(mkdir);
var mkdtemp2 = callbackify(mkdtemp);
var realpath2 = callbackify(realpath);
var open2 = callbackify(open);
var opendir2 = callbackify(opendir);
var readdir2 = callbackify(readdir);
var readFile2 = callbackify(readFile);
var readlink2 = callbackify(readlink);
var rename2 = callbackify(rename);
var rm2 = callbackify(rm);
var rmdir2 = callbackify(rmdir);
var stat2 = callbackify(stat);
var symlink2 = callbackify(symlink);
var truncate2 = callbackify(truncate);
var unlink2 = callbackify(unlink);
var utimes2 = callbackify(utimes);
var writeFile2 = callbackify(writeFile);
var statfs2 = callbackify(statfs);
var close = /* @__PURE__ */ notImplementedAsync("fs.close");
var createReadStream = /* @__PURE__ */ notImplementedAsync("fs.createReadStream");
var createWriteStream = /* @__PURE__ */ notImplementedAsync("fs.createWriteStream");
var exists = /* @__PURE__ */ notImplementedAsync("fs.exists");
var fchown = /* @__PURE__ */ notImplementedAsync("fs.fchown");
var fchmod = /* @__PURE__ */ notImplementedAsync("fs.fchmod");
var fdatasync = /* @__PURE__ */ notImplementedAsync("fs.fdatasync");
var fstat = /* @__PURE__ */ notImplementedAsync("fs.fstat");
var fsync = /* @__PURE__ */ notImplementedAsync("fs.fsync");
var ftruncate = /* @__PURE__ */ notImplementedAsync("fs.ftruncate");
var futimes = /* @__PURE__ */ notImplementedAsync("fs.futimes");
var lstatSync = /* @__PURE__ */ notImplementedAsync("fs.lstatSync");
var read = /* @__PURE__ */ notImplementedAsync("fs.read");
var readv = /* @__PURE__ */ notImplementedAsync("fs.readv");
var realpathSync = /* @__PURE__ */ notImplementedAsync("fs.realpathSync");
var statSync = /* @__PURE__ */ notImplementedAsync("fs.statSync");
var unwatchFile = /* @__PURE__ */ notImplementedAsync("fs.unwatchFile");
var watch2 = /* @__PURE__ */ notImplementedAsync("fs.watch");
var watchFile = /* @__PURE__ */ notImplementedAsync("fs.watchFile");
var write = /* @__PURE__ */ notImplementedAsync("fs.write");
var writev = /* @__PURE__ */ notImplementedAsync("fs.writev");
var _toUnixTimestamp = /* @__PURE__ */ notImplementedAsync("fs._toUnixTimestamp");
var openAsBlob = /* @__PURE__ */ notImplementedAsync("fs.openAsBlob");
var glob2 = /* @__PURE__ */ notImplementedAsync("fs.glob");
var appendFileSync = /* @__PURE__ */ notImplemented("fs.appendFileSync");
var accessSync = /* @__PURE__ */ notImplemented("fs.accessSync");
var chownSync = /* @__PURE__ */ notImplemented("fs.chownSync");
var chmodSync = /* @__PURE__ */ notImplemented("fs.chmodSync");
var closeSync = /* @__PURE__ */ notImplemented("fs.closeSync");
var copyFileSync = /* @__PURE__ */ notImplemented("fs.copyFileSync");
var cpSync = /* @__PURE__ */ notImplemented("fs.cpSync");
var existsSync = /* @__PURE__ */ __name(() => false, "existsSync");
var fchownSync = /* @__PURE__ */ notImplemented("fs.fchownSync");
var fchmodSync = /* @__PURE__ */ notImplemented("fs.fchmodSync");
var fdatasyncSync = /* @__PURE__ */ notImplemented("fs.fdatasyncSync");
var fstatSync = /* @__PURE__ */ notImplemented("fs.fstatSync");
var fsyncSync = /* @__PURE__ */ notImplemented("fs.fsyncSync");
var ftruncateSync = /* @__PURE__ */ notImplemented("fs.ftruncateSync");
var futimesSync = /* @__PURE__ */ notImplemented("fs.futimesSync");
var lchownSync = /* @__PURE__ */ notImplemented("fs.lchownSync");
var lchmodSync = /* @__PURE__ */ notImplemented("fs.lchmodSync");
var linkSync = /* @__PURE__ */ notImplemented("fs.linkSync");
var lutimesSync = /* @__PURE__ */ notImplemented("fs.lutimesSync");
var mkdirSync = /* @__PURE__ */ notImplemented("fs.mkdirSync");
var mkdtempSync = /* @__PURE__ */ notImplemented("fs.mkdtempSync");
var openSync = /* @__PURE__ */ notImplemented("fs.openSync");
var opendirSync = /* @__PURE__ */ notImplemented("fs.opendirSync");
var readdirSync = /* @__PURE__ */ notImplemented("fs.readdirSync");
var readSync = /* @__PURE__ */ notImplemented("fs.readSync");
var readvSync = /* @__PURE__ */ notImplemented("fs.readvSync");
var readFileSync = /* @__PURE__ */ notImplemented("fs.readFileSync");
var readlinkSync = /* @__PURE__ */ notImplemented("fs.readlinkSync");
var renameSync = /* @__PURE__ */ notImplemented("fs.renameSync");
var rmSync = /* @__PURE__ */ notImplemented("fs.rmSync");
var rmdirSync = /* @__PURE__ */ notImplemented("fs.rmdirSync");
var symlinkSync = /* @__PURE__ */ notImplemented("fs.symlinkSync");
var truncateSync = /* @__PURE__ */ notImplemented("fs.truncateSync");
var unlinkSync = /* @__PURE__ */ notImplemented("fs.unlinkSync");
var utimesSync = /* @__PURE__ */ notImplemented("fs.utimesSync");
var writeFileSync = /* @__PURE__ */ notImplemented("fs.writeFileSync");
var writeSync = /* @__PURE__ */ notImplemented("fs.writeSync");
var writevSync = /* @__PURE__ */ notImplemented("fs.writevSync");
var statfsSync = /* @__PURE__ */ notImplemented("fs.statfsSync");
var globSync = /* @__PURE__ */ notImplemented("fs.globSync");

// node_modules/unenv/dist/runtime/node/fs.mjs
var fs_default = {
  F_OK,
  R_OK,
  W_OK,
  X_OK,
  constants: constants_exports,
  promises: promises_default,
  Dir,
  Dirent,
  FileReadStream,
  FileWriteStream,
  ReadStream: ReadStream2,
  Stats,
  WriteStream: WriteStream2,
  _toUnixTimestamp,
  access: access2,
  accessSync,
  appendFile: appendFile2,
  appendFileSync,
  chmod: chmod2,
  chmodSync,
  chown: chown2,
  chownSync,
  close,
  closeSync,
  copyFile: copyFile2,
  copyFileSync,
  cp: cp2,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchmod,
  fchmodSync,
  fchown,
  fchownSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  glob: glob2,
  lchmod: lchmod2,
  globSync,
  lchmodSync,
  lchown: lchown2,
  lchownSync,
  link: link2,
  linkSync,
  lstat: lstat2,
  lstatSync,
  lutimes: lutimes2,
  lutimesSync,
  mkdir: mkdir2,
  mkdirSync,
  mkdtemp: mkdtemp2,
  mkdtempSync,
  open: open2,
  openAsBlob,
  openSync,
  opendir: opendir2,
  opendirSync,
  read,
  readFile: readFile2,
  readFileSync,
  readSync,
  readdir: readdir2,
  readdirSync,
  readlink: readlink2,
  readlinkSync,
  readv,
  readvSync,
  realpath: realpath2,
  realpathSync,
  rename: rename2,
  renameSync,
  rm: rm2,
  rmSync,
  rmdir: rmdir2,
  rmdirSync,
  stat: stat2,
  statSync,
  statfs: statfs2,
  statfsSync,
  symlink: symlink2,
  symlinkSync,
  truncate: truncate2,
  truncateSync,
  unlink: unlink2,
  unlinkSync,
  unwatchFile,
  utimes: utimes2,
  utimesSync,
  watch: watch2,
  watchFile,
  write,
  writeFile: writeFile2,
  writeFileSync,
  writeSync,
  writev,
  writevSync
};

// node_modules/schemaimporter/src/index.mjs
import path from "path";
import { fileURLToPath } from "url";
var SchemaImporter = class _SchemaImporter {
  static {
    __name(this, "SchemaImporter");
  }
  static async loadFromFolder({
    schemaRootFolder = "./../schemas/v1.2.0/",
    excludeSchemasWithImports = true,
    excludeSchemasWithRequiredServerParams = false,
    addAdditionalMetaData = false,
    outputType = null
    // [ 'onlyPath', 'onlySchema' ]
  }) {
    let schemas = [];
    schemas = _SchemaImporter.#getSchemaPaths({ schemaRootFolder });
    schemas = _SchemaImporter.#addHasImports({ schemas, excludeSchemasWithImports });
    if (outputType === "onlyPath") {
      return schemas;
    }
    schemas = await _SchemaImporter.#addSchemas({ schemas });
    schemas = _SchemaImporter.#excludeSchemasWithRequiredServerParams({ schemas, excludeSchemasWithRequiredServerParams });
    schemas = _SchemaImporter.#addSchemaMetaData({ schemas, addAdditionalMetaData });
    if (outputType === "onlySchema") {
      schemas = schemas.map((item) => item["schema"]);
    }
    return schemas;
  }
  static async loadFromFolderStatic({
    schemaRootFolder = "./../schemas/v1.2.0/",
    excludeSchemasWithImports = true,
    excludeSchemasWithRequiredServerParams = false,
    addAdditionalMetaData = false,
    outputType = null
    // [ 'onlyPath', 'onlySchema' ]
  }) {
    const { allSchemas: allSchemas2 } = await Promise.resolve().then(() => (init_static_import(), static_import_exports));
    let schemas = allSchemas2.filter(({ relativePath }) => relativePath.includes(schemaRootFolder.replace("./../schemas/", ""))).filter(({ hasImport }) => excludeSchemasWithImports === true ? hasImport === false : true).filter(({ requiredServerParams }) => excludeSchemasWithRequiredServerParams === true ? requiredServerParams.length === 0 : true);
    if (outputType === "onlyPath") {
      return schemas;
    }
    let index = 0;
    for (const { loadSchema } of schemas) {
      const { schema: schema115 } = await loadSchema();
      schemas[index]["schema"] = schema115;
      index++;
    }
    if (outputType === "onlySchema") {
      schemas = schemas.map((item) => item["schema"]);
    }
    return schemas;
  }
  static #getSchemaPaths({ schemaRootFolder }) {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const schemaPath = path.resolve(__dirname, schemaRootFolder);
    if (!fs_default.existsSync(schemaPath)) {
      throw new Error(`Schema root folder does not exist: ${schemaPath}`);
    }
    const result = this.#getAllFiles({ dirPath: schemaPath }).filter((file2) => !file2.endsWith(".DS_Store")).map((file2) => ({
      folderName: path.basename(path.dirname(file2)),
      absolutePath: path.resolve(file2)
    })).filter(({ absolutePath }) => absolutePath.endsWith(".mjs"));
    return result;
  }
  static #addHasImports({ schemas, excludeSchemasWithImports }) {
    schemas = schemas.map((schema115) => {
      const { absolutePath } = schema115;
      const hasImport = fs_default.readFileSync(absolutePath, "utf-8").split("\n").some((line) => {
        const trimmed = line.trim();
        const one = trimmed.startsWith("import ");
        const two = line.indexOf("import(") !== -1 || line.indexOf("import (") !== -1;
        return one || two;
      });
      schema115["hasImport"] = hasImport;
      return schema115;
    }).filter((schema115) => {
      if (excludeSchemasWithImports === true) {
        const { hasImport } = schema115;
        if (hasImport === true) {
          return false;
        }
      }
      return true;
    });
    return schemas;
  }
  static async #addSchemas({ schemas, withSchema }) {
    const result = await Promise.all(
      schemas.map(async (item) => {
        const { absolutePath } = item;
        const { schema: schema115 } = await import(absolutePath);
        item["schema"] = schema115;
        return item;
      })
    );
    return result;
  }
  static #addSchemaMetaData({ schemas, addAdditionalMetaData }) {
    if (addAdditionalMetaData === false) {
      return schemas;
    }
    schemas = schemas.map((item) => {
      const { schema: schema115, absolutePath } = item;
      const { namespace, routes, tags, requiredServerParams } = schema115;
      item = { ...item, namespace, tags, requiredServerParams };
      item["routeNames"] = Object.keys(routes);
      item["schemaFolder"] = path.basename(path.dirname(absolutePath));
      item["schemaName"] = path.basename(absolutePath, ".mjs");
      item["fileName"] = path.basename(absolutePath);
      return item;
    });
    return schemas;
  }
  static #getAllFiles({ dirPath, arrayOfFiles = [] }) {
    const files = fs_default.readdirSync(dirPath);
    files.filter((file2) => !file2.endsWith(".DS_Store")).forEach((file2) => {
      const fullPath = path.join(dirPath, file2);
      if (fs_default.statSync(fullPath).isDirectory()) {
        this.#getAllFiles({ dirPath: fullPath, arrayOfFiles });
      } else {
        arrayOfFiles.push(fullPath);
      }
    });
    return arrayOfFiles;
  }
  static #excludeSchemasWithRequiredServerParams({ schemas, excludeSchemasWithRequiredServerParams }) {
    if (excludeSchemasWithRequiredServerParams === false) {
      return schemas;
    }
    schemas = schemas.filter((item) => {
      const { schema: { requiredServerParams } } = item;
      if (!requiredServerParams) {
        console.log(`Schema ${item.fileName} has no requiredServerParams`);
        return false;
      }
      if (requiredServerParams.length > 0) {
        return false;
      }
      return true;
    });
    return schemas;
  }
};

// src/index.ts
var MyMCP = class extends McpAgent {
  constructor() {
    super(...arguments);
    this.server = new McpServer({
      name: "FlowMCP Schema Server",
      version: "1.0.0"
    });
  }
  static {
    __name(this, "MyMCP");
  }
  async init() {
    const env2 = globalThis.env || {};
    console.log("Environment variables:", env2);
    const config3 = {
      cfgSchemaImporter: {
        excludeSchemasWithImports: (env2.SCHEMA_EXCLUDE_IMPORTS || "true") === "true",
        excludeSchemasWithRequiredServerParams: (env2.SCHEMA_EXCLUDE_SERVER_PARAMS || "true") === "true",
        addAdditionalMetaData: (env2.SCHEMA_ADD_METADATA || "false") === "true"
      },
      cfgFilterArrayOfSchemas: {
        includeNamespaces: env2.FILTER_INCLUDE_NAMESPACES ? env2.FILTER_INCLUDE_NAMESPACES.split(",") : [],
        excludeNamespaces: env2.FILTER_EXCLUDE_NAMESPACES ? env2.FILTER_EXCLUDE_NAMESPACES.split(",") : [],
        activateTags: env2.FILTER_ACTIVATE_TAGS ? env2.FILTER_ACTIVATE_TAGS.split(",") : []
      }
    };
    console.log("Config:", config3);
    console.log("Start import...");
    const arrayOfSchemas = await SchemaImporter.loadFromFolderStatic({
      excludeSchemasWithImports: true,
      excludeSchemasWithRequiredServerParams: true,
      addAdditionalMetaData: false,
      outputType: "onlySchema"
    });
    const { filteredArrayOfSchemas } = FlowMCP.filterArrayOfSchemas({
      arrayOfSchemas,
      includeNamespaces: ["cryptocompare", "coingecko"],
      excludeNamespaces: [],
      activateTags: []
    });
    for (const schema115 of filteredArrayOfSchemas) {
      FlowMCP.activateServerTools({
        server: this.server,
        schema: schema115,
        serverParams: []
      });
    }
    console.log("Import finished");
    this.server.tool("ping6", {}, async () => ({
      content: [{ type: "text", text: "pong - FlowMCP Server is running!" }]
    }));
    console.log("Tool registration completed");
  }
};
var index_default = {
  fetch(request, env2, ctx) {
    const url2 = new URL(request.url);
    const routePath = env2.ROUTE_PATH || "/mcp";
    globalThis.env = env2;
    if (url2.pathname === "/sse" || url2.pathname === "/sse/message") {
      return MyMCP.serveSSE("/sse").fetch(request, env2, ctx);
    }
    if (url2.pathname === routePath) {
      return MyMCP.serve(routePath).fetch(request, env2, ctx);
    }
    return new Response("Not found", { status: 404 });
  }
};
export {
  MyMCP,
  index_default as default
};
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

partysocket/dist/chunk-ZCZZNAX5.mjs:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=index.js.map
